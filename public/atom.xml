<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[yutian's blog]]></title>
  <subtitle><![CDATA[stay hungry, stay foolish]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yutianx.info/"/>
  <updated>2015-10-03T16:22:43.000Z</updated>
  <id>http://yutianx.info/</id>
  
  <author>
    <name><![CDATA[雨天]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[LeetCode: Lowest Common Ancestor of a Binary Tree]]></title>
    <link href="http://yutianx.info/2015/10/03/2015-10-03-leetcode-lowest-common-ancestor-of-a-binary-tree/"/>
    <id>http://yutianx.info/2015/10/03/2015-10-03-leetcode-lowest-common-ancestor-of-a-binary-tree/</id>
    <published>2015-10-03T13:49:20.000Z</published>
    <updated>2015-10-03T16:22:43.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
</blockquote>
<p>想法还是很简单，如果要判断当前节点是否是两个节点$p,q$的最低公共父节点，（假设我们是从上往下开始判断的），那么如果当前节点与两个节点之一相等，那么当前节点可能是这两个节点的最低公共父节点，返回；如果不相等，那么就在当前节点的两个子节点中找；如果再两个子节点中都找到了可能的最低公共父节点，那么当前节点即是结果，否则返回两个子节点找到得结果。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == NULL)</span><br><span class="line">            <span class="keyword">return</span> NULL;</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        TreeNode *left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        TreeNode *right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != NULL &amp;&amp; right != NULL)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == NULL &amp;&amp; right == NULL)</span><br><span class="line">            <span class="keyword">return</span> NULL;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> left != NULL ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
</blockquote>
<p>想法还是很简单，如果要判]]>
    </summary>
    
      <category term="LeetCode" scheme="http://yutianx.info/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode: Add Digits]]></title>
    <link href="http://yutianx.info/2015/09/30/2015-09-30-leetcode-add-digits/"/>
    <id>http://yutianx.info/2015/09/30/2015-09-30-leetcode-add-digits/</id>
    <published>2015-09-30T13:49:20.000Z</published>
    <updated>2015-10-03T16:26:02.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.</p>
<p>For example:</p>
<p>Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.</p>
</blockquote>
<p>此题如果用一般的方法解决，很容易，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">                tmp += num % <span class="number">10</span>;</span><br><span class="line">                num = num / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是题中还提到可以不用循环就可以解决，但一般这都属于一些比较技巧性的东西，见多就好，如果临时想起，必然是大神了。</p>
<p>下面记录一下从别处看来的解法：</p>
<p>假设输入的num是一个5位的数字，各位数分别为$a, b, c, d, e$。那么$num = (a+b+c+d+e)+(a\times9999+b\times999+c\times99+d\times9)$。</p>
<p>然后对$a+b+c+d+e$重复进行此操作，最后将得到$num=x+y$,其中$1&lt;=x&lt;=9$,$y$则是一个能被9整除的表达式。我们所需要的结果就是$x$。</p>
<p>而$x=(x-1)\%9 + 1$,（此处是因为$x$可能为9），亦即$x=(num-1)\%9+1$，（因为$y$能被9整除）。</p>
<p>所以答案就更简单了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (num - <span class="number">1</span>) % <span class="number">9</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.</p>
<p>For example:</p>]]>
    </summary>
    
      <category term="LeetCode" scheme="http://yutianx.info/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker文件系统]]></title>
    <link href="http://yutianx.info/2015/05/20/2015-05-20-docker-filesystem/"/>
    <id>http://yutianx.info/2015/05/20/2015-05-20-docker-filesystem/</id>
    <published>2015-05-20T05:11:20.000Z</published>
    <updated>2015-09-30T11:41:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Docker文件系统概述">Docker文件系统概述</h2><p>典型的Linux文件系统由bootfs和rootfs两部分组成，bootfs(boot file system)主要包含 bootloader和kernel，bootloader主要是引导加载kernel，当kernel被加载到内存中后 bootfs就被umount了。 rootfs (root file system) 包含的就是典型 Linux 系统中的/dev，/proc，/bin，/etc等标准目录和文件。</p>
<p><img src="/img/docker-filesystem-1.png" alt=""></p>
<p>联合文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。</p>
<p>联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。另外，不同 Docker 容器就可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。<br>Aufs也是一种Union FS, 支持将不同的目录挂载到同一个虚拟文件系统下，并实现一种layer的概念。Aufs将挂载到同一虚拟文件系统下的多个目录分别设置成read-only，read-write以及whiteout-able权限，对read-only目录只能读，而写操作只能实施在read-write目录中。重点在于，写操作是在read-only上的一种增量操作，不影响read-only目录。当挂载目录的时候要严格按照各目录之间的这种增量关系，将被增量操作的目录优先于在它基础上增量操作的目录挂载，待所有目录挂载结束了，继续挂载一个read-write目录，如此便形成了一种层次结构。</p>
<p>Docker镜像的典型结构如下图。传统的Linux加载bootfs时会先将rootfs设为read-only，然后在系统自检之后将rootfs从read-only改为read-write，然后我们就可以在rootfs上进行写和读的操作了。但Docker的镜像却不是这样，它在bootfs自检完毕之后并不会把rootfs的read-only改为read-write。而是利用union mount（UnionFS的一种挂载机制）将一个或多个read-only的rootfs加载到之前的read-only的rootfs层之上。在加载了这么多层的rootfs之后，仍然让它看起来只像是一个文件系统，在Docker的体系里把union mount的这些read-only的rootfs叫做Docker的镜像。但是，此时的每一层rootfs都是read-only的，我们此时还不能对其进行操作。当我们创建一个容器，也就是将Docker镜像进行实例化，系统会在一层或是多层read-only的rootfs之上分配一层空的read-write的rootfs。</p>
<p><img src="/img/docker-filesystem-2.png" alt=""></p>
<p>Docker 目前支持的联合文件系统种类包括 AUFS, btrfs, vfs 和 DeviceMapper。</p>
<h2 id="Docker的文件系统驱动">Docker的文件系统驱动</h2><p>Docker定义了一个驱动原型的接口，<code>ProtoDriver</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ProtoDriver <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="typename">string</span></span><br><span class="line">    Create(id, parent <span class="typename">string</span>) error</span><br><span class="line">    Remove(id <span class="typename">string</span>) error</span><br><span class="line">    Get(id, mountLabel <span class="typename">string</span>) (dir <span class="typename">string</span>, err error)</span><br><span class="line">    Put(id <span class="typename">string</span>) error</span><br><span class="line">    Exists(id <span class="typename">string</span>) <span class="typename">bool</span></span><br><span class="line">    Status() [][<span class="number">2</span>]<span class="typename">string</span></span><br><span class="line">    Cleanup() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还定义了一个<code>Driver</code>的接口，该接口继承了<code>ProtoDriver</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Driver <span class="keyword">interface</span> &#123;</span><br><span class="line">    ProtoDriver</span><br><span class="line">    Diff(id, parent <span class="typename">string</span>) (archive.Archive, error)</span><br><span class="line">    Changes(id, parent <span class="typename">string</span>) ([]archive.Change, error)</span><br><span class="line">    ApplyDiff(id, parent <span class="typename">string</span>, diff archive.ArchiveReader) (size <span class="typename">int64</span>, err error)</span><br><span class="line">    DiffSize(id, parent <span class="typename">string</span>) (size <span class="typename">int64</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ProtoDriver中定义了一些各个文件系统所需要的基本操作，比如Create,Remove等。Driver继承了ProtoDriver，并增加了几个函数，比如Diff,ApplyDiff等，这主要是为了向aufs这种有layer概念的文件系统，还有像devicemapper这种有snapshot概念的文件系统构建设备提供方便。<br>像aufs直接是支持Diff,ApplyDiff等操作的，所以aufs的驱动直接实现了这个Driver这个接口。但是devicemapper并不直接支持这种操作，所以这里又定义了一个naiveDiffDriver的struct，也继承了ProtoDriver,但是又添加了Driver中多出的几个函数。这样，devicemapper等不直接支持那些操作的文件系统也可以间接得通过naiveDiffDriver实现这些功能。</p>
<h2 id="Docker对文件系统的初始化">Docker对文件系统的初始化</h2><p><img src="/img/docker-filesystem-3.png" alt=""></p>
<p>在initFunc中，会调用已经注册的文件系统驱动来进行初始化，或者如果没有注册过驱动，会按照文件系统的优先级来对文件系统进行初始化。<br>例如，在支持aufs的文件系统中，就会调用aufs文件系统提供的initFunc进行初始化；在支持devicemapper的文件系统中，就会调用devicemapper的initFunc进行初始化。</p>
<h2 id="关键流程">关键流程</h2><h3 id="下载镜像">下载镜像</h3><p><img src="/img/docker-filesystem-4.png" alt=""></p>
<p>从上图可以看出，在下载镜像时，docker先把镜像从hub上下载下来，然后注册该镜像。注册的流程就是以该镜像的parent的设备为基础，构建一个新的设备。然后将下载下来的image所做的改动应用到新建的设备上，这样就形成了一个以该image的ID为名的设备了。其实就是一个镜像。</p>
<h3 id="创建容器">创建容器</h3><p><img src="/img/docker-filesystem-5.png" alt=""></p>
<p>从上图我们可以看到，在创建容器时，docker创建了两个设备，一个设备的名称为container.ID-init，简称为initID,另一个名称为container.ID。intid是根据imageId这个设备创建的，从前面下载镜像的流程中我们可以知道，只要存在image，那么imageID这个镜像也就会存在。创建完成initID后，会对该设备进行初始化操作，比如说导入一些跟容器相关的配置文件等。然后根据初始化完成的设备initID构建一个名为container.ID的设备，这个设备就是容器的设备了，将该设备挂载到相应的挂载点上，我们就可以看到创建的容器了。Docker本身也是这么做的。</p>
<h3 id="创建镜像">创建镜像</h3><p>创建镜像的流程如下：<br><img src="/img/docker-filesystem-6.png" alt=""><br>当我们使用commit命令创建一个镜像时，首先导出我们在容器中所做的修改，这个功能由函数Diff来实现。此时将要创建的image的ID为imgID,而容器所使用的镜像ID为parentId。我们首先根据parentID这个设备来新建一个名为imgID的设备。然后我们将得到的修改rwTar添加到imgID这个设备中。这样，我们就得到了一个新的镜像。</p>
<h2 id="Devicemapper">Devicemapper</h2><h3 id="背景介绍">背景介绍</h3><h4 id="Snapshot">Snapshot</h4><p>Snapshot是Lvm提供的一种特性，它可以在不中断服务运行的情况下为the origin（original device）创建一个虚拟快照(Snapshot)，它具有以下几个特点：</p>
<ul>
<li>当the origin内容发生变化时，snapshot对变化的部分做一个拷贝以用来对the origin进行重构。</li>
<li>因为只对变化的部分做拷贝，所以Lvm的Snapshot在读操作频繁而写操作不频繁的情况下占用很少的一部分空间便能完成特定任务。</li>
<li>当Snapshot大小耗尽或者远大于实际需求时，我们可以对其大小进行调节。</li>
<li>当对Snapshot的数据进行写操作的时候，Snapshot实施相应操作，并丢弃从the origin的拷贝，以后的操作以写操作之后Snapshot中的数据为准。</li>
<li>在某些发行版的Linux系统下，可以使用lvconvert的—merge选项将Snapshot合并回the origin。</li>
</ul>
<h4 id="Thin-Provisioning">Thin-Provisioning</h4><p>Thin-Provisioning是一项利用虚拟化方法减少物理存储部署的技术，可最大限度提升存储空间利用率。下图中展示了某位用户向服务器管理员请求分配10TB的资源的情形。实际情况中这个数值往往是峰值，根据使用情况，分配2TB就已足够。因此，系统管理员准备2TB的物理存储，并给服务器分配10TB的虚拟卷。服务器即可基于仅占虚拟卷容量1/5的现有物理磁盘池开始运行。这样的“始于小”方案能够实现更高效地利用存储容量。</p>
<p><img src="/img/docker-filesystem-7.png" alt=""></p>
<p>Thin-provisioning Snapshot结合Thin-Provisioning和Snapshot两种技术，允许多个虚拟设备同时挂载到一个数据卷以达到数据共享的目的。Thin-Provisioning Snapshot的特点如下：</p>
<ul>
<li>可以将不同的snaptshot挂载到同一个the origin上，节省了磁盘空间。</li>
<li>当多个Snapshot挂载到了同一个the origin上，并在the origin上发生写操作时，将会触发COW操作。这样不会降低效率。</li>
<li>Thin-Provisioning Snapshot支持递归操作，即一个Snapshot可以作为另一个Snapshot的the origin，且没有深度限制。</li>
<li>在Snapshot上可以创建一个逻辑卷，这个逻辑卷在实际写操作（COW，Snapshot写操作）发生之前是不占用磁盘空间的。</li>
</ul>
<p>Thin-Provisioning Snapshot虽然有诸多优点，但是也有很多不足之处，例如大小固定等问题。<br>Thin-Provisioning Snapshot是作为device mapper的一个target在内核中实现的。Device mapper 是Linux 2.6内核中提供的一种从逻辑设备到物理设备的映射框架机制。在该机制下，用户可以很方便的根据自己的需要制定实现存储资源的管理策略，如条带化，镜像，快照等。<br>Device Mapper主要包含内核空间的映射和用户空间的device mapper库及dmsetup工具。Device Mapper库是对ioctl、用户空间创建删除Device Mapper逻辑设备所需必要操作的封装，dmsetup是一个提供给用户直接可用的创建删除device mapper设备的命令行工具</p>
<h3 id="devicemapper概述">devicemapper概述</h3><p>Docker在初始化过程中，会在<code>/var/lib/docker/devicemapper/devicemapper</code>目录下创建一个100G的稀疏文件<code>data</code>，用于存储数据，和一个2G的稀疏文件<code>metadata</code>用于存储元数据然后分别附加到回环块设备<code>/dev/loop0</code>和<code>/dev/loop1</code>。然后基于回环块设备创建<code>thin pool</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/dev/loop0: [<span class="number">64769</span>]:<span class="number">135007216</span> (/var/lib/docker/devicemapper/devicemapper/data)</span><br><span class="line">/dev/loop1: [<span class="number">64769</span>]:<span class="number">135007217</span> (/var/lib/docker/devicemapper/devicemapper/metadata)</span><br></pre></td></tr></table></figure></p>
<p>在创建容器时，devicemapper会在thin pool中基于一个基础镜像新建一个默认大小为10G的设备，然后将设备的信息写入到metadata中。我们可以通过修改docker的启动参数来调整data文件和metadata文件的大小，比如将data文件的大小修改为200G，metadata文件大小修改为4G，默认设备大小修改为20G：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="operator">-d</span> --storage-opt dm.basesize=<span class="number">20</span>G --storage-opt dm.loopdatasize=<span class="number">200</span>G --storage-opt dm.loopmetadatasize=<span class="number">4</span>G</span><br></pre></td></tr></table></figure></p>
<p>当修改配置，重启docker服务时，所有的镜像，容器都会被删除，所以在重新设置时要注意做好备份。</p>
<h3 id="关键流程-1">关键流程</h3><h4 id="初始化devicemapper">初始化devicemapper</h4><p><img src="/img/docker-filesystem-8.png" alt=""><br>初始化devicemapper时，docker会基于data文件创建一个thin pool，用于存储容器设备。然后建立一个基础镜像baseImage。如果创建设备时没有指定父设备的时候，就会以baseImage为父设备新建一个设备。</p>
<h4 id="创建设备">创建设备</h4><p><img src="/img/docker-filesystem-9.png" alt=""><br>从上可以看出，devicemapper创建设备的流程为：先根据父设备创建一个快照，生成一个新的设备，然后注册该设备，即将该设备的元数据写入metadata文件中。</p>
<h2 id="AUFS">AUFS</h2><h3 id="AUFS概述">AUFS概述</h3><p>AUFS (AnotherUnionFS) 是一种 Union FS, 简单来说就是支持将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)的文件系统。 Aufs driver是docker 最早支持的driver，但是aufs只是linux内核的一个补丁集而且不太可以会被合并加入到linux内核中。但是由于aufs是唯一一个 storage driver可以实现容器间共享可执行及可共享的运行库, 所以当你跑成千上百个拥有相同程序代码或者运行库时时候，aufs是个相当不错的选择。</p>
<h4 id="镜像存储">镜像存储</h4><p>在AUFS中，镜像存储的位置为<code>/var/lib/docker/aufs</code>。Aufs目录的结构如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aufs/</span><br><span class="line">├── diff</span><br><span class="line">├── layers</span><br><span class="line">└── mnt</span><br></pre></td></tr></table></figure></p>
<p>其中<code>diff</code>目录下存储的是镜像的具体信息；<code>layers</code>目录下存储的是镜像的继承结构,<code>mnt</code>是启动容器rootfs的挂载目录。下面分别介绍一下各个目录的具体信息。</p>
<ul>
<li><p>Layers目录<br><code>Layer</code>目录下存放的是每个镜像的继承关系文件。比如说<code>ubuntu:latest</code>镜像的imageid为<code>2103b00b3fdf1d26a86aded36ae73c1c425def0f779a6e69073b3b77377df348</code>，那么在这个目录下就会存在一个名为<code>2103b00b3fdf1d26a86aded36ae73c1c425def0f779a6e69073b3b77377df348</code>的文件，存储了镜像的继承结构，文件的内容为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>faa69f72743ce3a18508e840ff84598952<span class="built_in">fc</span>05bd1de5fd54c6bc0f8ca835884</span><br><span class="line"><span class="number">76</span>b658ecb5644a4aca23b35de695803ad2e223da087d4f8015016021bd970169</span><br><span class="line">f0dde87450ec8236a64aebd3e8b499fe2772fca5e837ecbfa97bd8ae380c605e</span><br><span class="line"><span class="number">511136</span>ea3c5a64f264b78b5433614aec563103b4d4702f3ba7d4d2698e22c158</span><br></pre></td></tr></table></figure>
</li>
<li><p>Diff目录<br>因为docker中，每一个镜像都是基于上一层镜像。所以在<code>diff</code>目录下，存储的是每一个镜像相对于上一层镜像所做的增量修改。如果只有<code>ubuntu:latest</code>这一个镜像，那么目录下就会存在以下几个目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2103</span>b00b3fdf1d26a86aded36ae73c1c425def0f779a6e69073b3b77377df348</span><br><span class="line"><span class="number">4</span>faa69f72743ce3a18508e840ff84598952<span class="built_in">fc</span>05bd1de5fd54c6bc0f8ca835884</span><br><span class="line"><span class="number">76</span>b658ecb5644a4aca23b35de695803ad2e223da087d4f8015016021bd970169</span><br><span class="line">f0dde87450ec8236a64aebd3e8b499fe2772fca5e837ecbfa97bd8ae380c605e</span><br><span class="line"><span class="number">511136</span>ea3c5a64f264b78b5433614aec563103b4d4702f3ba7d4d2698e22c158</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>每一个目录下保存的即为该层镜像基于上层镜像所做的修改。</p>
<ul>
<li>mnt目录<br><code>mnt</code>是挂载文件系统的目录，比如说启动一个<code>ubuntu:lastest</code>的容器，在<code>mnt</code>下就能够看到容器id的目录，目录下是容器的rootfs.</li>
</ul>
<h4 id="创建容器时的文件操作">创建容器时的文件操作</h4><p>创建一个基于<code>ubuntu:lastest</code>的容器并启动，假如容器id为<code>3eaa0e6ed18f949e0d0cf2ddfaa44c166063e8753676e2ec2c61ed2d2bd134f1</code>，我们就会发现在<code>diff</code>目录下会多出两个目录：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>eaa0e6ed18f949e0d0cf2ddfaa44c166063e8753676e2ec2c61ed2d2bd134f1</span><br><span class="line"><span class="number">3</span>eaa0e6ed18f949e0d0cf2ddfaa44c166063e8753676e2ec2c61ed2d2bd134f1-init</span><br></pre></td></tr></table></figure></p>
<p>其中<code>3eaa0e6ed18f949e0d0cf2ddfaa44c166063e8753676e2ec2c61ed2d2bd134f1-init</code>存储的是容器的初始信息，比如说一些在启动容器时需要加载的一些配置文件，比如<code>hosts</code>, <code>resolv.conf</code>等。而<code>3eaa0e6ed18f949e0d0cf2ddfaa44c166063e8753676e2ec2c61ed2d2bd134f1</code>目录下存储的是在容器中所做的修改。如果我们在容器中新建一个名为<code>test</code>的大小为<code>10M</code>的文件，那么我们会在<code>ec872d7343abdcf14ec900a0667363e78eaf603fee61f09ba6e6b41773f14f85</code>中看到该<code>test</code>文件，而<code>3eaa0e6ed18f949e0d0cf2ddfaa44c166063e8753676e2ec2c61ed2d2bd134f1-init</code>目录中不会有什么修改。<br>此时，我们如果commit该容器，得到一个imageid为<code>ec872d7343abdcf14ec900a0667363e78eaf603fee61f09ba6e6b41773f14f85</code>的镜像。而diff目录下以该imageid为目录名的目录下存储的正是该<code>test</code>文件。</p>
<h3 id="关键流程-2">关键流程</h3><h4 id="aufs的初始化">aufs的初始化</h4><p>Aufs在初始化Init函数中主要完成了以下几个操作：</p>
<ul>
<li>调用surportsAufs函数加载Aufs模块。</li>
<li>调用MakePrivate在系统中为/var/lib/docker/aufs创建一个挂载点。这里的实现原理与mount —bind命令一样，只不过mount命令的源文件夹和目的文件夹一样，在系统中只创建了挂载点而已。并且这个挂载点的内容即不受源文件夹的影响也不影响源文件夹。</li>
<li>最后，在/var/lib/docker/aufs创建mnt， diff， layers文件夹。mnt文件夹为容器的挂载点目录，每一个容器在mnt下都有一个长ID目录，对应为该容器的rootfs的挂载点。diff有着与mnt中对应的长ID目录，这里的每个目录对应Docker 镜像的一个layer层，里面存放的是该layer相比较于父layer变化的内容。注意： 这里才是存放我们在容器中看到的内容的地方，比如/usr, /bin等等。</li>
</ul>
<h4 id="创建设备-1">创建设备</h4><p><img src="/img/docker-filesystem-10.png" alt=""><br>从上可以看出，aufs创建设备的步骤很简单，首先是在mnt,diff目录下创建相应的目录，然后创建layers文件，里面记录的是image的层次关系。</p>
<h2 id="参考文献">参考文献</h2><p><a href="http://www.infoq.com/cn/articles/analysis-of-docker-file-system-aufs-and-devicemapper/(大部分都是从这摘抄过来的，感谢作者写得这么细致" target="_blank" rel="external">http://www.infoq.com/cn/articles/analysis-of-docker-file-system-aufs-and-devicemapper/(大部分都是从这摘抄过来的，感谢作者写得这么细致</a>)</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Docker文件系统概述">Docker文件系统概述</h2><p>典型的Linux文件系统由bootfs和rootfs两部分组成，bootfs(boot file system)主要包含 bootloader和kernel，bootloader主要是引导加载ke]]>
    </summary>
    
      <category term="docker" scheme="http://yutianx.info/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[操作系统的一些笔记]]></title>
    <link href="http://yutianx.info/2015/05/03/2015-05-03-operating-system/"/>
    <id>http://yutianx.info/2015/05/03/2015-05-03-operating-system/</id>
    <published>2015-05-03T04:53:20.000Z</published>
    <updated>2015-05-03T04:56:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="死锁">死锁</h3><p>两个或多个进程无线地等待一个事件，而该时间只可能由这些等待进程之一来产生。当出现这样的状态时，这些进程就称为死锁(deadlocked)。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="死锁">死锁</h3><p>两个或多个进程无线地等待一个事件，而该时间只可能由这些等待进程之一来产生。当出现这样的状态时，这些进程就称为死锁(deadlocked)。</p>
]]>
    </summary>
    
      <category term="操作系统" scheme="http://yutianx.info/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[chroot的使用与构建一个简单的rootfs]]></title>
    <link href="http://yutianx.info/2015/04/30/2015-04-30-chroot/"/>
    <id>http://yutianx.info/2015/04/30/2015-04-30-chroot/</id>
    <published>2015-04-30T08:21:20.000Z</published>
    <updated>2015-04-30T11:07:20.000Z</updated>
    <content type="html"><![CDATA[<h3 id="什么是chroot">什么是chroot</h3><p>chroot，即 change root directory (更改 root 目录)。在 linux 系统中，系统默认的目录结构都是以 <code>/</code>，即是以根 (root) 开始的。而在使用 chroot 之后，系统的目录结构将以指定的位置作为 <code>/</code> 位置。</p>
<h3 id="为何使用chroot">为何使用chroot</h3><p>在经过 chroot 之后，系统读取到的目录和文件将不在是旧系统根下的而是新根下(即被指定的新的位置)的目录结构和文件，因此它带来的好处大致有以下3个：</p>
<ul>
<li><p>增加了系统的安全性，限制了用户的权力；</p>
<p>  在经过 chroot 之后，在新根下将访问不到旧系统的根目录结构和文件，这样就增强了系统的安全性。这个一般是在登录 (login) 前使用 chroot，以此达到用户不能访问一些特定的文件。</p>
</li>
<li><p>建立一个与原系统隔离的系统目录结构，方便用户的开发；</p>
<p>  使用 chroot 后，系统读取的是新根下的目录和文件，这是一个与原系统根下文件不相关的目录结构。在这个新的环境中，可以用来测试软件的静态编译以及一些与系统不相关的独立开发。</p>
</li>
<li><p>切换系统的根目录位置，引导 Linux 系统启动以及急救系统等。</p>
<p>  chroot 的作用就是切换系统的根位置，而这个作用最为明显的是在系统初始引导磁盘的处理过程中使用，从初始 RAM 磁盘 (initrd) 切换系统的根位置并执行真正的 init。另外，当系统出现一些问题时，我们也可以使用 chroot 来切换到一个临时的系统。</p>
</li>
</ul>
<h3 id="构建一个简单的新根目录">构建一个简单的新根目录</h3><p>我们首先新建一个目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir rootfs</span><br><span class="line">$ mkdir bin</span><br></pre></td></tr></table></figure>
<p>拷贝/bin/bash命令到bin目录下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp /bin/bash ./bin</span><br></pre></td></tr></table></figure>
<p>使用<code>ldd</code>命令得到所需要的动态库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ldd /bin/bash</span><br><span class="line">    linux-vdso.so.<span class="number">1</span> =&gt;  (<span class="number">0</span>x00007fff5f225000)</span><br><span class="line">    libtinfo.so.<span class="number">5</span> =&gt; /lib64/libtinfo.so.<span class="number">5</span> (<span class="number">0</span>x00007<span class="built_in">fc</span>515981000)</span><br><span class="line">    libdl.so.<span class="number">2</span> =&gt; /lib64/libdl.so.<span class="number">2</span> (<span class="number">0</span>x00007<span class="built_in">fc</span>51577c000)</span><br><span class="line">    libc.so.<span class="number">6</span> =&gt; /lib64/libc.so.<span class="number">6</span> (<span class="number">0</span>x00007<span class="built_in">fc</span>5153bb000)</span><br><span class="line">    /lib64/ld-linux-x86-<span class="number">64</span>.so.<span class="number">2</span> (<span class="number">0</span>x00007<span class="built_in">fc</span>515bb3000)</span><br></pre></td></tr></table></figure></p>
<p>然后将这些动态链接库复制到rootfs目录下。这样就可以使用<code>chroot</code>来进入这个目录下了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chroot .</span><br><span class="line">bash-<span class="number">4.2</span><span class="comment"># pwd</span></span><br><span class="line">/</span><br></pre></td></tr></table></figure></p>
<p>我们如果再拷贝一些常用的命令以及一些目录，就可以弄成一个像模像样的rootfs了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="什么是chroot">什么是chroot</h3><p>chroot，即 change root directory (更改 root 目录)。在 linux 系统中，系统默认的目录结构都是以 <code>/</code>，即是以根 (root) 开始的。而在使用]]>
    </summary>
    
      <category term="linux" scheme="http://yutianx.info/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[动态规划: 树形dp-没有上司的舞会]]></title>
    <link href="http://yutianx.info/2015/04/29/2015-04-29-ball-without-boss/"/>
    <id>http://yutianx.info/2015/04/29/2015-04-29-ball-without-boss/</id>
    <published>2015-04-29T13:16:20.000Z</published>
    <updated>2015-05-04T13:38:28.000Z</updated>
    <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3><blockquote>
<p>Ural大学有N个职员，编号为1~N。他们有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。每个职员有一个快乐指数。现在有个周年庆宴会，要求与会职员的快乐指数最大。但是，没有职员愿和直接上司一起与会。意思是如果某人直接上司去了，那么他就不去。</p>
</blockquote>
<h3 id="输入描述">输入描述</h3><blockquote>
<p>第一行一个整数N。(1&lt;=N&lt;=6000)<br>接下来N行，第i+1行表示i号职员的快乐指数Ri。(-128&lt;=Ri&lt;=127)<br>接下来N-1行，每行输入一对整数L,K。表示K是L的直接上司。<br>最后一行输入0,0。</p>
</blockquote>
<h3 id="输出描述">输出描述</h3><blockquote>
<p>输出最大的快乐指数。</p>
</blockquote>
<h3 id="样例输入">样例输入</h3><blockquote>
<p>7<br>1<br>1<br>1<br>1<br>1<br>1<br>1<br>1 3<br>2 3<br>6 4<br>7 4<br>4 5<br>3 5<br>0 0</p>
</blockquote>
<h3 id="样例输出">样例输出</h3><blockquote>
<p>5</p>
</blockquote>
<h3 id="思路">思路</h3><p>设状态f[k][0],表示k不参加舞会时最大的快乐指数，f[k][1]表示k参加舞会时的最大快乐指数<br>状态转移方程如下：</p>
<p>$f[k][0]=\sum max \left( f[l][0], f[l][1] \right) $</p>
<p>$f[k][1]=\sum f[l][0] + happy[k] $</p>
<p>树形dp的以大特点就是数据是分好几块的，相互之间并不影响，比如说处理左子树和右子树时，两边的数据是不会相互影响的，即只用到了一部分数据。而一般的dp算法都是从0-n一步一步算出来的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">6000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAX_N + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> happy[MAX_N + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> f[MAX_N + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> has_boss[MAX_N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    f[k][<span class="number">1</span>] = happy[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[k].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = G[k][i];</span><br><span class="line">        dp(l);</span><br><span class="line">        f[k][<span class="number">1</span>] += f[l][<span class="number">0</span>];</span><br><span class="line">        f[k][<span class="number">0</span>] += max(f[l][<span class="number">0</span>], f[l][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!has_boss[i])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp(i);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;max(f[i][<span class="number">0</span>], f[i][<span class="number">1</span>])&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;happy[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> l, k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;k;</span><br><span class="line">        G[k].push_back(l);</span><br><span class="line">        has_boss[l] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;k;</span><br><span class="line">    </span><br><span class="line">    solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="题目描述">题目描述</h3><blockquote>
<p>Ural大学有N个职员，编号为1~N。他们有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。每个职员有一个快乐指数。现在有个周年庆宴会，要求与会职员的快乐指数最大。但是，]]>
    </summary>
    
      <category term="动态规划" scheme="http://yutianx.info/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="problems" scheme="http://yutianx.info/categories/problems/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[goroutine与调度器]]></title>
    <link href="http://yutianx.info/2015/04/28/2015-04-28-go-schedule/"/>
    <id>http://yutianx.info/2015/04/28/2015-04-28-go-schedule/</id>
    <published>2015-04-28T05:33:20.000Z</published>
    <updated>2015-04-30T13:28:57.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>本文为转载，原文地址：<a href="https://github.com/Unknwon/gcblog/blob/master/content/11-golang-schedule.md" target="_blank" rel="external">https://github.com/Unknwon/gcblog/blob/master/content/11-golang-schedule.md</a></p>
</blockquote>
<p>我们都知道 Go 语言是原生支持语言级并发的，这个并发的最小逻辑单元就是 goroutine。goroutine 就是 Go 语言提供的一种用户态线程，当然这种用户态线程是跑在内核级线程之上的。当我们创建了很多的 goroutine，并且它们都是跑在同一个内核线程之上的时候，就需要一个调度器来维护这些 goroutine，确保所有的 goroutine 都使用 cpu，并且是尽可能公平的使用 cpu 资源。</p>
<p>这个调度器的原理以及实现值得我们去深入研究一下。支撑整个调度器的主要有 4 个重要结构，分别是 M、G、P、Sched，前三个定义在 runtime.h 中，Sched 定义在 proc.c 中。</p>
<p>Sched 结构就是调度器，它维护有存储M和G的队列以及调度器的一些状态信息等。<br>M 代表内核级线程，一个M就是一个线程，goroutine 就是跑在 M 之上的；M是一个很大的结构，里面维护小对象内存 cache（mcache）、当前执行的 goroutine、随机数发生器等等非常多的信息。<br>P 全称是 Processor，处理器，它的主要用途就是用来执行 goroutine 的，所以它也维护了一个 goroutine 队列，里面存储了所有需要它来执行的 goroutine，这个P的角色可能有一点让人迷惑，一开始容易和 M 冲突，后面重点聊一下它们的关系。<br>G 就是 goroutine 实现的核心结构了，G 维护了 goroutine 需要的栈、程序计数器以及它所在的 M 等信息。<br>理解 M、P、G 三者的关系对理解整个调度器非常重要，我从网络上找了一个图来说明其三者关系：</p>
<p><img src="/img/golang-car.jpg" alt=""></p>
<p>地鼠(gopher)用小车运着一堆待加工的砖。M 就可以看作图中的地鼠，P 就是小车，G 就是小车里装的砖。一图胜千言啊，弄清楚了它们三者的关系，下面我们就开始重点聊地鼠是如何在搬运砖块的。</p>
<h3 id="启动过程">启动过程</h3><p>在关心绝大多数程序的内部原理的时候，我们都试图去弄明白其启动初始化过程，弄明白这个过程对后续的深入分析至关重要。在 asm_amd64.s 文件中的汇编代码 _rt0_amd64 就是整个启动过程，核心过程如下：</p>
<pre><code>CALL    runtime·<span class="function"><span class="title">args</span><span class="params">(SB)</span></span>
CALL    runtime·<span class="function"><span class="title">osinit</span><span class="params">(SB)</span></span>
CALL    runtime·<span class="function"><span class="title">hashinit</span><span class="params">(SB)</span></span>
CALL    runtime·<span class="function"><span class="title">schedinit</span><span class="params">(SB)</span></span>

<span class="comment">// create a new goroutine to start program</span>
PUSHQ   <span class="variable">$runtime</span>·main·<span class="function"><span class="title">f</span><span class="params">(SB)</span></span>     <span class="comment">// entry</span>
PUSHQ   $<span class="number">0</span>          <span class="comment">// arg size</span>
CALL    runtime·<span class="function"><span class="title">newproc</span><span class="params">(SB)</span></span>
POPQ    AX
POPQ    AX

<span class="comment">// start this M</span>
CALL    runtime·<span class="function"><span class="title">mstart</span><span class="params">(SB)</span></span>
</code></pre><p>启动过程做了调度器初始化 runtime·schedinit 后，调用 runtime·newproc 创建出第一个 goroutine，这个 goroutine 将执行的函数是 runtime·main，这第一个 goroutine 也就是所谓的主 goroutine。我们写的最简单的 Go 程序 ”hello，world” 就是完全跑在这个 goroutine 里，当然任何一个 Go 程序的入口都是从这个 goroutine 开始的。最后调用的 runtime·mstart 就是真正的执行上一步创建的主 goroutine。</p>
<p>启动过程中的调度器初始化 runtime·schedinit 函数主要根据用户设置的 GOMAXPROCS 值来创建一批小车(P)，不管 GOMAXPROCS 设置为多大，最多也只能创建 256 个小车(P)。这些小车(p)初始创建好后都是闲置状态，也就是还没开始使用，所以它们都放置在调度器结构(Sched)的 pidle 字段维护的链表中存储起来了，以备后续之需。</p>
<p>查看 runtime·main 函数可以了解到主 goroutine 开始执行后，做的第一件事情是创建了一个新的内核线程(地鼠 M)，不过这个线程是一个特殊线程，它在整个运行期专门负责做特定的事情——系统监控(sysmon)。接下来就是进入 Go 程序的 main 函数开始 Go 程序的执行。</p>
<p>至此，Go 程序就被启动起来开始运行了。一个真正干活的 Go 程序，一定创建有不少的 goroutine，所以在 Go 程序开始运行后，就会向调度器添加 goroutine，调度器就要负责维护好这些 goroutine 的正常执行。</p>
<h3 id="创建_goroutine(G)">创建 goroutine(G)</h3><p>在Go程序中，时常会有类似代码：</p>
<pre><code>go <span class="function"><span class="title">do_something</span><span class="params">()</span></span>
</code></pre><p>go 关键字就是用来创建一个 goroutine 的，后面的函数就是这个 goroutine 需要执行的代码逻辑。go 关键字对应到调度器的接口就是 runtime·newproc。<code>runtime·newproc</code> 干的事情很简单，就负责制造一块砖(G)，然后将这块砖(G)放入当前这个地鼠(M)的小车(P)中。</p>
<p>每个新的 goroutine 都需要有一个自己的栈，G结构的 <code>sched</code> 字段维护了栈地址以及程序计数器等信息，这是最基本的调度信息，也就是说这个 goroutine 放弃 cpu 的时候需要保存这些信息，待下次重新获得 cpu 的时候，需要将这些信息装载到对应的 cpu 寄存器中。</p>
<p>假设这个时候已经创建了大量的 goroutne，就轮到调度器去维护这些 goroutine 了。</p>
<h3 id="创建内核线程(M)">创建内核线程(M)</h3><p><img src="/img/golang-car.jpg" alt=""></p>
<p>Go 程序中没有语言级的关键字让你去创建一个内核线程，你只能创建 goroutine，内核线程只能由 runtime 根据实际情况去创建。runtime 什么时候创建线程？以地鼠运砖图来讲，砖(G)太多了，地鼠(M)又太少了，实在忙不过来，刚好还有空闲的小车(P)没有使用，那就从别处再借些地鼠(M)过来直到把小车(p)用完为止。这里有一个地鼠(M)不够用，从别处借地鼠(M)的过程，这个过程就是创建一个内核线程(M)。创建M的接口函数是:</p>
<pre><code>void newm<span class="list">(<span class="keyword">void</span> <span class="list">(<span class="keyword">*fn</span>)</span><span class="list">(<span class="keyword">void</span>)</span>, P <span class="variable">*p)</span></span>
</code></pre><p>newm 函数的核心行为就是调用 clone 系统调用创建一个内核线程，每个内核线程的开始执行位置都是 runtime·mstart 函数。参数 p 就是一辆空闲的小车(p)。</p>
<p>每个创建好的内核线程都从 runtime·mstart 函数开始执行了，它们将用分配给自己小车去搬砖了。</p>
<h3 id="调度核心">调度核心</h3><p>newm 接口只是给新创建的M分配了一个空闲的 P，也就是相当于告诉借来的地鼠(M)——“接下来的日子，你将使用 1 号小车搬砖，记住是 1 号小车；待会自己到停车场拿车。”，地鼠(M)去拿小车(P)这个过程就是 <code>acquirep</code>。 runtime·mstart 在进入 <code>schedule</code> 之前会给当前 M 装配上 P，runtime·mstart 函数中的代码：</p>
<pre><code>} <span class="keyword">else</span> <span class="keyword">if</span>(m != &amp;runtime·m0) {
    acquirep(m-&gt;nextp);
    m-&gt;nextp = <span class="literal">nil</span>;
}
schedule<span class="literal">()</span>;
</code></pre><p>if 分支的内容就是为当前 M 装配上 P，<code>nextp</code> 就是 newm 分配的空闲小车(P)，只是到这个时候才真正拿到手罢了。没有 P，M 是无法执行 goroutine 的，就像地鼠没有小车无法运砖一样的道理。对应 acquirep 的动作是 releasep，把 M 装配的 P 给载掉；活干完了，地鼠需要休息了，就把小车还到停车场，然后睡觉去。</p>
<p>地鼠(M)拿到属于自己的小车(P)后，就进入工场开始干活了，也就是上面的 <code>schedule</code> 调用。简化 schedule 的代码如下：</p>
<pre><code><span class="keyword">static</span> <span class="keyword">void</span>
schedule(<span class="keyword">void</span>)
{
    G *gp;

    gp = runqget(m-&gt;p);
    <span class="keyword">if</span>(gp == nil)
        gp = findrunnable();

    <span class="keyword">if</span> (m-&gt;p-&gt;runqhead != m-&gt;p-&gt;runqtail &amp;&amp;
        <span class="keyword">runtime</span>·atomicload(&amp;<span class="keyword">runtime</span>·sched.nmspinning) == <span class="number">0</span> &amp;&amp;
        <span class="keyword">runtime</span>·atomicload(&amp;<span class="keyword">runtime</span>·sched.npidle) &gt; <span class="number">0</span>)  <span class="comment">// TODO: fast atomic</span>
        wakep();

    execute(gp);
}
</code></pre><p>schedule 函数被我简化了太多，主要是我不喜欢贴大段大段的代码，因此只保留主干代码了。这里涉及到 4 大步逻辑：</p>
<p><img src="/img/gopher-bz.jpg" alt=""></p>
<ol>
<li><code>runqget</code>, 地鼠(M)试图从自己的小车(P)取出一块砖(G)，当然结果可能失败，也就是这个地鼠的小车已经空了，没有砖了。</li>
<li><code>findrunnable</code>, 如果地鼠自己的小车中没有砖，那也不能闲着不干活是吧，所以地鼠就会试图跑去工场仓库取一块砖来处理；工场仓库也可能没砖啊，出现这种情况的时候，这个地鼠也没有偷懒停下干活，而是悄悄跑出去，随机盯上一个小伙伴(地鼠)，然后从它的车里试图偷一半砖到自己车里。如果多次尝试偷砖都失败了，那说明实在没有砖可搬了，这个时候地鼠就会把小车还回停车场，然后 <code>睡觉</code> 休息了。如果地鼠睡觉了，下面的过程当然都停止了，地鼠睡觉也就是线程 sleep 了。</li>
<li><code>wakep</code>, 到这个过程的时候，可怜的地鼠发现自己小车里有好多砖啊，自己根本处理不过来；再回头一看停车场居然有闲置的小车，立马跑到宿舍一看，你妹，居然还有小伙伴在睡觉，直接给屁股一脚，“你妹，居然还在睡觉，老子都快累死了，赶紧起来干活，分担点工作。”，小伙伴醒了，拿上自己的小车，乖乖干活去了。有时候，可怜的地鼠跑到宿舍却发现没有在睡觉的小伙伴，于是会很失望，最后只好向工场老板说——”停车场还有闲置的车啊，我快干不动了，赶紧从别的工场借个地鼠来帮忙吧。”，最后工场老板就搞来一个新的地鼠干活了。</li>
<li><code>execute</code>，地鼠拿着砖放入火种欢快的烧练起来。</li>
</ol>
<p><em>注： “地鼠偷砖”叫 <a href="http://supertech.csail.mit.edu/papers/steal.pdf" target="_blank" rel="external">work stealing</a>，一种调度算法。</em></p>
<h3 id="调度点">调度点</h3><p>当我们翻看 channel 的实现代码可以发现，对 channel 读写操作的时候会触发调用 runtime·park 函数。 goroutine 调用 park 后，这个 goroutine 就会被设置位 waiting 状态，放弃 cpu。被 park 的 goroutine 处于 waiting 状态，并且这个 goroutine 不在小车(P)中，如果不对其调用 runtime·ready，它是永远不会再被执行的。除了 channel 操作外，定时器中，网络 poll 等都有可能 park goroutine。</p>
<p>除了 park 可以放弃 cpu 外，调用 runtime·gosched 函数也可以让当前 goroutine 放弃 cpu，但和 park 完全不同；gosched 是将 goroutine 设置为 runnable 状态，然后放入到调度器全局等待队列（也就是上面提到的工场仓库，这下就明白为何工场仓库会有砖块(G)了吧）。</p>
<p>除此之外，就轮到系统调用了，有些系统调用也会触发重新调度。Go 语言完全是自己封装的系统调用，所以在封装系统调用的时候，可以做不少手脚，也就是进入系统调用的时候执行 entersyscall，退出后又执行 exitsyscall 函数。 也只有封装了 entersyscall 的系统调用才有可能触发重新调度，它将改变小车(P)的状态为 syscall。还记一开始提到的 sysmon 线程吗？这个系统监控线程会扫描所有的小车(P)，发现一个小车(P)处于了 syscall 的状态，就知道这个小车(P)遇到了 goroutine 在做系统调用，于是系统监控线程就会创建一个新的地鼠(M)去把这个处于 syscall 的小车给抢过来，开始干活，这样这个小车中的所有砖块(G)就可以绕过之前系统调用的等待了。被抢走小车的地鼠等系统调用返回后，发现自己的车没，不能继续干活了，于是只能把执行系统调用的 goroutine 放回到工场仓库，自己 <code>睡觉</code> 去了。</p>
<p>从 goroutine 的调度点可以看出，调度器还是挺粗暴的，调度粒度有点过大，公平性也没有想想的那么好。总之，这个调度器还是比较简单的。</p>
<h3 id="现场处理">现场处理</h3><p>goroutine 在 cpu 上换入换出，不断上下文切换的时候，必须要保证的事情就是 <code>保存现场</code> 和 <code>恢复现场</code>，保存现场就是在 goroutine 放弃 cpu 的时候，将相关寄存器的值给保存到内存中；恢复现场就是在 goroutine 重新获得 cpu 的时候，需要从内存把之前的寄存器信息全部放回到相应寄存器中去。</p>
<p>goroutine 在主动放弃 cpu 的时候(park/gosched)，都会涉及到调用 runtime·mcall 函数，此函数也是汇编实现，主要将 goroutine 的栈地址和程序计数器保存到 G 结构的 <code>sched</code> 字段中，mcall 就完成了现场保存。恢复现场的函数是 runtime·gogocall，这个函数主要在 <code>execute</code> 中调用，就是在执行 goroutine 前，需要重新装载相应的寄存器。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>本文为转载，原文地址：<a href="https://github.com/Unknwon/gcblog/blob/master/content/11-golang-schedule.md" target="_blank" rel="extern]]>
    </summary>
    
      <category term="golang" scheme="http://yutianx.info/categories/golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[golang--sort包中的Interface]]></title>
    <link href="http://yutianx.info/2015/04/28/2015-04-28-go-sort-interface/"/>
    <id>http://yutianx.info/2015/04/28/2015-04-28-go-sort-interface/</id>
    <published>2015-04-28T01:56:20.000Z</published>
    <updated>2015-04-30T13:20:35.000Z</updated>
    <content type="html"><![CDATA[<p>golang的sort包中定义了一个名为Interface的interface，还有一个Sort(Interface)的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">        <span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">        Len() <span class="typename">int</span></span><br><span class="line">        <span class="comment">// Less reports whether the element with</span></span><br><span class="line">        <span class="comment">// index i should sort before the element with index j.</span></span><br><span class="line">        Less(i, j <span class="typename">int</span>) <span class="typename">bool</span></span><br><span class="line">        <span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">        Swap(i, j <span class="typename">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> Sort(data Interface)</span><br></pre></td></tr></table></figure>
<p>所以，只要一个类型实现了Interface接口，都可以调用Sort函数进行排序，在某些方面用起来感觉比c++中的sort()函数要更直观一点。</p>
<p>放一个官方的例子, ByAge实现了Interface，这样就可以根据自己规定的排序方式，来对ByAge进行排序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name <span class="typename">string</span></span><br><span class="line">        Age  <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (p Person) String() <span class="typename">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s: %d"</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ByAge implements sort.Interface for []Person based on</span></span><br><span class="line"><span class="comment">// the Age field.</span></span><br><span class="line"><span class="keyword">type</span> ByAge []Person</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (a ByAge) Len() <span class="typename">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="keyword">func</span> (a ByAge) Swap(i, j <span class="typename">int</span>)      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"><span class="keyword">func</span> (a ByAge) Less(i, j <span class="typename">int</span>) <span class="typename">bool</span> &#123; <span class="keyword">return</span> a[i].Age &lt; a[j].Age &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">        people := []Person&#123;</span><br><span class="line">                &#123;<span class="string">"Bob"</span>, <span class="number">31</span>&#125;,</span><br><span class="line">                &#123;<span class="string">"John"</span>, <span class="number">42</span>&#125;,</span><br><span class="line">                &#123;<span class="string">"Michael"</span>, <span class="number">17</span>&#125;,</span><br><span class="line">                &#123;<span class="string">"Jenny"</span>, <span class="number">26</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fmt.Println(people)</span><br><span class="line">        sort.Sort(ByAge(people))</span><br><span class="line">        fmt.Println(people)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>golang的sort包中定义了一个名为Interface的interface，还有一个Sort(Interface)的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span]]>
    </summary>
    
      <category term="golang" scheme="http://yutianx.info/categories/golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[golang中interface需要注意的一点地方]]></title>
    <link href="http://yutianx.info/2015/04/28/2015-04-28-go-interface/"/>
    <id>http://yutianx.info/2015/04/28/2015-04-28-go-interface/</id>
    <published>2015-04-28T01:56:20.000Z</published>
    <updated>2015-04-30T13:29:51.000Z</updated>
    <content type="html"><![CDATA[<p>先看代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> List []<span class="typename">int</span></span><br><span class="line"><span class="keyword">func</span> (l List) Len() <span class="typename">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(l) &#125;</span><br><span class="line"><span class="keyword">func</span> (l *List) Append(val <span class="typename">int</span>) &#123; *l = <span class="built_in">append</span>(*l, val) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Appender <span class="keyword">interface</span> &#123;</span><br><span class="line">        Append(<span class="typename">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> CountInto(a Appender, start, end <span class="typename">int</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> i := start; i &lt;= end; i++ &#123;</span><br><span class="line">                a.Append(i)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Lener <span class="keyword">interface</span> &#123;</span><br><span class="line">        Len() <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> LongEnough(l Lener) <span class="typename">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> l.Len()*<span class="number">10</span> &gt; <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">        <span class="keyword">var</span> lst List</span><br><span class="line">        <span class="comment">// compiler error:</span></span><br><span class="line">        <span class="comment">// cannot use lst (type List) as type Appender in function argument:</span></span><br><span class="line">        <span class="comment">// List does not implement Appender (Append method requires pointer receiver)</span></span><br><span class="line">        <span class="comment">// INVALID: Append has a pointer receiver</span></span><br><span class="line">        <span class="comment">// CountInto(lst, 1, 10) </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> LongEnough(lst) &#123;  <span class="comment">// VALID: Identical receiver type</span></span><br><span class="line">                fmt.Printf(<span class="string">" - lst is long enough"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A pointer value</span></span><br><span class="line">        plst := <span class="built_in">new</span>(List)</span><br><span class="line">        CountInto(plst, <span class="number">1</span>, <span class="number">10</span>) <span class="comment">// VALID: Identical receiver type</span></span><br><span class="line">        <span class="keyword">if</span> LongEnough(plst) &#123;  <span class="comment">// VALID: a *List can be dereferenced for the receiver</span></span><br><span class="line">                fmt.Printf(<span class="string">" - plst is long enough"</span>)  <span class="comment">//  - plst is long enoug</span></span><br><span class="line">        &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>CountInto(1st, 1, 10)</code>这一句编译时会报错，因为List实现Appender接口时的receiver是指针类型，所以调用时也必须使用指针类型。</p>
<p>所以interface这和struct自身的method调用时不同，interface使用时receiver的类型必须和实现时的类型完全一样，而struct调用自身的method时会自动转换类型。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>先看代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><]]>
    </summary>
    
      <category term="golang" scheme="http://yutianx.info/categories/golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[动态规划: 树形dp-访问艺术馆]]></title>
    <link href="http://yutianx.info/2015/04/27/2015-04-27-visit-gallary/"/>
    <id>http://yutianx.info/2015/04/27/2015-04-27-visit-gallary/</id>
    <published>2015-04-27T13:58:20.000Z</published>
    <updated>2015-05-04T13:40:51.000Z</updated>
    <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3><blockquote>
<p>皮尔是一个出了名的盗画者，他经过数月的精心准备，打算到艺术馆盗画。艺术馆的结构，每条走廊要么分叉为二条走廊，要么通向一个展览室。皮尔知道每个展室里藏画的数量，并且他精确地测量了通过每条走廊的时间，由于经验老道，他拿下一副画需要5秒的时间。你的任务是设计一个程序，计算在警察赶来之前(警察到达时皮尔回到了入口也算)，他最多能偷到多少幅画。<br><img src="/img/visit_gallary.jpg" alt="trie1"></p>
</blockquote>
<h3 id="输入描述">输入描述</h3><blockquote>
<p>第1行是警察赶到得时间，以s为单位。第2行描述了艺术馆得结构，是一串非负整数，成对地出现：每一对得第一个数是走过一条走廊得时间，第2个数是它末端得藏画数量；如果第2个数是0，那么说明这条走廊分叉为两条另外得走廊。数据按照深度优先得次序给出，请看样例</p>
</blockquote>
<h3 id="输出描述">输出描述</h3><blockquote>
<p>输出偷到得画得数量</p>
</blockquote>
<h3 id="样例输入">样例输入</h3><blockquote>
<p>60<br>7 0 8 0 3 1 14 2 10 0 12 4 6 2</p>
</blockquote>
<h3 id="样例输出">样例输出</h3><blockquote>
<p>2</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> LIMIT, T[MAX_N], P[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, L[MAX_N], R[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build_tree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T[n]&gt;&gt;P[n];</span><br><span class="line">    </span><br><span class="line">    T[n] *= <span class="number">2</span>; <span class="comment">//进去还得出来，所以要两倍的时间</span></span><br><span class="line">    <span class="keyword">int</span> now = n;</span><br><span class="line">    <span class="keyword">if</span> (P[now] == <span class="number">0</span>) &#123;</span><br><span class="line">        L[now] = build_tree();</span><br><span class="line">        R[now] = build_tree();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[root][time] != -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[root][time];</span><br><span class="line">    <span class="keyword">if</span> (time &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[root][time] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ct = time - T[root];</span><br><span class="line">    <span class="keyword">if</span> (!L[root] &amp;&amp; !R[root]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (P[root] * <span class="number">5</span> &lt;= ct)</span><br><span class="line">            <span class="keyword">return</span> dp[root][time] = P[root];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> dp[root][time] = ct / <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dp[root][time] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt;= ct; t++) &#123;</span><br><span class="line">        <span class="keyword">int</span> lp = solve(L[root], ct - t);</span><br><span class="line">        <span class="keyword">int</span> rp = solve(R[root], t);</span><br><span class="line">        dp[root][time] = max(dp[root][time], lp + rp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[root][time];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;LIMIT;</span><br><span class="line">    build_tree();</span><br><span class="line">    <span class="built_in">memset</span>(dp, -<span class="number">1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    solve(<span class="number">1</span>, LIMIT);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[<span class="number">1</span>][LIMIT]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="题目描述">题目描述</h3><blockquote>
<p>皮尔是一个出了名的盗画者，他经过数月的精心准备，打算到艺术馆盗画。艺术馆的结构，每条走廊要么分叉为二条走廊，要么通向一个展览室。皮尔知道每个展室里藏画的数量，并且他精确地测量了通过每条走廊的时间，由于经]]>
    </summary>
    
      <category term="动态规划" scheme="http://yutianx.info/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="problems" scheme="http://yutianx.info/categories/problems/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[动态规划: Palindrome Partitioning II ]]></title>
    <link href="http://yutianx.info/2015/04/23/2015-04-23-Palindrome_Partitioning_II%20/"/>
    <id>http://yutianx.info/2015/04/23/2015-04-23-Palindrome_Partitioning_II /</id>
    <published>2015-04-23T03:38:20.000Z</published>
    <updated>2015-05-04T13:40:59.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return the minimum cuts needed for a palindrome partitioning of s.</p>
<p>For example, given s = “aab”,<br>Return 1 since the palindrome partitioning [“aa”,”b”] could be produced using 1 cut.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">这里用到了两个dp，</span><br><span class="line">一个是判断字符串s[i][j]是否为回文，</span><br><span class="line">一个是记录s[0..i]最小的切割数</span><br><span class="line"></span><br><span class="line">经典题</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isPal(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="keyword">false</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cut(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            cut[j] = j;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= j; i++) &#123;</span><br><span class="line">                <span class="comment">//如果子串 s[i...j]是回文串</span></span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j] &amp;&amp; (j - i &lt;= <span class="number">1</span> || isPal[i + <span class="number">1</span>][j - <span class="number">1</span>])) &#123;</span><br><span class="line">                    isPal[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">                        cut[j] = min(cut[j], cut[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        cut[j] = <span class="number">0</span>; <span class="comment">//如果 s[0...j]是回文串，则说明不需要切割</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cut[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return the minimum cuts nee]]>
    </summary>
    
      <category term="动态规划" scheme="http://yutianx.info/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="problems" scheme="http://yutianx.info/categories/problems/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Math: Divide Two Integers]]></title>
    <link href="http://yutianx.info/2015/04/23/2015-04-23-leetcode-Divide-Two-Integers/"/>
    <id>http://yutianx.info/2015/04/23/2015-04-23-leetcode-Divide-Two-Integers/</id>
    <published>2015-04-23T01:56:20.000Z</published>
    <updated>2015-04-30T13:14:08.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Divide two integers without using multiplication, division and mod operator.</p>
<p>If it is overflow, return MAX_INT.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">这里需要注意的就是溢出的问题，我们知道，int的范围为</span><br><span class="line">-2147483648 ~ 2147483647</span><br><span class="line">所以需要考虑的情况就是当-2147483648 / -1时，会溢出</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> a = dividend &gt;= <span class="number">0</span> ? dividend : -(<span class="keyword">long</span> <span class="keyword">long</span>) dividend;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> b = divisor &gt;= <span class="number">0</span> ? divisor : -(<span class="keyword">long</span> <span class="keyword">long</span>) divisor;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (a &gt;= b) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> c = b;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; a &gt;= c; ++i, c &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                a -= c;</span><br><span class="line">                result += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result = ((dividend ^ divisor) &gt;&gt; <span class="number">31</span>) ? -result : result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result &gt;= INT_MAX ? INT_MAX : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>Divide two integers without using multiplication, division and mod operator.</p>
<p>If it is overflow, return MAX_INT.</p>
<]]>
    </summary>
    
      <category term="problems" scheme="http://yutianx.info/categories/problems/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[动态规划：背包问题]]></title>
    <link href="http://yutianx.info/2015/04/11/2015-04-11-bag-problem/"/>
    <id>http://yutianx.info/2015/04/11/2015-04-11-bag-problem/</id>
    <published>2015-04-11T15:21:20.000Z</published>
    <updated>2015-05-04T13:41:09.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-01背包问题">1.01背包问题</h3><blockquote>
<p>有n个重量和价值分别为wi和vi的物品。从这些物品中挑选出总重量不超过W的物品，求所有<br>挑选方案中价值总和的最大值。<br>其中<code>1 &lt; n &lt; 100</code>, <code>1 &lt; wi, vi &lt; 100</code>, <code>1 &lt; W &lt; 10000</code></p>
</blockquote>
<p>在前面的博客中说过01背包可以用DFS来解，但是使用DFS来解得话时间复杂度很高，所以可以使用动态规划<br>来解这道题。</p>
<p>首先，可以得到递推关系式：</p>
<p>令dp[i + 1][j]表示从前i个物品中选出总重量不超过j的物品时总价值的最大值，那么：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="link_label">0</span>][<span class="link_reference">j</span>] = 0;</span><br><span class="line"></span><br><span class="line"><span class="code">                dp[i][j]    j &lt; w[i]</span></span><br><span class="line">dp[<span class="link_label">i+1</span>][<span class="link_reference">j</span>] = </span><br><span class="line"><span class="code">                max&#123;dp[i][j], dp[j-w[i]] + vi&#125;</span></span><br></pre></td></tr></table></figure>
<p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> 此题见于挑战一书51页</span><br><span class="line"> */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, W;</span><br><span class="line"><span class="keyword">int</span> w[MAX_N], v[MAX_N];</span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">1</span>][MAX_N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= W; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; w[i]) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j] = dp[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j] = max(dp[i][j], dp[i][j-w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[n][W]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;W;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-完全背包问题">2.完全背包问题</h3><blockquote>
<p>有n种重量和价值分别为wi和vi的物品。从这些物品中挑选出总重量不超过W的物品，求所有<br>挑选方案中价值总和的最大值。这里每种物品可以挑选任意多件。<br>其中<code>1 &lt; n &lt; 100</code>, <code>1 &lt; wi, vi &lt; 100</code>, <code>1 &lt; W &lt; 10000</code></p>
</blockquote>
<p>这个问题和上一个问题的区别在于每种物品都可以挑选任意多件。但是递推关系和上一个问题差不多。</p>
<p>令dp[i + 1][j]表示从前i个物品中选出总重量不超过j的物品时总价值的最大值，那么：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="link_label">0</span>][<span class="link_reference">j</span>] = 0;</span><br><span class="line"><span class="code">           </span></span><br><span class="line">dp[<span class="link_label">i+1</span>][<span class="link_reference">j</span>] = max&#123;dp[<span class="link_label">i</span>][<span class="link_reference">j - k*w[i</span>]] + k*v[i] | k &gt;= 0&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> 此题见于挑战一书51页</span><br><span class="line"> */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, W;</span><br><span class="line"><span class="keyword">int</span> w[MAX_N], v[MAX_N];</span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">1</span>][MAX_N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= W; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k*w[i] &lt;= j; k++) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j] = max(dp[i+<span class="number">1</span>][j], dp[i][j - k*w[i]] + k*v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[n][W];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;W;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是上面这种解法的时间复杂度可能达到O(nW^2),所以可以继续对题进行优化，在dp[i+1][j]的计算中选择k(k&gt;=1)个i物品的情况与在dp[j+1][j-w[i]]的计算中选择k-1个i物品的情况<br>是一样的，所以dp[i+1][j]的递推中k&gt;=1的部分计算已经在dp[i+1][j-w[i]]的计算中完成<br>了。所以可以按照如下方式变形：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="link_label">i+1</span>][<span class="link_reference">j</span>] = max&#123;dp[<span class="link_label">i</span>][<span class="link_reference">j - k*wi</span>] - k*vi | k &gt;= 0&#125;</span><br><span class="line"><span class="code">	   	   = max&#123;dp[i][j], max&#123; dp[i][j - k*wi] + k*vi | k &gt;= 1&#125; &#125;</span></span><br><span class="line"><span class="code">	   	   = max&#123;dp[i][j], max&#123;dp[i][(j - wi) - k*wi] + k*vi | k &gt;= 0&#125; + vi&#125;</span></span><br><span class="line"><span class="code">	   	   = max&#123;dp[i][j], dp[i+1][j-wi] + vi&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> 此题见于挑战一书51页</span><br><span class="line"> */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, W;</span><br><span class="line"><span class="keyword">int</span> w[MAX_N], v[MAX_N];</span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">1</span>][MAX_N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= W; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; w[i]) &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j] = dp[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j] = max(dp[i][j], dp[i + <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[n][W];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;W;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-使用滚动数组来减少空间复杂度">3.使用滚动数组来减少空间复杂度</h3><p>对这种一行一行计算结果的情况，我们有时可以用重复利用一个滚动数组来降低空间复杂度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[MAX_W + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">01背包问题</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = W; j &gt;= w[i]; j--) &#123;</span><br><span class="line">			dp[j] = max(dp[j], dp[i - w[i]] + v[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;dp[W]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">完全背包问题</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = w[i]; j &lt;= W; j++) &#123;</span><br><span class="line">			dp[j] = max(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;dp[W]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-01背包问题">1.01背包问题</h3><blockquote>
<p>有n个重量和价值分别为wi和vi的物品。从这些物品中挑选出总重量不超过W的物品，求所有<br>挑选方案中价值总和的最大值。<br>其中<code>1 &lt; n &lt; 100</c]]>
    </summary>
    
      <category term="动态规划" scheme="http://yutianx.info/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="problems" scheme="http://yutianx.info/categories/problems/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[动态规划: Dungeon Game]]></title>
    <link href="http://yutianx.info/2015/04/10/2015-04-10-leetcode-Dungeon-Game/"/>
    <id>http://yutianx.info/2015/04/10/2015-04-10-leetcode-Dungeon-Game/</id>
    <published>2015-04-10T06:47:20.000Z</published>
    <updated>2015-05-04T13:41:15.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.</p>
<p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.</p>
<p>Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0’s) or contain magic orbs that increase the knight’s health (positive integers).</p>
<p>In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.</p>
</blockquote>
<p><a href="https://leetcode.com/problems/dungeon-game/" target="_blank" rel="external">原题链接</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">    这道题和以前求最短路径的题有点相似，但是又不是求最短路径，因为要时刻保持英雄血量为正</span><br><span class="line"></span><br><span class="line">    但是我们还是可以使用动态规划来解决，我们约定一个数组dp[rows][cols]，其中</span><br><span class="line">    dp[i][j]表示进来(i, j)之前所需要的最少血量，则我们要求的结果就是dp[0][0]</span><br><span class="line"></span><br><span class="line">    那么我们可以得到一个递归式：</span><br><span class="line">    dp[i][j] = min(max(1, dp[i+1][j] - dungeon[i][j], max(1, dp[i][j+1] - dungeon[i][j])))</span><br><span class="line">    </span><br><span class="line">    可以这么理解，英雄进来（i, j）室后，有两条路出去，那么他出去之后所需的血量是接下来需要进入的</span><br><span class="line">    密室所需要的最低血量，即dp[i+1][j]和dp[i][j+1],那么他进来这个密室之前所需要的最低血量是多少</span><br><span class="line">    呢，那就很容易知道了，我们肯定选择一个出去时所需血量最少的，这样进来之前所需要的血量也是最少，</span><br><span class="line">    但是，需要注意的是，英雄的血量必须时刻保持为正，所以我们取max(1, exit_HP - dungeon[i][j])</span><br><span class="line"></span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = dungeon.size();</span><br><span class="line">        <span class="keyword">int</span> cols = rows &gt; <span class="number">0</span> ? dungeon[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(cols, INT_MAX);</span><br><span class="line">        dp[cols - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = rows - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            dp[cols - <span class="number">1</span>] = max(<span class="number">1</span>, dp[cols - <span class="number">1</span>] - dungeon[i][cols - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = cols - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                dp[j] = max(<span class="number">1</span>, min(dp[j], dp[j + <span class="number">1</span>]) - dungeon[i][j]);</span><br><span class="line">            &#125;          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of]]>
    </summary>
    
      <category term="动态规划" scheme="http://yutianx.info/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="problems" scheme="http://yutianx.info/categories/problems/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[golang中的sync]]></title>
    <link href="http://yutianx.info/2015/03/11/2015-03-11-go-sync/"/>
    <id>http://yutianx.info/2015/03/11/2015-03-11-go-sync/</id>
    <published>2015-03-11T05:11:20.000Z</published>
    <updated>2015-04-30T13:12:40.000Z</updated>
    <content type="html"><![CDATA[<p>在golang中使用并发时，除了使用channel用来同步以外，还可以使用sync包来实现。</p>
<p>sync包中的WaitGroup实现了一个类似任务队列的结构，你可以向队列中加入任务，任务完成后就把任务从队列中移除，如果队列中的任务没有全部完成，队列就会触发阻塞以阻止程序继续运行。</p>
<p>这种情况就适用于各个goroutine之间不需要交换什么数据，只是完成一些相互独立的功能。例如写一个爬虫，爬曲各个不同页面，就可以使用sync。</p>
<p>下面是golang官网的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> urls = []<span class="typename">string</span>&#123;</span><br><span class="line">        <span class="string">"http://www.golang.org/"</span>,</span><br><span class="line">        <span class="string">"http://www.google.com/"</span>,</span><br><span class="line">        <span class="string">"http://www.somestupidname.com/"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">        <span class="comment">// Increment the WaitGroup counter.</span></span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// Launch a goroutine to fetch the URL.</span></span><br><span class="line">        <span class="keyword">go</span> <span class="keyword">func</span>(url <span class="typename">string</span>) &#123;</span><br><span class="line">                <span class="comment">// Decrement the counter when the goroutine completes.</span></span><br><span class="line">                <span class="keyword">defer</span> wg.Done()</span><br><span class="line">                <span class="comment">// Fetch the URL.</span></span><br><span class="line">                http.Get(url)</span><br><span class="line">        &#125;(url)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Wait for all HTTP fetches to complete.</span></span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>在golang中使用并发时，除了使用channel用来同步以外，还可以使用sync包来实现。</p>
<p>sync包中的WaitGroup实现了一个类似任务队列的结构，你可以向队列中加入任务，任务完成后就把任务从队列中移除，如果队列中的任务没有全部完成，队列就会触发阻塞以]]>
    </summary>
    
      <category term="golang" scheme="http://yutianx.info/categories/golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[c++中fill与fill_n函数]]></title>
    <link href="http://yutianx.info/2015/01/29/2015-01-29-cpp-fill/"/>
    <id>http://yutianx.info/2015/01/29/2015-01-29-cpp-fill/</id>
    <published>2015-01-29T12:01:20.000Z</published>
    <updated>2015-04-30T13:11:23.000Z</updated>
    <content type="html"><![CDATA[<h3 id="fill函数">fill函数</h3><p>fill函数的作用是：将一个区间的元素都赋予val值。函数参数：fill(first,last,val);//first为容器的首迭代器，last为容器的末迭代器，val为将要替换的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fill algorithm example</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;    <span class="comment">// std::fill</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;       <span class="comment">// std::vector</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">8</span>);                       <span class="comment">// myvector: 0 0 0 0 0 0 0 0</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::fill (myvector.begin(),myvector.begin()+<span class="number">4</span>,<span class="number">5</span>);   <span class="comment">// myvector: 5 5 5 5 0 0 0 0</span></span><br><span class="line">  <span class="built_in">std</span>::fill (myvector.begin()+<span class="number">3</span>,myvector.end()-<span class="number">2</span>,<span class="number">8</span>);   <span class="comment">// myvector: 5 5 5 8 8 8 0 0</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myvector contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fill_n函数">fill_n函数</h3><p>fill_n函数的作用是：给你一个起始点，然后再给你一个数值count和val。把从起始点开始依次赋予count个元素val的值。</p>
<p>与fill函数的区别就是fill_n直接指定元素的个数，fill只是指定一个区间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// fill_n example</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;    <span class="comment">// std::fill_n</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;       <span class="comment">// std::vector</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">8</span>,<span class="number">10</span>);        <span class="comment">// myvector: 10 10 10 10 10 10 10 10</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::fill_n (myvector.begin(),<span class="number">4</span>,<span class="number">20</span>);     <span class="comment">// myvector: 20 20 20 20 10 10 10 10</span></span><br><span class="line">  <span class="built_in">std</span>::fill_n (myvector.begin()+<span class="number">3</span>,<span class="number">3</span>,<span class="number">33</span>);   <span class="comment">// myvector: 20 20 20 33 33 33 10 10</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myvector contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="fill函数">fill函数</h3><p>fill函数的作用是：将一个区间的元素都赋予val值。函数参数：fill(first,last,val);//first为容器的首迭代器，last为容器的末迭代器，val为将要替换的值。</p>
<figure clas]]>
    </summary>
    
      <category term="cpp" scheme="http://yutianx.info/categories/cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[常量指针和指针常量]]></title>
    <link href="http://yutianx.info/2014/11/30/2014-11-30-c-constant-pointer/"/>
    <id>http://yutianx.info/2014/11/30/2014-11-30-c-constant-pointer/</id>
    <published>2014-11-30T06:41:20.000Z</published>
    <updated>2015-04-30T13:11:07.000Z</updated>
    <content type="html"><![CDATA[<h3 id="常量指针">常量指针</h3><p>常量指针是说指针所指向的内容是常量。</p>
<p>比如:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = a;</span><br><span class="line">*p = <span class="string">'a'</span>; <span class="comment">//这样是不行的，因为申明的是一个常量指针</span></span><br></pre></td></tr></table></figure></p>
<h3 id="指针常量">指针常量</h3><p>指针常量说的是指针是一个常量，不能够更改指针的值。</p>
<p>比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> b[<span class="number">10</span>] = <span class="string">"world"</span>;</span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">//这样是不行的，因为申明的是一个指针常量</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="常量指针">常量指针</h3><p>常量指针是说指针所指向的内容是常量。</p>
<p>比如:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="lin]]>
    </summary>
    
      <category term="cpp" scheme="http://yutianx.info/categories/cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[动态规划: Maximum Product Subarray]]></title>
    <link href="http://yutianx.info/2014/11/26/2014-11-26-leetcode-maximum-product-subarray/"/>
    <id>http://yutianx.info/2014/11/26/2014-11-26-leetcode-maximum-product-subarray/</id>
    <published>2014-11-26T13:45:20.000Z</published>
    <updated>2015-05-04T13:41:38.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>For example, given the array <code>[2,3,-2,4]</code>,</p>
<p>the contiguous subarray <code>[2,3]</code> has the largest product = <code>6</code>.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"></span><br><span class="line">f(k) = Largest product subarray, from index 0 up to k, but must multiply A[k].</span><br><span class="line">g(k) = Smallest product subarray, from index 0 up to k, but must multiply A[k].</span><br><span class="line"></span><br><span class="line">在f(k)和g(k)中，</span><br><span class="line">f(k)是指从0~k,最后乘以A[k]的最大值，</span><br><span class="line">g(k)是指从0~k,最后乘以A[k]的最小值.</span><br><span class="line">所以这也是为什么f(k)，g(k)并不是全局的最大值和最小值，之所以一定要乘上A[k]，是因为</span><br><span class="line">求的是连续的范围，只有这样，才能够往下继续遍历。</span><br><span class="line"></span><br><span class="line">f(k) = max( f(k-1) * A[k], A[k], g(k-1) * A[k] )</span><br><span class="line">g(k) = min( g(k-1) * A[k], A[k], f(k-1) * A[k] )</span><br><span class="line"></span><br><span class="line">在递推公式中，如果f(k)为A[k]，表示从k重新开始。</span><br><span class="line">比如&#123;2,3,-2,4&#125;，k=2时，f(k)=-2,表示从-2处重新开始计算最大值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min_tmp = A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max_tmp = A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> result = max_tmp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = min_tmp * A[i];</span><br><span class="line">            <span class="keyword">int</span> b = max_tmp * A[i];</span><br><span class="line">            min_tmp = min(min(a, b), A[i]);</span><br><span class="line">            max_tmp = max(max(a, b), A[i]);</span><br><span class="line">            result = max(result, max_tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>For exam]]>
    </summary>
    
      <category term="动态规划" scheme="http://yutianx.info/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="problems" scheme="http://yutianx.info/categories/problems/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[STL:iterator的一些常见操作]]></title>
    <link href="http://yutianx.info/2014/11/25/2014-11-25-stl-iterator/"/>
    <id>http://yutianx.info/2014/11/25/2014-11-25-stl-iterator/</id>
    <published>2014-11-25T02:20:20.000Z</published>
    <updated>2015-04-30T13:16:04.000Z</updated>
    <content type="html"><![CDATA[<p>有时在做题时，碰到vector之类的容器时，如果我要制定一个容器的范围，那么我就不得不声明三个形参，一个vector，两个下标。但是在这里我们还可以实用迭代器来实现，这样，就只需要实用两个形参就可以了。</p>
<p>iterator在实际题目中的使用见重建二叉树部分。</p>
<p>下面，举出一些iterator的常用函数：</p>
<ul>
<li>begin(), end()</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;       <span class="comment">// std::vector, std::begin, std::end</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> foo[] = &#123;a&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bar;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// iterate foo: inserting into bar</span></span><br><span class="line">  <span class="comment">//数组也可以使用</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">std</span>::begin(foo); it!=<span class="built_in">std</span>::end(foo); ++it)</span><br><span class="line">    bar.push_back(*it);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// iterate bar: print contents:</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"bar contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">std</span>::begin(bar); it!=<span class="built_in">std</span>::end(bar); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>distance()</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// advance example</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iterator&gt;     <span class="comment">// std::distance</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;list&gt;         <span class="comment">// std::list</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) mylist.push_back (i*<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator first = mylist.begin();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator last = mylist.end();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The distance is: "</span> &lt;&lt; <span class="built_in">std</span>::distance(first,last) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>next()</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next example</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iterator&gt;     <span class="comment">// std::next</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;list&gt;         <span class="comment">// std::list</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;    <span class="comment">// std::for_each</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) mylist.push_back (i*<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist:"</span>;</span><br><span class="line">  <span class="built_in">std</span>::for_each (mylist.begin(),</span><br><span class="line">                 <span class="built_in">std</span>::next(mylist.begin(),<span class="number">5</span>),</span><br><span class="line">                 [](<span class="keyword">int</span> x) &#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x;&#125; );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>pre()</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prev example</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iterator&gt;     <span class="comment">// std::next</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;list&gt;         <span class="comment">// std::list</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;    <span class="comment">// std::for_each</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) mylist.push_back (i*<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The last element is "</span> &lt;&lt; *<span class="built_in">std</span>::prev(mylist.end()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>reverse_iterator()</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reverse_iterator example</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iterator&gt;     <span class="comment">// std::reverse_iterator</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;       <span class="comment">// std::vector</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) myvector.push_back(i);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter_type;</span><br><span class="line">                                                         <span class="comment">// ? 0 1 2 3 4 5 6 7 8 9 ?</span></span><br><span class="line">  <span class="function">iter_type <span class="title">from</span> <span class="params">(myvector.begin()</span>)</span>;                     <span class="comment">//   ^</span></span><br><span class="line">                                                         <span class="comment">//         ------&gt;</span></span><br><span class="line">  <span class="function">iter_type <span class="title">until</span> <span class="params">(myvector.end()</span>)</span>;                      <span class="comment">//                       ^</span></span><br><span class="line">                                                         <span class="comment">//</span></span><br><span class="line">  <span class="built_in">std</span>::reverse_iterator&lt;iter_type&gt; rev_until (from);     <span class="comment">// ^</span></span><br><span class="line">                                                         <span class="comment">//         &lt;------</span></span><br><span class="line">  <span class="built_in">std</span>::reverse_iterator&lt;iter_type&gt; rev_from (until);     <span class="comment">//                     ^</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myvector:"</span>;</span><br><span class="line">  <span class="keyword">while</span> (rev_from != rev_until)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *rev_from++;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>有时在做题时，碰到vector之类的容器时，如果我要制定一个容器的范围，那么我就不得不声明三个形参，一个vector，两个下标。但是在这里我们还可以实用迭代器来实现，这样，就只需要实用两个形参就可以了。</p>
<p>iterator在实际题目中的使用见重建二叉树部分。</]]>
    </summary>
    
      <category term="cpp" scheme="http://yutianx.info/categories/cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[STL: upper_bound & lower_bound]]></title>
    <link href="http://yutianx.info/2014/11/23/2014-11-23-upper-bound-lower-bound/"/>
    <id>http://yutianx.info/2014/11/23/2014-11-23-upper-bound-lower-bound/</id>
    <published>2014-11-23T03:39:20.000Z</published>
    <updated>2015-05-04T13:54:41.000Z</updated>
    <content type="html"><![CDATA[<p>有时候，我们用到二分搜索的时候需要求出大于等于一个数的最小值和小于等于一个数的最大值，这个时候我们除了自己写出二分搜索的代码外，还可以使用这两个函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lower_bound/upper_bound example</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;    <span class="comment">// std::lower_bound, std::upper_bound, std::sort</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;       <span class="comment">// std::vector</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> myints[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">20</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(myints,myints+<span class="number">8</span>);           <span class="comment">// 10 20 30 30 20 10 10 20</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::sort (v.begin(), v.end());                <span class="comment">// 10 10 10 20 20 20 30 30</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator low,up;</span><br><span class="line">  low=<span class="built_in">std</span>::lower_bound (v.begin(), v.end(), <span class="number">20</span>); <span class="comment">//          ^</span></span><br><span class="line">  up= <span class="built_in">std</span>::upper_bound (v.begin(), v.end(), <span class="number">20</span>); <span class="comment">//                   ^</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lower_bound at position "</span> &lt;&lt; (low- v.begin()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"upper_bound at position "</span> &lt;&lt; (up - v.begin()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>有时候，我们用到二分搜索的时候需要求出大于等于一个数的最小值和小于等于一个数的最大值，这个时候我们除了自己写出二分搜索的代码外，还可以使用这两个函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutte]]>
    </summary>
    
      <category term="二分搜索" scheme="http://yutianx.info/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"/>
    
      <category term="cpp" scheme="http://yutianx.info/categories/cpp/"/>
    
  </entry>
  
</feed>