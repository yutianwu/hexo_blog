
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>yutian&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="雨天">
    

    
    <meta name="description" content="dsfd">
<meta property="og:type" content="website">
<meta property="og:title" content="yutian's blog">
<meta property="og:url" content="http://yutianx.info/index.html">
<meta property="og:site_name" content="yutian's blog">
<meta property="og:description" content="dsfd">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yutian's blog">
<meta name="twitter:description" content="dsfd">

    
    <link rel="alternative" href="/atom.xml" title="yutian&#39;s blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/logo.svg">
    <link rel="apple-touch-icon-precomposed" href="/img/logo.svg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="yutian&#39;s blog" title="yutian&#39;s blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="yutian&#39;s blog">yutian&#39;s blog</a></h1>
				<h2 class="blog-motto">stay hungry, stay foolish</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yutianx.info">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2015/10/17/2015-10-17-leetcode-product-of-array-except-self/" title="LeetCode: Product of Array Except Self" itemprop="url">
  
    <h1 itemprop="name">LeetCode: Product of Array Except Self</h1>
    
     
           <p itemprop="description" >Given an array of n integers where n &amp;gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of</p>
        
    
    <time datetime="2015-10-17T04:00:20.000Z" itemprop="datePublished">2015-10-17</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2015/10/08/2015-10-08-leetcode-remove-linked-list-elements/" title="LeetCode: Remove Linked List Elements" itemprop="url">
  
    <h1 itemprop="name">LeetCode: Remove Linked List Elements</h1>
    
     
           <p itemprop="description" >Remove all elements from a linked list of integers that have value val.
Example
Given: 1 —&amp;gt; 2 —&amp;gt; 6 —&amp;gt; 3 —&amp;gt; 4 —&amp;gt; 5 —&amp;gt; 6, va</p>
        
    
    <time datetime="2015-10-08T05:42:20.000Z" itemprop="datePublished">2015-10-08</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2015/10/07/2015-10-07-leetcode-rectangle-area/" title="LeetCode: Rectangle Area" itemprop="url">
  
    <h1 itemprop="name">LeetCode: Rectangle Area</h1>
    
     
           <p itemprop="description" >Find the total area covered by two rectilinear rectangles in a 2D plane.
Each rectangle is defined by its bottom left corner and top right c</p>
        
    
    <time datetime="2015-10-07T14:11:20.000Z" itemprop="datePublished">2015-10-07</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2015/10/06/2015-10-06-leetcode-word-pattern/" title="LeetCode: Word Pattern" itemprop="url">
  
    <h1 itemprop="name">LeetCode: Word Pattern</h1>
    
     
           <p itemprop="description" >Given a pattern and a string str, find if str follows the same pattern.
Examples:

pattern = “abba”, str = “dog cat cat dog” should return t</p>
        
    
    <time datetime="2015-10-06T13:40:20.000Z" itemprop="datePublished">2015-10-06</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2015/10/05/2015-10-05-leetcode-ugly-number/" title="LeetCode: Ugly Number" itemprop="url">
  
    <h1 itemprop="name">LeetCode: Ugly Number</h1>
    
     
           <p itemprop="description" >Write a program to check whether a given number is an ugly number.
Ugly numbers are positive numbers whose prime factors only include 2, 3, </p>
        
    
    <time datetime="2015-10-05T14:09:20.000Z" itemprop="datePublished">2015-10-05</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2015/10/04/2015-10-04-leetcode-implement-queue-using-stacks/" title="LeetCode: Implement Queue using Stacks" itemprop="url">
  
    <h1 itemprop="name">LeetCode: Implement Queue using Stacks</h1>
    
     
           <p itemprop="description" >Implement the following operations of a queue using stacks.

push(x) — Push element x to the back of queue.
pop() — Removes the element from</p>
        
    
    <time datetime="2015-10-04T11:17:20.000Z" itemprop="datePublished">2015-10-04</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2015/10/04/2015-10-04-leetcode-reverse-linked-list/" title="LeetCode: Reverse Linked List" itemprop="url">
  
    <h1 itemprop="name">LeetCode: Reverse Linked List</h1>
    
     
           <p itemprop="description" >Reverse a singly linked list.

思路还是很简单的，有三个节点的临时变量就可以了，主要是代码要写得精炼。
代码如下：
12345678910111213141516171819202122/** * Definition for singly-link</p>
        
    
    <time datetime="2015-10-04T10:50:20.000Z" itemprop="datePublished">2015-10-04</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2015/10/03/2015-10-03-leetcode-lowest-common-ancestor-of-a-binary-tree/" title="LeetCode: Lowest Common Ancestor of a Binary Tree" itemprop="url">
  
    <h1 itemprop="name">LeetCode: Lowest Common Ancestor of a Binary Tree</h1>
    
     
           <p itemprop="description" >Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

想法还是很简单，如果要判断当前节点是否是两个节点$p,q$的最低公共父节点，（假设我们是从上往下</p>
        
    
    <time datetime="2015-10-03T13:49:20.000Z" itemprop="datePublished">2015-10-03</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2015/09/30/2015-09-30-leetcode-add-digits/" title="LeetCode: Add Digits" itemprop="url">
  
    <h1 itemprop="name">LeetCode: Add Digits</h1>
    
     
           <p itemprop="description" >Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.
For example:
Given num = 38, the proces</p>
        
    
    <time datetime="2015-09-30T13:49:20.000Z" itemprop="datePublished">2015-09-30</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2015/05/20/2015-05-20-docker-filesystem/" title="Docker文件系统" itemprop="url">
  
    <h1 itemprop="name">Docker文件系统</h1>
    
     
           <p itemprop="description" >Docker文件系统概述典型的Linux文件系统由bootfs和rootfs两部分组成，bootfs(boot file system)主要包含 bootloader和kernel，bootloader主要是引导加载kernel，当kernel被加载到内存中后 bootfs就被u</p>
        
    
    <time datetime="2015-05-20T05:11:20.000Z" itemprop="datePublished">2015-05-20</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2015/05/03/2015-05-03-operating-system/" title="操作系统的一些笔记" itemprop="url">
  
    <h1 itemprop="name">操作系统的一些笔记</h1>
    
     
           <p itemprop="description" >死锁两个或多个进程无线地等待一个事件，而该时间只可能由这些等待进程之一来产生。当出现这样的状态时，这些进程就称为死锁(deadlocked)。</p>
        
    
    <time datetime="2015-05-03T04:53:20.000Z" itemprop="datePublished">2015-05-03</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2015/04/30/2015-04-30-chroot/" title="chroot的使用与构建一个简单的rootfs" itemprop="url">
  
    <h1 itemprop="name">chroot的使用与构建一个简单的rootfs</h1>
    
     
           <p itemprop="description" >什么是chrootchroot，即 change root directory (更改 root 目录)。在 linux 系统中，系统默认的目录结构都是以 /，即是以根 (root) 开始的。而在使用 chroot 之后，系统的目录结构将以指定的位置作为 / 位置。
为何使用ch</p>
        
    
    <time datetime="2015-04-30T08:21:20.000Z" itemprop="datePublished">2015-04-30</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2015/04/29/2015-04-29-ball-without-boss/" title="动态规划: 树形dp-没有上司的舞会" itemprop="url">
  
    <h1 itemprop="name">动态规划: 树形dp-没有上司的舞会</h1>
    
     
           <p itemprop="description" >题目描述
Ural大学有N个职员，编号为1~N。他们有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。每个职员有一个快乐指数。现在有个周年庆宴会，要求与会职员的快乐指数最大。但是，没有职员愿和直接上司一起与会。意思是如果某人直接上司去了，那么他就不</p>
        
    
    <time datetime="2015-04-29T13:16:20.000Z" itemprop="datePublished">2015-04-29</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2015/04/28/2015-04-28-go-schedule/" title="goroutine与调度器" itemprop="url">
  
    <h1 itemprop="name">goroutine与调度器</h1>
    
     
           <p itemprop="description" >本文为转载，原文地址：https://github.com/Unknwon/gcblog/blob/master/content/11-golang-schedule.md

我们都知道 Go 语言是原生支持语言级并发的，这个并发的最小逻辑单元就是 goroutine。gorou</p>
        
    
    <time datetime="2015-04-28T05:33:20.000Z" itemprop="datePublished">2015-04-28</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2015/04/28/2015-04-28-go-sort-interface/" title="golang--sort包中的Interface" itemprop="url">
  
    <h1 itemprop="name">golang--sort包中的Interface</h1>
    
     
           <p itemprop="description" >golang的sort包中定义了一个名为Interface的interface，还有一个Sort(Interface)的函数：
1234567891011type Interface interface &amp;#123;        // Len is the number of </p>
        
    
    <time datetime="2015-04-28T01:56:20.000Z" itemprop="datePublished">2015-04-28</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2015/04/28/2015-04-28-go-interface/" title="golang中interface需要注意的一点地方" itemprop="url">
  
    <h1 itemprop="name">golang中interface需要注意的一点地方</h1>
    
     
           <p itemprop="description" >先看代码：
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport (        &quot;fmt&quot;)type List []int</p>
        
    
    <time datetime="2015-04-28T01:56:20.000Z" itemprop="datePublished">2015-04-28</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2015/04/27/2015-04-27-visit-gallary/" title="动态规划: 树形dp-访问艺术馆" itemprop="url">
  
    <h1 itemprop="name">动态规划: 树形dp-访问艺术馆</h1>
    
     
           <p itemprop="description" >题目描述
皮尔是一个出了名的盗画者，他经过数月的精心准备，打算到艺术馆盗画。艺术馆的结构，每条走廊要么分叉为二条走廊，要么通向一个展览室。皮尔知道每个展室里藏画的数量，并且他精确地测量了通过每条走廊的时间，由于经验老道，他拿下一副画需要5秒的时间。你的任务是设计一个程序，计算在警</p>
        
    
    <time datetime="2015-04-27T13:58:20.000Z" itemprop="datePublished">2015-04-27</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2015/04/23/2015-04-23-Palindrome_Partitioning_II /" title="动态规划: Palindrome Partitioning II " itemprop="url">
  
    <h1 itemprop="name">动态规划: Palindrome Partitioning II </h1>
    
     
           <p itemprop="description" >Given a string s, partition s such that every substring of the partition is a palindrome.
Return the minimum cuts needed for a palindrome pa</p>
        
    
    <time datetime="2015-04-23T03:38:20.000Z" itemprop="datePublished">2015-04-23</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2015/04/23/2015-04-23-leetcode-Divide-Two-Integers/" title="Math: Divide Two Integers" itemprop="url">
  
    <h1 itemprop="name">Math: Divide Two Integers</h1>
    
     
           <p itemprop="description" >Divide two integers without using multiplication, division and mod operator.
If it is overflow, return MAX_INT.

123456789101112131415161718</p>
        
    
    <time datetime="2015-04-23T01:56:20.000Z" itemprop="datePublished">2015-04-23</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2015/04/11/2015-04-11-bag-problem/" title="动态规划：背包问题" itemprop="url">
  
    <h1 itemprop="name">动态规划：背包问题</h1>
    
     
           <p itemprop="description" >1.01背包问题
有n个重量和价值分别为wi和vi的物品。从这些物品中挑选出总重量不超过W的物品，求所有挑选方案中价值总和的最大值。其中1 &amp;lt; n &amp;lt; 100, 1 &amp;lt; wi, vi &amp;lt; 100, 1 &amp;lt; W &amp;lt; 10000

在前面的博客中说</p>
        
    
    <time datetime="2015-04-11T15:21:20.000Z" itemprop="datePublished">2015-04-11</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2015/04/10/2015-04-10-leetcode-Dungeon-Game/" title="动态规划: Dungeon Game" itemprop="url">
  
    <h1 itemprop="name">动态规划: Dungeon Game</h1>
    
     
           <p itemprop="description" >The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms lai</p>
        
    
    <time datetime="2015-04-10T06:47:20.000Z" itemprop="datePublished">2015-04-10</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2015/03/11/2015-03-11-go-sync/" title="golang中的sync" itemprop="url">
  
    <h1 itemprop="name">golang中的sync</h1>
    
     
           <p itemprop="description" >在golang中使用并发时，除了使用channel用来同步以外，还可以使用sync包来实现。
sync包中的WaitGroup实现了一个类似任务队列的结构，你可以向队列中加入任务，任务完成后就把任务从队列中移除，如果队列中的任务没有全部完成，队列就会触发阻塞以阻止程序继续运行。
</p>
        
    
    <time datetime="2015-03-11T05:11:20.000Z" itemprop="datePublished">2015-03-11</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2015/01/29/2015-01-29-cpp-fill/" title="c++中fill与fill_n函数" itemprop="url">
  
    <h1 itemprop="name">c++中fill与fill_n函数</h1>
    
     
           <p itemprop="description" >fill函数fill函数的作用是：将一个区间的元素都赋予val值。函数参数：fill(first,last,val);//first为容器的首迭代器，last为容器的末迭代器，val为将要替换的值。
123456789101112131415161718// fill algor</p>
        
    
    <time datetime="2015-01-29T12:01:20.000Z" itemprop="datePublished">2015-01-29</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/11/30/2014-11-30-c-constant-pointer/" title="常量指针和指针常量" itemprop="url">
  
    <h1 itemprop="name">常量指针和指针常量</h1>
    
     
           <p itemprop="description" >常量指针常量指针是说指针所指向的内容是常量。
比如:123char a[10] = &quot;hello&quot;;const char *p = a;*p = &#39;a&#39;; //这样是不行的，因为申明的是一个常量指针
指针常量指针常量说的是指针是一个常量，不能够更改指针的值。
比如：1234cha</p>
        
    
    <time datetime="2014-11-30T06:41:20.000Z" itemprop="datePublished">2014-11-30</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/11/26/2014-11-26-leetcode-maximum-product-subarray/" title="动态规划: Maximum Product Subarray" itemprop="url">
  
    <h1 itemprop="name">动态规划: Maximum Product Subarray</h1>
    
     
           <p itemprop="description" >Find the contiguous subarray within an array (containing at least one number) which has the largest product.
For example, given the array [2</p>
        
    
    <time datetime="2014-11-26T13:45:20.000Z" itemprop="datePublished">2014-11-26</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/11/25/2014-11-25-stl-iterator/" title="STL:iterator的一些常见操作" itemprop="url">
  
    <h1 itemprop="name">STL:iterator的一些常见操作</h1>
    
     
           <p itemprop="description" >有时在做题时，碰到vector之类的容器时，如果我要制定一个容器的范围，那么我就不得不声明三个形参，一个vector，两个下标。但是在这里我们还可以实用迭代器来实现，这样，就只需要实用两个形参就可以了。
iterator在实际题目中的使用见重建二叉树部分。
下面，举出一些iter</p>
        
    
    <time datetime="2014-11-25T02:20:20.000Z" itemprop="datePublished">2014-11-25</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/11/23/2014-11-23-upper-bound-lower-bound/" title="STL: upper_bound &amp; lower_bound" itemprop="url">
  
    <h1 itemprop="name">STL: upper_bound &amp; lower_bound</h1>
    
     
           <p itemprop="description" >有时候，我们用到二分搜索的时候需要求出大于等于一个数的最小值和小于等于一个数的最大值，这个时候我们除了自己写出二分搜索的代码外，还可以使用这两个函数。
1234567891011121314151617181920// lower_bound/upper_bound exampl</p>
        
    
    <time datetime="2014-11-23T03:39:20.000Z" itemprop="datePublished">2014-11-23</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/11/23/2014-11-23-binary-search/" title="二分搜索" itemprop="url">
  
    <h1 itemprop="name">二分搜索</h1>
    
     
           <p itemprop="description" >我们可以很快地写出在已排序数组中查找某一个数的代码，但是如果我们要找出某个数的上界和下届有时候就会多费点心思，在这里我们可以看看这三种方式的不同之处,另外，在实际应用中，我们可以不用自己是实现，直接使用STL中的upper_bound和lower_bound函数就可以了。
123</p>
        
    
    <time datetime="2014-11-23T03:38:20.000Z" itemprop="datePublished">2014-11-23</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/11/22/2014-11-22-floyd-warshall/" title="图：Floyd-Warshall算法" itemprop="url">
  
    <h1 itemprop="name">图：Floyd-Warshall算法</h1>
    
     
           <p itemprop="description" >Floyd-Warshall算法是一种动态规划算法，动规算法的话只要得出递推公式，那么程序就会非常简洁。
这里也不给出算法的递推公式，详见算法导论第25章。
在这里，需要强调的一点就是，动规算法一般是需要辅助的数组来存储中间值的，但是有时我们可以巧妙的利用算法的执行顺序，使用滚动</p>
        
    
    <time datetime="2014-11-22T03:40:20.000Z" itemprop="datePublished">2014-11-22</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/11/21/2014-11-21-rebuild-binary-tree/" title="重建二叉树" itemprop="url">
  
    <h1 itemprop="name">重建二叉树</h1>
    
     
           <p itemprop="description" >重建二叉树就是给定二叉树的两种遍历的结果，比如前序遍历，中序遍历，然后根据这两种遍历结果来重建二叉树。
比如说给定一个二叉树

前序遍历：$[1, 2, 4, 5, 3, 6, 7]$
中序遍历：$[4, 2, 5, 1, 6, 3, 7]$

然后根据这两个遍历结果重建二叉树。</p>
        
    
    <time datetime="2014-11-21T10:08:20.000Z" itemprop="datePublished">2014-11-21</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/11/20/2014-11-20-leetcode-insert-intervals/" title="二分搜索: Insert Interval" itemprop="url">
  
    <h1 itemprop="name">二分搜索: Insert Interval</h1>
    
     
           <p itemprop="description" >Insert Interval
Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).
You may assume that</p>
        
    
    <time datetime="2014-11-20T09:40:20.000Z" itemprop="datePublished">2014-11-20</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/11/20/2014-11-20-edmonds-karp/" title="最大流: Edmonds-Karp算法" itemprop="url">
  
    <h1 itemprop="name">最大流: Edmonds-Karp算法</h1>
    
     
           <p itemprop="description" >Edmonds-Karp算法是Ford-Fulkerson算法的一种实现，时间复杂度为$O(VE^2)$.
思想就是每次在源点和终点之间都找出一条增广路径，然后根据这条增广路径的容量计算图的残留网络，继续在残留网络上找增广路径，直至找不出增广路径为止，最后得到的增广路径的和即为图</p>
        
    
    <time datetime="2014-11-20T07:03:20.000Z" itemprop="datePublished">2014-11-20</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/11/19/2014-08-28-sorting/" title="基础排序(sorting)" itemprop="url">
  
    <h1 itemprop="name">基础排序(sorting)</h1>
    
     
           <p itemprop="description" >选择排序(selection sort)选择排序的思想就是每次在数组未排序部分选择最大或者最小的数值，然后将它放在正确的位置上。代码实现如下:123456789101112131415161718192021public static void insertionSort(Com</p>
        
    
    <time datetime="2014-11-19T11:39:20.000Z" itemprop="datePublished">2014-11-19</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/11/18/2014-11-18-segment-tree/" title="数据结构：线段树(segment tree)" itemprop="url">
  
    <h1 itemprop="name">数据结构：线段树(segment tree)</h1>
    
     
           <p itemprop="description" >线段树的概念线段树是擅长处理区间的，形如下图的数据结构。线段树是一棵完美二叉树（Perfect Binary Tree)（所有的叶子的深度都相同，并且每个节点要么是叶子要么有2个儿子的树）树上的每个节点都维护一个区间。根维护的是整个区间，每个节点维护的是父亲的区间二等分后的其中一</p>
        
    
    <time datetime="2014-11-18T02:39:20.000Z" itemprop="datePublished">2014-11-18</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/11/15/2014-11-15-math-prime/" title="素数" itemprop="url">
  
    <h1 itemprop="name">素数</h1>
    
     
           <p itemprop="description" >判断一个数是否为素数很容易想到，我们只要把$2\rightarrow n-1$遍历一遍，就可以得到一个数是否为素数。但是这样的话时间复杂度将会是O(n).再想想其实我们可以只遍历$2\rightarrow n/2$，但是这样还是$O(n)$.
那么假设d是n的约数，那么n/d也是</p>
        
    
    <time datetime="2014-11-15T03:01:20.000Z" itemprop="datePublished">2014-11-15</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/11/13/2014-11-13-dijkstra/" title="图:单源点最短路之dijkstra算法" itemprop="url">
  
    <h1 itemprop="name">图:单源点最短路之dijkstra算法</h1>
    
     
           <p itemprop="description" >dijkstra算法也是采用的贪心算法，和prim算法非常像，可以比较一下代码，就两三行不同。
思想就是根据各顶点到源点的距离生成一个优先级队列，初始时除了源点距离为零，其它都为INF。这样，每次从队列中取出最短路径的顶点，然后对每个邻接的顶点进行松弛，更新队列。重复操作直至队列</p>
        
    
    <time datetime="2014-11-13T08:02:20.000Z" itemprop="datePublished">2014-11-13</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/11/12/2014-11-12-leetcode-Subsets/" title="位运算与深搜: subsets" itemprop="url">
  
    <h1 itemprop="name">位运算与深搜: subsets</h1>
    
     
           <p itemprop="description" >Given a set of distinct integers, S, return all possible subsets.
Note:Elements in a subset must be in non-descending order.
The solution se</p>
        
    
    <time datetime="2014-11-12T13:00:20.000Z" itemprop="datePublished">2014-11-12</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/11/07/2014-11-07-linux-virtual-network/" title="Linux网络虚拟化的一些概念" itemprop="url">
  
    <h1 itemprop="name">Linux网络虚拟化的一些概念</h1>
    
     
           <p itemprop="description" >bridgeBridge（桥）是 Linux 上用来做 TCP/IP 二层协议交换的设备，与现实世界中的交换机功能相似。Bridge 设备实例可以和 Linux 上其他网络设备实例连接，既 attach 一个从设备，类似于在现实世界中的交换机和一个用户终端之间连接一根网线。当有数</p>
        
    
    <time datetime="2014-11-06T16:00:00.000Z" itemprop="datePublished">2014-11-07</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/11/01/2014-11-1-leetcode-Clone-Graph/" title="DFS,图: Clone Graph" itemprop="url">
  
    <h1 itemprop="name">DFS,图: Clone Graph</h1>
    
     
           <p itemprop="description" >Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.

1234567891011121314151617181920212223242526</p>
        
    
    <time datetime="2014-11-01T13:04:20.000Z" itemprop="datePublished">2014-11-01</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/10/30/2014-10-30-dag-shortest-path/" title="图: DAG中使用拓扑排序来求单源点最短路径" itemprop="url">
  
    <h1 itemprop="name">图: DAG中使用拓扑排序来求单源点最短路径</h1>
    
     
           <p itemprop="description" >求单源点最短路径时，使用Bellman-Ford算法的需要对所有边松弛V-1遍。但是如果我们知道一个图是一个有向无环图时，我们先对所有顶点进行一次拓扑排序，然后依次对每个顶点连接的边松弛一遍就可以了。时间复杂度为O(V+E)。
123456DAG-SHORTEST-PATHS(G</p>
        
    
    <time datetime="2014-10-30T08:55:00.000Z" itemprop="datePublished">2014-10-30</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/10/30/2014-10-30-throw-disks/" title="扔盘子问题" itemprop="url">
  
    <h1 itemprop="name">扔盘子问题</h1>
    
     
           <p itemprop="description" >题目链接：扔盘子
The story is about throwing concrete disks into an old dry well. The well is made of concrete rings that can have different (intern</p>
        
    
    <time datetime="2014-10-30T07:10:20.000Z" itemprop="datePublished">2014-10-30</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/10/28/2014-10-28-bellman-ford/" title="图:单源点最短路径之Bellman-Ford算法" itemprop="url">
  
    <h1 itemprop="name">图:单源点最短路径之Bellman-Ford算法</h1>
    
     
           <p itemprop="description" >Bellman-Ford算法能够在一般的情况下(存在负权边的情况)， 解决单源点最短路径问题，而且能够判断图中是否存在负值回路。
算法用到了两个辅助数组D,P。使用D来记录源点到各个点得最短距离。使用P来记录最短路的路径。
算法的思路如下:

对两个数组进行初始化，将D[0]赋值</p>
        
    
    <time datetime="2014-10-28T09:48:20.000Z" itemprop="datePublished">2014-10-28</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/10/26/2014-10-26-kruskal/" title="图:最小生成树之kruskal算法" itemprop="url">
  
    <h1 itemprop="name">图:最小生成树之kruskal算法</h1>
    
     
           <p itemprop="description" >kruskal法是一种贪心算法，与prim算法相似。
在kruskal算法中，我们用到了并查集。
算法的思想是这样的:

对所有的顶点建立一个并查集，对所有的边先进行排序
遍历每一条边，（因为我们之前对边进行排过序，所以我们每次都是选择最短的边），如果边的两个端点不在通一个集合里</p>
        
    
    <time datetime="2014-10-26T11:56:20.000Z" itemprop="datePublished">2014-10-26</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/10/26/2014-10-26-Balanced-Lineup/" title="线段树、平方分割:POJ 3264 Balanced Lineup" itemprop="url">
  
    <h1 itemprop="name">线段树、平方分割:POJ 3264 Balanced Lineup</h1>
    
     
           <p itemprop="description" >12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &amp;lt;iostream&amp;gt;#i</p>
        
    
    <time datetime="2014-10-26T07:56:20.000Z" itemprop="datePublished">2014-10-26</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/10/26/2014-10-26-union-find/" title="图:并查集" itemprop="url">
  
    <h1 itemprop="name">图:并查集</h1>
    
     
           <p itemprop="description" >并查集是一种树型的数据结构，其保持着用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。
并查集一般支持两种操作：

查找    查询两个元素a和b是否在同一个集合
合并    合并a和b所在的两个集合

并查集一般使用树形结构，但不是二叉树。下面具体说说并查集</p>
        
    
    <time datetime="2014-10-26T06:40:20.000Z" itemprop="datePublished">2014-10-26</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/10/25/2014-10-25-prim-mst/" title="图:最小生成树之Prim算法" itemprop="url">
  
    <h1 itemprop="name">图:最小生成树之Prim算法</h1>
    
     
           <p itemprop="description" >123456789101112131415贪心算法之最小生成树伪代码：MST-PRIM（G, w, r）for each u in V[G]    do key[u] &amp;lt;- INF    pi[u] &amp;lt;- NILkey[r] &amp;lt;- 0Q &amp;lt;- V[G]wh</p>
        
    
    <time datetime="2014-10-25T03:11:20.000Z" itemprop="datePublished">2014-10-25</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/10/23/2014-10-24-binary-tree-traversal/" title="二叉树的普通非递归遍历" itemprop="url">
  
    <h1 itemprop="name">二叉树的普通非递归遍历</h1>
    
     
           <p itemprop="description" >这里给出二叉树的普通非递归遍历：
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566</p>
        
    
    <time datetime="2014-10-23T13:16:20.000Z" itemprop="datePublished">2014-10-23</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/10/23/2014-10-23-Topological-sorting/" title="图：拓扑排序(Topological sort)" itemprop="url">
  
    <h1 itemprop="name">图：拓扑排序(Topological sort)</h1>
    
     
           <p itemprop="description" >由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序。

每个顶点出现且只出现一次；
若A在序列中排在B的前面，则在图中不存在从B到A的路径。

也可以定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点A到顶点B的路径，那么在排序</p>
        
    
    <time datetime="2014-10-23T13:16:20.000Z" itemprop="datePublished">2014-10-23</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/10/23/2014-10-23-leetcode-Merge-k-Sorted-Lists/" title="堆排序: Merge k Sorted Lists" itemprop="url">
  
    <h1 itemprop="name">堆排序: Merge k Sorted Lists</h1>
    
     
           <p itemprop="description" >Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
这个题如果按照常规思路来做得话，就是将k个链表两两合并，但是这样做的时间复杂度高.</p>
        
    
    <time datetime="2014-10-23T09:10:20.000Z" itemprop="datePublished">2014-10-23</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/10/23/2014-10-23-c-traps/" title="c语言的一些需要注意的小问题" itemprop="url">
  
    <h1 itemprop="name">c语言的一些需要注意的小问题</h1>
    
     
           <p itemprop="description" >#define square(x) x * x如果执行的是square(z + 1),那么替换后的结果为z + 1*z + 1，结果是不对的，所以使用宏的时候还是得非常小心。 
c++中auto的使用根据初始化表达式自动推断被声明的变量的类型，如：
1234auto f=3.14</p>
        
    
    <time datetime="2014-10-23T01:35:20.000Z" itemprop="datePublished">2014-10-23</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/10/20/2014-10-20-Polish-notation/" title="四则运算计算器实现" itemprop="url">
  
    <h1 itemprop="name">四则运算计算器实现</h1>
    
     
           <p itemprop="description" >波兰表示法与逆波兰表示法波兰表示法（Polish notation，或波兰记法），是一种逻辑、算术和代数表示方法，其特点是操作符置于操作数的前面，因此也称做前缀表示法。与逆波兰表示法不同，前缀表达式基本没有在商业计算器中使用过，但是其体系经常在编译器构造的概念教学中首先使用。
逆</p>
        
    
    <time datetime="2014-10-20T07:52:20.000Z" itemprop="datePublished">2014-10-20</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/10/16/2014-10-16-binary-search-tree/" title="二叉搜索树(binary search tree)" itemprop="url">
  
    <h1 itemprop="name">二叉搜索树(binary search tree)</h1>
    
     
           <p itemprop="description" >二叉搜索树二叉搜索树又叫二叉查找树，是指一棵空树或者具有下列性质的二叉树：

若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
任意节点的左、右子树也分别为二叉查找树。
没有键值相等的节点（n</p>
        
    
    <time datetime="2014-10-16T02:33:20.000Z" itemprop="datePublished">2014-10-16</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/10/16/2014-10-16-stl-iterator-pointer/" title="iterator和指针" itemprop="url">
  
    <h1 itemprop="name">iterator和指针</h1>
    
     
           <p itemprop="description" >Iteratoriterator一般用在容器中，下面是所有容器都支持的一些运算：12345678910*iter 返回迭代器 iter 所指向的元素的引用iter-&amp;gt;mem 对 iter 进行解引用，获取指定元素中名为 mem 的成员。等效于 (*iter).mem++it</p>
        
    
    <time datetime="2014-10-16T00:34:20.000Z" itemprop="datePublished">2014-10-16</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/10/14/2014-10-14-bipartite-graph/" title="图: 二分图(用邻接表实现)" itemprop="url">
  
    <h1 itemprop="name">图: 二分图(用邻接表实现)</h1>
    
     
           <p itemprop="description" >给定一个具有n个顶点的图。要给图上每个顶点染色，并且要使相邻的顶点颜色不同。问是否能最多使用2种颜色进行染色？题目保证没有重边和自环。
这个题可以使用dfs来实现，思路还是挺简单的。
假设有一个简单图，随意从一个顶点开始染色，然后给相邻的顶点染上相反的色，如果相邻顶点和自己的色相</p>
        
    
    <time datetime="2014-10-14T12:26:20.000Z" itemprop="datePublished">2014-10-14</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/10/13/2014-10-13-c-function-pointer/" title="函数指针" itemprop="url">
  
    <h1 itemprop="name">函数指针</h1>
    
     
           <p itemprop="description" >函数指针是指向函数的指针变量。 因而“函数指针”本身首先应是指针变量，只不过该指针变量指向函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。如前所述，C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该</p>
        
    
    <time datetime="2014-10-13T15:28:20.000Z" itemprop="datePublished">2014-10-13</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/10/11/2014-10-11-poj-3253-Fence-Repair/" title="poj: 3253-Fence Repair" itemprop="url">
  
    <h1 itemprop="name">poj: 3253-Fence Repair</h1>
    
     
           <p itemprop="description" >DescriptionFarmer John wants to repair a small length of the fence around the pasture. He measures the fence and finds that he needs N (1 ≤ </p>
        
    
    <time datetime="2014-10-11T14:46:00.000Z" itemprop="datePublished">2014-10-11</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/10/11/2014-10-11-stl-priority-queue/" title="STL中的priority_queue" itemprop="url">
  
    <h1 itemprop="name">STL中的priority_queue</h1>
    
     
           <p itemprop="description" >如果碰到需要使用优先级序列的时候，可以不用自己去实现，使用STL中的便是，STL其它还提供了许多有用的工具，要善加利用。
下面是C++ Reference中priority_queue的使用的例子，知道这些应该就够了:
12template &amp;lt;class T, class </p>
        
    
    <time datetime="2014-10-11T14:18:20.000Z" itemprop="datePublished">2014-10-11</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/10/11/2014-10-11-poj-2431-Expedition/" title="poj: 2431-Expedition" itemprop="url">
  
    <h1 itemprop="name">poj: 2431-Expedition</h1>
    
     
           <p itemprop="description" >DescriptionA group of cows grabbed a truck and ventured on an expedition deep into the jungle. Being rather poor drivers, the cows unfortuna</p>
        
    
    <time datetime="2014-10-11T13:09:20.000Z" itemprop="datePublished">2014-10-11</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/10/11/2014-10-11-std-sort-function/" title="标准类库中的sort()函数" itemprop="url">
  
    <h1 itemprop="name">标准类库中的sort()函数</h1>
    
     
           <p itemprop="description" >由于有时候需要对数组啊之类的进行排序，那么是不是要自己动手写个快排呢，当然不是！
标准类库中自带一个很强大的sort()函数，在Expedition一题中，就用到了sort()。
下面是c++ Reference中sort()的一些用法，应该足够用了吧。
123456789101</p>
        
    
    <time datetime="2014-10-11T07:34:20.000Z" itemprop="datePublished">2014-10-11</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/10/11/2014-10-11-set-and-map/" title="set &amp; map" itemprop="url">
  
    <h1 itemprop="name">set &amp; map</h1>
    
     
           <p itemprop="description" >1.set如果需要使用二叉搜索树时，可以不用自己来实现，用STL中的set就可以。
使用set的话必须包含set的头文件。
set的操作如下代码：
123456789101112131415161718192021222324252627282930313233343536373</p>
        
    
    <time datetime="2014-10-11T07:34:20.000Z" itemprop="datePublished">2014-10-11</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/09/26/2014-09-26-leetcode-edit-distance/" title="动态规划: Edit Distance" itemprop="url">
  
    <h1 itemprop="name">动态规划: Edit Distance</h1>
    
     
           <p itemprop="description" >Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)</p>
        
    
    <time datetime="2014-09-26T08:07:20.000Z" itemprop="datePublished">2014-09-26</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/09/25/2014-09-25-leetcode-distinct-subsequences/" title="动态规划: Distinct Subsequences " itemprop="url">
  
    <h1 itemprop="name">动态规划: Distinct Subsequences </h1>
    
     
           <p itemprop="description" >Given a string S and a string T, count the number of distinct subsequences of T in S.A subsequence of a string is a new string which is form</p>
        
    
    <time datetime="2014-09-25T13:00:20.000Z" itemprop="datePublished">2014-09-25</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/09/24/2014-09-24-2301/" title="DFS: 部分和问题与01背包" itemprop="url">
  
    <h1 itemprop="name">DFS: 部分和问题与01背包</h1>
    
     
           <p itemprop="description" >部分和问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*此题见于挑战程序设计竞赛书30页给定整数 a 1 、a 2 、…、a n ，判断是否可以</p>
        
    
    <time datetime="2014-09-24T15:01:20.000Z" itemprop="datePublished">2014-09-24</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/09/24/2014-09-24-leetcode-decode-ways/" title="动态规划: Decode Ways" itemprop="url">
  
    <h1 itemprop="name">动态规划: Decode Ways</h1>
    
     
           <p itemprop="description" >A message containing letters from A-Z is being encoded to numbers using the &amp;gt;following mapping:&amp;#39;A&amp;#39; -&amp;gt; 1 &amp;#39;B&amp;#39; -&amp;gt; 2 ..</p>
        
    
    <time datetime="2014-09-24T11:09:20.000Z" itemprop="datePublished">2014-09-24</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/09/23/2014-09-23-leetcode-climbing-stairs/" title="动态规划: Climbing Stairs" itemprop="url">
  
    <h1 itemprop="name">动态规划: Climbing Stairs</h1>
    
     
           <p itemprop="description" >You are climbing a stair case. It takes n steps to reach to the top.Each time you can either climb 1 or 2 steps. In how many distinct ways c</p>
        
    
    <time datetime="2014-09-23T15:01:20.000Z" itemprop="datePublished">2014-09-23</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/09/23/2014-09-23-leetcode-word-break/" title="动态规划: Word Break" itemprop="url">
  
    <h1 itemprop="name">动态规划: Word Break</h1>
    
     
           <p itemprop="description" >Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary w</p>
        
    
    <time datetime="2014-09-23T07:31:20.000Z" itemprop="datePublished">2014-09-23</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/08/29/2014-08-29-heap-sort/" title="堆排序(heap sort)" itemprop="url">
  
    <h1 itemprop="name">堆排序(heap sort)</h1>
    
     
           <p itemprop="description" >二叉堆二叉堆是一个数组，它可以被看成一个近似的完全二叉树。如图一。树上的每个节点都对应数组中的一个元素。除了最底层外，该树是完全充满的，而且是从左向右填充。
二叉堆可以分为两种形式：最大堆和最小堆。在最大堆中，每一个父节点的值都要大于子节点的值；在最小堆中，每一个父节点的值都要小</p>
        
    
    <time datetime="2014-08-29T00:33:20.000Z" itemprop="datePublished">2014-08-29</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/08/12/2014-08-12-undirected-graph/" title="图:无向图(undirected graph)" itemprop="url">
  
    <h1 itemprop="name">图:无向图(undirected graph)</h1>
    
     
           <p itemprop="description" >1.无向图的数据结构我们一般有两种方式来表示图：

邻接矩阵：我们用一个V*V的布尔矩阵来表示一个无向图。当顶点v和顶点w之间有相连接的边时，定义v行w列的元素值为true，否则为false。这种表示方法最简单，但当图的顶点太多，且为一个稀疏矩阵时，空间就有点浪费了。
邻接表数组</p>
        
    
    <time datetime="2014-08-12T01:20:20.000Z" itemprop="datePublished">2014-08-12</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/08/11/2014-08-11-trie/" title="单词查找树(Tries)" itemprop="url">
  
    <h1 itemprop="name">单词查找树(Tries)</h1>
    
     
           <p itemprop="description" >单词查找树单词查找树是由字符串键中的所有字符构造而成，允许使用被查找键中的字符进行查找。比如说有一个字典，我们想要查询一个单词的释义，我们就可以根据单词生成一个单词查找树，然后将释义保存在值中。由于单词查找树的查找时间为单词字符串的长度，所以查找效率有时比排序的算法还要高。
图一</p>
        
    
    <time datetime="2014-08-11T01:03:20.000Z" itemprop="datePublished">2014-08-11</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/08/06/2014-08-06-brute_search_and_KMP/" title="子字符串查找——暴力查找与KMP算法" itemprop="url">
  
    <h1 itemprop="name">子字符串查找——暴力查找与KMP算法</h1>
    
     
           <p itemprop="description" >在这篇文章里，主要分析子字符串查找的两种算法：暴力查找和KMP算法。
1.暴力查找子字符串查找最简单的方法就是在需要查找的字符串(text)中模式(pattern)可能出现匹配的任何地方检查匹配是否存在。代码如下：1234567891011121314public static </p>
        
    
    <time datetime="2014-08-06T06:03:20.000Z" itemprop="datePublished">2014-08-06</time>
  </a>
</section>






  
<section class="post" itemscope itemprop="blogitem">
  
    <a href="/2014/08/04/2014-08-04-ubuntu-rsyslog/" title="Ubuntu 12.04 配置两级Rsyslog" itemprop="url">
  
    <h1 itemprop="name">Ubuntu 12.04 配置两级Rsyslog</h1>
    
     
           <p itemprop="description" >升级Rsyslog由于要使用Rsyslog的日志动态文件名的功能，必须将Rsyslog升级到高的版本（ubuntu上自带的版本为5.8.*）。升级的方式使用apt-get install12345678910111.修改/etc/apt/sources.list,添加如下两行：d</p>
        
    
    <time datetime="2014-08-03T16:00:00.000Z" itemprop="datePublished">2014-08-04</time>
  </a>
</section>







</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/LeetCode/" title="LeetCode">LeetCode<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/algorithms/" title="algorithms">algorithms<sup>22</sup></a></li>
		  
		
		  
			<li><a href="/categories/cpp/" title="cpp">cpp<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/docker/" title="docker">docker<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/golang/" title="golang">golang<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/linux/" title="linux">linux<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/problems/" title="problems">problems<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/操作系统/" title="操作系统">操作系统<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/动态规划/" title="动态规划">动态规划<sup>11</sup></a></li>
			
		
			
				<li><a href="/tags/Math/" title="Math">Math<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/二叉树/" title="二叉树">二叉树<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/图/" title="图">图<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Linked-List/" title="Linked List">Linked List<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Hash-Table/" title="Hash Table">Hash Table<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Stack/" title="Stack">Stack<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Tree/" title="Tree">Tree<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/二分搜索/" title="二分搜索">二分搜索<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Array/" title="Array">Array<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://1mhz.me" target="_blank" title="1mhz">1mhz</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Zhenxing Wu in BUPT. <br/>
			This is my blog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/yutianwu" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:wzxingbupt@gmail.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2015 
		
		<a href="/about" target="_blank" title="雨天">雨天</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"雨天byr"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-53478698-1', 'yutianx.info');  
ga('send', 'pageview');
</script>





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  <!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
 </html>
