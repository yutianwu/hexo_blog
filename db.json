{"meta":{"version":1,"warehouse":"1.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1},{"_id":"themes/jacman/source/js/totop.js","path":"js/totop.js","modified":1},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":1},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":1},{"_id":"themes/jacman/source/js/gallery.js","path":"js/gallery.js","modified":1},{"_id":"themes/jacman/source/img/scrollup.png","path":"img/scrollup.png","modified":1},{"_id":"themes/jacman/source/img/logo.svg","path":"img/logo.svg","modified":1},{"_id":"themes/jacman/source/img/favicon.ico","path":"img/favicon.ico","modified":1},{"_id":"themes/jacman/source/img/cc-zero.svg","path":"img/cc-zero.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by.svg","path":"img/cc-by.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-sa.svg","path":"img/cc-by-sa.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nd.svg","path":"img/cc-by-nd.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nc.svg","path":"img/cc-by-nc.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","path":"img/cc-by-nc-sa.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","path":"img/cc-by-nc-nd.svg","modified":1},{"_id":"themes/jacman/source/img/banner.jpg","path":"img/banner.jpg","modified":1},{"_id":"themes/jacman/source/img/author.png","path":"img/author.png","modified":1},{"_id":"themes/jacman/source/font/fontdiao.woff","path":"font/fontdiao.woff","modified":1},{"_id":"themes/jacman/source/font/fontdiao.ttf","path":"font/fontdiao.ttf","modified":1},{"_id":"themes/jacman/source/font/fontdiao.svg","path":"font/fontdiao.svg","modified":1},{"_id":"themes/jacman/source/font/fontdiao.eot","path":"font/fontdiao.eot","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":1},{"_id":"themes/jacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1},{"_id":"themes/jacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1},{"_id":"themes/jacman/source/css/style.styl","path":"css/style.styl","modified":1},{"_id":"source/img/visit_gallary.jpg","path":"img/visit_gallary.jpg","modified":1},{"_id":"source/img/virtual_network.png","path":"img/virtual_network.png","modified":1},{"_id":"source/img/union_find_4.png","path":"img/union_find_4.png","modified":1},{"_id":"source/img/union_find_3.png","path":"img/union_find_3.png","modified":1},{"_id":"source/img/union_find_2.png","path":"img/union_find_2.png","modified":1},{"_id":"source/img/union_find_1.png","path":"img/union_find_1.png","modified":1},{"_id":"source/img/trie-4.png","path":"img/trie-4.png","modified":1},{"_id":"source/img/trie-3.png","path":"img/trie-3.png","modified":1},{"_id":"source/img/trie-2.png","path":"img/trie-2.png","modified":1},{"_id":"source/img/trie-1.png","path":"img/trie-1.png","modified":1},{"_id":"source/img/throw_disks_2.png","path":"img/throw_disks_2.png","modified":1},{"_id":"source/img/throw_disks_1.png","path":"img/throw_disks_1.png","modified":1},{"_id":"source/img/sorting-1.png","path":"img/sorting-1.png","modified":1},{"_id":"source/img/segment_tree_4.png","path":"img/segment_tree_4.png","modified":1},{"_id":"source/img/segment_tree_3.png","path":"img/segment_tree_3.png","modified":1},{"_id":"source/img/segment_tree_2.png","path":"img/segment_tree_2.png","modified":1},{"_id":"source/img/segment_tree_1.png","path":"img/segment_tree_1.png","modified":1},{"_id":"source/img/kmp-2.png","path":"img/kmp-2.png","modified":1},{"_id":"source/img/kmp-1.png","path":"img/kmp-1.png","modified":1},{"_id":"source/img/heap-sort-1.png","path":"img/heap-sort-1.png","modified":1},{"_id":"source/img/gopher-bz.jpg","path":"img/gopher-bz.jpg","modified":1},{"_id":"source/img/golang-car.jpg","path":"img/golang-car.jpg","modified":1},{"_id":"source/img/floyd_1.png","path":"img/floyd_1.png","modified":1},{"_id":"source/img/edmonds_karp_1.png","path":"img/edmonds_karp_1.png","modified":1},{"_id":"source/img/docker-filesystem-9.png","path":"img/docker-filesystem-9.png","modified":1},{"_id":"source/img/docker-filesystem-8.png","path":"img/docker-filesystem-8.png","modified":1},{"_id":"source/img/docker-filesystem-7.png","path":"img/docker-filesystem-7.png","modified":1},{"_id":"source/img/docker-filesystem-6.png","path":"img/docker-filesystem-6.png","modified":1},{"_id":"source/img/docker-filesystem-5.png","path":"img/docker-filesystem-5.png","modified":1},{"_id":"source/img/docker-filesystem-4.png","path":"img/docker-filesystem-4.png","modified":1},{"_id":"source/img/docker-filesystem-3.png","path":"img/docker-filesystem-3.png","modified":1},{"_id":"source/img/docker-filesystem-3.jpg","path":"img/docker-filesystem-3.jpg","modified":1},{"_id":"source/img/docker-filesystem-2.png","path":"img/docker-filesystem-2.png","modified":1},{"_id":"source/img/docker-filesystem-10.png","path":"img/docker-filesystem-10.png","modified":1},{"_id":"source/img/docker-filesystem-1.png","path":"img/docker-filesystem-1.png","modified":1},{"_id":"source/img/avatar@2X.png","path":"img/avatar@2X.png","modified":1},{"_id":"source/img/avatar.png","path":"img/avatar.png","modified":1},{"_id":"source/img/Shunting-Yard.png","path":"img/Shunting-Yard.png","modified":1}],"Cache":[{"_id":"source/CNAME","shasum":"7aff6510aa5ea9fff0964c817af55563a3cc6cd7","modified":1413772466000},{"_id":"source/_posts/2014-08-04-ubuntu-rsyslog.md","shasum":"6546d4a55b14556403d94ae71845063d88ef8be9","modified":1430392711000},{"_id":"source/_posts/2014-08-06-brute_search_and_KMP.md","shasum":"07cbbf0b505c8067e26314227edc6398e0d64d11","modified":1430393061000},{"_id":"source/_posts/2014-08-11-trie.md","shasum":"572160c754c77a696577410e72dd57a2f3a64adf","modified":1430394402000},{"_id":"source/_posts/2014-08-12-undirected-graph.md","shasum":"e18fb2b8b7a14d886dc381dd07b7d499da020761","modified":1430392853000},{"_id":"source/_posts/2014-08-28-sorting.md","shasum":"18b42c087a9a1523f9bba4c3f932d16d14c3dc12","modified":1443612694000},{"_id":"source/_posts/2014-08-29-heap-sort.md","shasum":"31e304f159ff9f92f60a444771366a25db003913","modified":1430394475000},{"_id":"source/_posts/2014-09-23-leetcode-climbing-stairs.md","shasum":"3f8cdce6ac1570f217192275697ff6cfa34e28a3","modified":1430747013000},{"_id":"source/_posts/2014-09-23-leetcode-word-break.md","shasum":"97ae0fcc037747236ce4877495961bdbd127eeea","modified":1443612635000},{"_id":"source/_posts/2014-09-24-2301.md","shasum":"59992cbee6c9b636d50a37de63903ef9c300d141","modified":1430394194000},{"_id":"source/_posts/2014-09-24-leetcode-decode-ways.md","shasum":"c2c6a7e1714330e6cf090884b1c0f1435820dc9a","modified":1430747025000},{"_id":"source/_posts/2014-09-25-leetcode-distinct-subsequences.md","shasum":"2d53a6b3a1ddb1a35f5df9ae72328f4fd8de333c","modified":1430747037000},{"_id":"source/_posts/2014-09-26-leetcode-edit-distance.md","shasum":"584762df456e58a41e8beb080225e4c65a6346da","modified":1430747045000},{"_id":"source/_posts/2014-10-11-poj-2431-Expedition.md","shasum":"d7f819231e1b05167e6b383dbae8a9f893fbde89","modified":1430395016000},{"_id":"source/_posts/2014-10-11-poj-3253-Fence-Repair.md","shasum":"088cdffa9a025f4ac1035d84f2a76b239c941a3a","modified":1430394716000},{"_id":"source/_posts/2014-10-11-set-and-map.md","shasum":"863aa8d2eceed8c250441f0b6b59238fbb3e450c","modified":1430395105000},{"_id":"source/_posts/2014-10-11-std-sort-function.md","shasum":"d4d2180e72bb44284e017258e8c75a1d5acefaad","modified":1430395121000},{"_id":"source/_posts/2014-10-11-stl-priority-queue.md","shasum":"4cb3db6e55d0d2a8873c84e3fb4282239d0c1c18","modified":1430395471000},{"_id":"source/_posts/2014-10-13-c-function-pointer.md","shasum":"11afcf69afb24fa6981ca15a41b8473a49b0e7c5","modified":1430395694000},{"_id":"source/_posts/2014-10-14-bipartite-graph.md","shasum":"b49e86204d1be81921ba181bfce1a00a1e0c389d","modified":1430395316000},{"_id":"source/_posts/2014-10-16-binary-search-tree.md","shasum":"1414716fc7999d08db26b57b81b91367f24886d2","modified":1430747337000},{"_id":"source/_posts/2014-10-16-stl-iterator-pointer.md","shasum":"174ace68f439fc0815b84e2bc1ad45304f2d06a8","modified":1430395422000},{"_id":"source/_posts/2014-10-20-Polish-notation.md","shasum":"4f95af262ac7f48bb446a805f372c1b668c85a55","modified":1433858549000},{"_id":"source/_posts/2014-10-23-Topological-sorting.md","shasum":"cd4a260c372202050d7f21b297f46a70366f1fce","modified":1430801850000},{"_id":"source/_posts/2014-10-23-c-traps.md","shasum":"c0bc57c76fdfdd33b4a357bc7d23930646b2d4a7","modified":1430393709000},{"_id":"source/_posts/2014-10-23-leetcode-Merge-k-Sorted-Lists.md","shasum":"bdebfc747fb7f23fe86001ebb70743e537777dbe","modified":1430395882000},{"_id":"source/_posts/2014-10-24-binary-tree-traversal.md","shasum":"1a73bb16af7897c14f9d2b6ce76b62d7cbfc83ab","modified":1430747110000},{"_id":"source/_posts/2014-10-25-prim-mst.md","shasum":"ed956668ce617a5e4ffd1d29533c33a0d3ec47b0","modified":1430801841000},{"_id":"source/_posts/2014-10-26-Balanced-Lineup.md","shasum":"89a10d7bb6f3054d419a5a2f85049f24db0252e8","modified":1430395839000},{"_id":"source/_posts/2014-10-26-kruskal.md","shasum":"e820788b2bac334dcd023c238b5c7c2074db5a33","modified":1430801822000},{"_id":"source/_posts/2014-10-26-union-find.md","shasum":"b94067753bca979fb0c9282d065c0adef6896c80","modified":1430396755000},{"_id":"source/_posts/2014-10-28-bellman-ford.md","shasum":"4885b2bcd84bd0b24bfff6c08d11da66871cddac","modified":1430396295000},{"_id":"source/_posts/2014-10-30-dag-shortest-path.md","shasum":"14fbc83c1623c1f769838a8dccdf9e82dcf35b1b","modified":1430396282000},{"_id":"source/_posts/2014-10-30-throw-disks.md","shasum":"5cbe99f5bc6fd57efe6752836b89dfa18f445438","modified":1430396265000},{"_id":"source/_posts/2014-11-07-linux-virtual-network.md","shasum":"3d7c34bf852359d4602f659aec4d1aa1aa90a9ba","modified":1430743636000},{"_id":"source/_posts/2014-11-1-leetcode-Clone-Graph.md","shasum":"1595a686dcbf6070f08571a5d06dc00a8509b6cb","modified":1430396224000},{"_id":"source/_posts/2014-11-12-leetcode-Subsets.md","shasum":"6990eb33ce9b6a6931a6a5c8cc76134c3c17527e","modified":1430396710000},{"_id":"source/_posts/2014-11-13-dijkstra.md","shasum":"b88619d67353f4860c589ea98a8c5b6831856982","modified":1430396475000},{"_id":"source/_posts/2014-11-15-math-prime.md","shasum":"c4be5653f65ca8cdb769f040f2b1a5f43f924038","modified":1430396451000},{"_id":"source/_posts/2014-11-18-segment-tree.md","shasum":"abe9155eb0afe06601993912c7c8ac51cf916892","modified":1430399192000},{"_id":"source/_posts/2014-11-20-edmonds-karp.md","shasum":"70177b1c40bc71933b31f734edf279e158a8c541","modified":1430399312000},{"_id":"source/_posts/2014-11-20-leetcode-insert-intervals.md","shasum":"3c5c6c5bd30961188029f1059c5b0559de367e35","modified":1430399294000},{"_id":"source/_posts/2014-11-21-rebuild-binary-tree.md","shasum":"a88ca2b66b527525a16a2cf34d26a88ad18ad0b5","modified":1430747296000},{"_id":"source/_posts/2014-11-22-floyd-warshall.md","shasum":"72d8fa7aa76928ff2c991815a9594a60cbb40823","modified":1430399270000},{"_id":"source/_posts/2014-11-23-binary-search.md","shasum":"215cce6af7e1f2c23a060a71179d9f4cfa469355","modified":1430399243000},{"_id":"source/_posts/2014-11-23-upper-bound-lower-bound.md","shasum":"3db9ce61d40565eeb4ad135188ef2208e686080e","modified":1430747681000},{"_id":"source/_posts/2014-11-25-stl-iterator.md","shasum":"5a9e743d23dc836464a66d6528a9d8ef394fee67","modified":1430399764000},{"_id":"source/_posts/2014-11-26-leetcode-maximum-product-subarray.md","shasum":"9926f182abeb3760c0f362143def24d302570460","modified":1430746898000},{"_id":"source/_posts/2014-11-30-c-constant-pointer.md","shasum":"446b0846dc85b39eb2a8df7b1e681c740fa75356","modified":1430399467000},{"_id":"source/_posts/2015-01-29-cpp-fill.md","shasum":"b10b64492aec547716057f12122912908f6bd82e","modified":1430399483000},{"_id":"source/_posts/2015-03-11-go-sync.md","shasum":"e9e24f9d3cab7c1f389204055ddb5737979cab07","modified":1430399560000},{"_id":"source/_posts/2015-04-10-leetcode-Dungeon-Game.md","shasum":"2f004299f12f6385a39fd6db7cdf3f54ed392b99","modified":1430746875000},{"_id":"source/_posts/2015-04-11-bag-problem.md","shasum":"06addaa324a67070d87acd0eb80bbe6afd210fe5","modified":1430746869000},{"_id":"source/_posts/2015-04-23-Palindrome_Partitioning_II .md","shasum":"499b22030364efb118465f66cabc122cfae6b32a","modified":1430746859000},{"_id":"source/_posts/2015-04-23-leetcode-Divide-Two-Integers.md","shasum":"9e08d4113878c213227dfaaa11bb67b2e56ec815","modified":1430399648000},{"_id":"source/_posts/2015-04-27-visit-gallary.md","shasum":"3aec7f7340d31bad48a0c11183b18d01edcdbc7a","modified":1430746851000},{"_id":"source/_posts/2015-04-28-go-interface.md","shasum":"3b8d89d2c1c53a337c2f12b20dfc044cdf368da1","modified":1430400591000},{"_id":"source/_posts/2015-04-28-go-schedule.md","shasum":"0294a26df8944057b341193c40b0d3cfd7bcf744","modified":1430400537000},{"_id":"source/_posts/2015-04-28-go-sort-interface.md","shasum":"896da002ecc4087205b37c3826c3fb0ca60a9f44","modified":1430400035000},{"_id":"source/_posts/2015-04-29-ball-without-boss.md","shasum":"1d5d652597a875e4ae6e40702ddc1d605c31f0fa","modified":1430746708000},{"_id":"source/_posts/2015-04-30-chroot.md","shasum":"eed94d1def8eb2d4f62a9589044b89088a90f440","modified":1430392040000},{"_id":"source/_posts/2015-05-03-operating-system.md","shasum":"db002e1043df9f43b01307f49c06e0a062b91ee6","modified":1430628996000},{"_id":"source/_posts/2015-05-20-docker-filesystem.md","shasum":"85f40d494db0dc979808fd928b84727b155fdc5f","modified":1443613303000},{"_id":"source/_posts/2015-09-30-leetcode-add-digits.md","shasum":"01bb23a500eed5a460ebb0cd2c84a7db46f8984a","modified":1443624926000},{"_id":"source/about/index.md","shasum":"a421ccb7d75f88d68b6035418d3585429fc35e78","modified":1430404716000},{"_id":"source/img/avatar.png","shasum":"accc1da7160111cd958e5b021ee19d79b17a1dc5","modified":1411310773000},{"_id":"source/img/docker-filesystem-10.png","shasum":"57c28bdf8f13f50c3fe6b359570d3e3b307afbda","modified":1432109375000},{"_id":"source/img/docker-filesystem-3.jpg","shasum":"78eb7d9cda91c0e7304df64891a8867f15861067","modified":1432106980000},{"_id":"source/img/docker-filesystem-4.png","shasum":"01d59879d29e43b44849db178ac50427cb728c69","modified":1432107347000},{"_id":"source/img/docker-filesystem-3.png","shasum":"7be02fd02efc7fe548ef469547c3614d85ad91ae","modified":1432107187000},{"_id":"source/img/docker-filesystem-6.png","shasum":"902bd8098f3955f4135324daa696e834105a72f1","modified":1432108172000},{"_id":"source/img/golang-car.jpg","shasum":"82bdafb03ffafa0df55e9c32e3f6e1d9df085dc7","modified":1430199182000},{"_id":"source/img/gopher-bz.jpg","shasum":"161079c81b60bb3c8fbe01163ea243adb34b728b","modified":1430199196000},{"_id":"source/img/docker-filesystem-5.png","shasum":"5bc5e876ad8f1afc23f64c12872c3d34bea7795f","modified":1432107469000},{"_id":"source/img/kmp-1.png","shasum":"12c3a8754ca1401c5221f063cf38e59a8d910096","modified":1411310773000},{"_id":"source/img/sorting-1.png","shasum":"182b1554b69e51100284fe7da3f5a05123a4d9fe","modified":1411310773000},{"_id":"source/img/throw_disks_1.png","shasum":"fe9ee74dd55ecf95d8bae88d087fb500fc5dc6b9","modified":1414652820000},{"_id":"source/img/segment_tree_1.png","shasum":"05102eff3ec6393ab769a0f9fb55a10ea3aa7098","modified":1416278887000},{"_id":"source/img/throw_disks_2.png","shasum":"f29360820674f2da498345a9dc483543b3d531e7","modified":1414652860000},{"_id":"source/img/trie-3.png","shasum":"69fd707b61897a4f4b136c44aa45660ef09c24da","modified":1411310773000},{"_id":"source/img/union_find_2.png","shasum":"33b7db899fa7c4520e012ffe8aadf519cbf4a994","modified":1414306272000},{"_id":"source/img/union_find_4.png","shasum":"d2ad83f0801b3d7c460bc63f8160c256eb770e64","modified":1414306333000},{"_id":"source/img/union_find_3.png","shasum":"3bfeda3e0c48f9c33afd7127d9e2a647668eaada","modified":1414306300000},{"_id":"source/img/visit_gallary.jpg","shasum":"c5984d2163b79046ec91b616dcc7747c5976c6ed","modified":1430143369000},{"_id":"source/img/virtual_network.png","shasum":"909703f5baa251eceab7c9e0aa8bde8b582d13ea","modified":1415669641000},{"_id":"source/tags/index.md","shasum":"5019b9a96394995ea4b9e47a8b9d415efd33056e","modified":1430390210000},{"_id":"source/img/trie-4.png","shasum":"c429ad9a1284ce0a3af2716524ce024dfacd0e50","modified":1411310773000},{"_id":"source/img/union_find_1.png","shasum":"cd12d9d9e5a578483746862e52f3b614aa3889fc","modified":1414306230000},{"_id":"source/img/docker-filesystem-1.png","shasum":"375627c238fa698efd211839ca3b6df70a3a8150","modified":1432106541000},{"_id":"source/img/avatar@2X.png","shasum":"47b7552fcb0fd555a92e66df50a19f1054895873","modified":1411310773000},{"_id":"source/img/docker-filesystem-8.png","shasum":"c802cc4d3b5ea8bb3d3854f3f6863ff5288492a9","modified":1432108658000},{"_id":"source/img/docker-filesystem-9.png","shasum":"6cba5fc814d72c05930f0f289a3f7c2abd940165","modified":1432108824000},{"_id":"source/img/floyd_1.png","shasum":"eb300180807502551d4ba70c4fbc6a296b917849","modified":1416629360000},{"_id":"source/img/heap-sort-1.png","shasum":"031eea4c4b788b3dfc26fb88f1945860c74d9ac6","modified":1411310773000},{"_id":"source/img/segment_tree_3.png","shasum":"d5517934134d6d144809d08bd0e2b8e0b908c7e3","modified":1416280164000},{"_id":"source/img/kmp-2.png","shasum":"17630cdf6be6de3ec3da5817f7a065c8d255d85b","modified":1411310773000},{"_id":"source/img/segment_tree_4.png","shasum":"8d45eee9b36d71da69d4ccdf7b9eec596e73d359","modified":1416280424000},{"_id":"source/img/segment_tree_2.png","shasum":"8e0dbbb6e04fc88fab813556ff980bb7bed0af7e","modified":1416279742000},{"_id":"source/img/trie-1.png","shasum":"e1ac64895255a53914beb4c33513bbecba2de360","modified":1411310773000},{"_id":"source/img/trie-2.png","shasum":"94444d0500c8066b57bcc25924a7eb6157aefb25","modified":1411310773000},{"_id":"source/img/docker-filesystem-2.png","shasum":"4e83433286545e63045d78e23501ed9fb1237f06","modified":1432106554000},{"_id":"source/img/edmonds_karp_1.png","shasum":"73f84ba1b693eb07afdf1350ee76ef7234c8d5ec","modified":1416467949000},{"_id":"source/img/docker-filesystem-7.png","shasum":"5984a9698233f16bcb192fd2627be580bbb1241d","modified":1432108414000},{"_id":"themes/jacman/LICENSE","shasum":"931516aa36c53eb7843c83d82662eb50cc3c4367","modified":1430387763000},{"_id":"themes/jacman/README.md","shasum":"38698c732ca2c0fa48de89cfee9859bc09e74fd4","modified":1430387763000},{"_id":"themes/jacman/README_zh.md","shasum":"ee9eeb2b72e5597a3550d59d231f443d990d3115","modified":1430387763000},{"_id":"themes/jacman/_config.yml","shasum":"faf61c554463dc31fea8167b8703dc3f54419eff","modified":1430659588000},{"_id":"themes/jacman/languages/default-1.yml","shasum":"ad0de3e82c7fc238cc067ffc37359b1420aef6b3","modified":1430388804000},{"_id":"themes/jacman/languages/default.yml","shasum":"5e4ac19d7b2bbf0d5b5aa55d33653380abda8b9a","modified":1430388813000},{"_id":"themes/jacman/languages/zh-CN.yml","shasum":"5e4ac19d7b2bbf0d5b5aa55d33653380abda8b9a","modified":1430387763000},{"_id":"themes/jacman/languages/zh-TW.yml","shasum":"41c112162d79b4d3f97b417c7cd6ca6d70419ef2","modified":1430387763000},{"_id":"themes/jacman/layout/_partial/after_footer.ejs","shasum":"07b52001fb612d67cfc2d60f982a4e838cdf0c17","modified":1430387763000},{"_id":"themes/jacman/layout/_partial/analytics.ejs","shasum":"fd004beb8d4500afd5fb3b3871a95afa2a375f16","modified":1430387763000},{"_id":"themes/jacman/layout/_partial/archive.ejs","shasum":"2c7395e7563fe016521712a645c28a13f952d52a","modified":1430387763000},{"_id":"themes/jacman/layout/_partial/article.ejs","shasum":"261ecacb8456f4cb972632b6a9103860fa63b9a3","modified":1430387763000},{"_id":"themes/jacman/layout/_partial/article_row.ejs","shasum":"4cb855d91ece7f67b2ca0992fffa55472d0b9c93","modified":1430387763000},{"_id":"themes/jacman/layout/_partial/categories.ejs","shasum":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1430387763000},{"_id":"themes/jacman/layout/_partial/footer.ejs","shasum":"7a7eaa64ac5139c4c418844aa35076271cd4365d","modified":1430387763000},{"_id":"themes/jacman/layout/_partial/head.ejs","shasum":"761941be4922cd3c177c8130296b909bf7db5c09","modified":1430387763000},{"_id":"themes/jacman/layout/_partial/header.ejs","shasum":"18515612344ff048b9372b91b7eef6f3b143801f","modified":1430387763000},{"_id":"themes/jacman/layout/_partial/math-jax.ejs","shasum":"cee3f094a1f454765be308d8ad86524cdc5b71a0","modified":1426954559000},{"_id":"themes/jacman/layout/_partial/mathjax.ejs","shasum":"d42994ac696f52ba99c1cbac382cd76d5b04a3e8","modified":1430387763000},{"_id":"themes/jacman/layout/_partial/pagination.ejs","shasum":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1430387763000},{"_id":"themes/jacman/layout/_partial/post/article.ejs","shasum":"b09e3acea7076e1f01dfe0c2295e19951ea09437","modified":1430387763000},{"_id":"themes/jacman/layout/_partial/post/catetags.ejs","shasum":"0e37bababc8f4659f5b59a552a946b46d89e4158","modified":1430387763000},{"_id":"themes/jacman/layout/_partial/post/comment.ejs","shasum":"c88bc8f5805173920a5fdd7e9234a850e3d8e151","modified":1430387763000},{"_id":"themes/jacman/layout/_partial/post/footer.ejs","shasum":"b12ec08a5845a3d8c01257614f1dfead879c87d2","modified":1430387763000},{"_id":"themes/jacman/layout/_partial/post/gallery.ejs","shasum":"fafc2501d7e65983b0f5c2b58151ca12e57c0574","modified":1430387763000},{"_id":"themes/jacman/layout/_partial/post/header.ejs","shasum":"36a705942b691abe0d643ea8afa339981b32f6f2","modified":1430387763000},{"_id":"themes/jacman/layout/_partial/post/jiathis.ejs","shasum":"d7f5960039ac74924559ab6ba03c64457b8f0966","modified":1430387763000},{"_id":"themes/jacman/layout/_partial/post/pagination.ejs","shasum":"7de9c07a4c968429a8088c31a28b7f3a993ded1b","modified":1430387763000},{"_id":"themes/jacman/layout/_partial/search.ejs","shasum":"1083824a6c6c3df02767f2f3b727aee78ebb76ec","modified":1430387763000},{"_id":"themes/jacman/layout/_partial/tinysou_search.ejs","shasum":"06ecddc8a9d40b480fe2e958af1dab857a9d5441","modified":1430387763000},{"_id":"themes/jacman/layout/_partial/sidebar.ejs","shasum":"c4f527fff0070fbe65919053a16224412317f40d","modified":1430387763000},{"_id":"themes/jacman/layout/_partial/tags.ejs","shasum":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1430387763000},{"_id":"themes/jacman/layout/_partial/totop.ejs","shasum":"bea5bb7cb9350b8af7d97a8d223af63a5b30ab78","modified":1430387763000},{"_id":"themes/jacman/layout/_widget/archive.ejs","shasum":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1430387763000},{"_id":"themes/jacman/layout/_widget/category.ejs","shasum":"c1fae96b5053da021bcc04ab2ce5c2c8d30de8a2","modified":1430387763000},{"_id":"themes/jacman/layout/_widget/douban.ejs","shasum":"94ce1fb7a1143f34ac1365924b00cae64e1a111e","modified":1430387763000},{"_id":"themes/jacman/layout/_widget/links.ejs","shasum":"e49868063439c2092cdf9a8ec82cc295b0e42f66","modified":1430387763000},{"_id":"themes/jacman/layout/_widget/rss.ejs","shasum":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1430387763000},{"_id":"themes/jacman/layout/_widget/tag.ejs","shasum":"7e82ad9c916b9ce871b2f65ce8f283c5ba47947b","modified":1430387763000},{"_id":"themes/jacman/layout/_widget/tagcloud.ejs","shasum":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1430387763000},{"_id":"themes/jacman/layout/_widget/weibo.ejs","shasum":"a31c2b223d0feb2a227e203cac9e5d13b7d328a8","modified":1430387763000},{"_id":"themes/jacman/layout/archive.ejs","shasum":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1430387763000},{"_id":"themes/jacman/layout/category.ejs","shasum":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1430387763000},{"_id":"themes/jacman/layout/index.ejs","shasum":"75cef2172c286994af412e11ab7f4f5a0daaf1f5","modified":1430387763000},{"_id":"themes/jacman/layout/layout.ejs","shasum":"beb9b8aa118481485f26ac23fcdfce3157e4192d","modified":1430398423000},{"_id":"themes/jacman/layout/page.ejs","shasum":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1430387763000},{"_id":"themes/jacman/layout/post.ejs","shasum":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1430387763000},{"_id":"themes/jacman/layout/tag.ejs","shasum":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1430387763000},{"_id":"themes/jacman/scripts/fancybox.js","shasum":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1430387763000},{"_id":"themes/jacman/source/css/_base/code.styl","shasum":"a7fe002222bfc7a125c8fe92b26ba9dc604595a2","modified":1430387763000},{"_id":"themes/jacman/source/css/_base/font.styl","shasum":"c8a0faf43b08e37ad07a5669db76d595da966159","modified":1430387763000},{"_id":"themes/jacman/source/css/_base/public.styl","shasum":"a29e4a4fbc288323b7f3ca2e501a6609e5646e2f","modified":1430387763000},{"_id":"themes/jacman/source/css/_base/variable.styl","shasum":"cb652eb83c28a208743fabab92de896f8b7cbf7b","modified":1430387763000},{"_id":"themes/jacman/source/css/_partial/article.styl","shasum":"c69641b4a34a8c62986b335414413dbde26de25e","modified":1430387763000},{"_id":"themes/jacman/source/css/_partial/aside.styl","shasum":"6b0e46e2e3be200339197696f5aabd0871aa9952","modified":1430387763000},{"_id":"themes/jacman/source/css/_partial/duoshuo.styl","shasum":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1430387763000},{"_id":"themes/jacman/source/css/_partial/footer.styl","shasum":"1911613a19b605a58f801c21b03b5d4c83b90f9c","modified":1430387763000},{"_id":"themes/jacman/source/css/_partial/gallery.styl","shasum":"7246809f4ce3166ec1b259bf475cae1a48e29aad","modified":1430387763000},{"_id":"themes/jacman/source/css/_partial/header.styl","shasum":"5121ceb712be3f2dde98b8b6e589b546e19eab8f","modified":1430387763000},{"_id":"themes/jacman/source/css/_partial/helper.styl","shasum":"0bf862a860c07aff5f440b5e6f040baa83031d2c","modified":1430387763000},{"_id":"themes/jacman/source/css/_partial/index.styl","shasum":"864fba1fcb3830a9055c366a99ce5c951c2e9fe9","modified":1430387763000},{"_id":"themes/jacman/source/css/_partial/totop.styl","shasum":"96363d7c5aaed5f649667fc0752a62620a67e872","modified":1430387763000},{"_id":"themes/jacman/source/css/style.styl","shasum":"89070fcce9a70c82ea5559ae8f6efc60e624c6d3","modified":1430387763000},{"_id":"themes/jacman/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1430387763000},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1430387763000},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1430387763000},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1430387763000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1430387763000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1430387763000},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1430387763000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1430387763000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1430387763000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1430387763000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1430387763000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1430387763000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1430387763000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1430387763000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1430387763000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","shasum":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1430387763000},{"_id":"themes/jacman/source/font/FontAwesome.otf","shasum":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1430387763000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","shasum":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1430387763000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","shasum":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1430387763000},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1430387763000},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","shasum":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1430387763000},{"_id":"themes/jacman/source/font/fontdiao.eot","shasum":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1430387763000},{"_id":"themes/jacman/source/font/fontdiao.ttf","shasum":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1430387763000},{"_id":"themes/jacman/source/font/fontdiao.woff","shasum":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1430387763000},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","shasum":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1430387763000},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","shasum":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1430387763000},{"_id":"themes/jacman/source/img/cc-by-nc.svg","shasum":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1430387763000},{"_id":"themes/jacman/source/img/cc-by-nd.svg","shasum":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1430387763000},{"_id":"themes/jacman/source/img/cc-by-sa.svg","shasum":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1430387763000},{"_id":"themes/jacman/source/img/cc-zero.svg","shasum":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1430387763000},{"_id":"themes/jacman/source/img/cc-by.svg","shasum":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1430387763000},{"_id":"themes/jacman/source/img/favicon.ico","shasum":"8e856b9f4cece5e785ac5349a366ac9f0985f531","modified":1430382995000},{"_id":"themes/jacman/source/img/logo.svg","shasum":"cef3f0bb4bf3661dd3a58c81b9a7be79601a0bfb","modified":1430401762000},{"_id":"themes/jacman/source/img/scrollup.png","shasum":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1430387763000},{"_id":"themes/jacman/source/js/gallery.js","shasum":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1430387763000},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","shasum":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1430387763000},{"_id":"themes/jacman/source/js/totop.js","shasum":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1430387763000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","shasum":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1430387763000},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1430387763000},{"_id":"themes/jacman/source/font/fontdiao.svg","shasum":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1430387763000},{"_id":"themes/jacman/source/img/author.png","shasum":"47b7552fcb0fd555a92e66df50a19f1054895873","modified":1411310773000},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","shasum":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1430387763000},{"_id":"source/img/Shunting-Yard.png","shasum":"eae528c3faae4ad7c76d813450d322834cd0111b","modified":1413797975000},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","shasum":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1430387763000},{"_id":"themes/jacman/source/img/banner.jpg","shasum":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1430387763000}],"Category":[{"name":"LeetCode","_id":"cif6xck0v0003rwmwirllm89u"},{"name":"docker","_id":"cif6xck0z0006rwmwphcl9us4"},{"name":"操作系统","_id":"cif6xck110009rwmwixl25zvt"},{"name":"linux","_id":"cif6xck1a000crwmwfcg4ftbv"},{"name":"problems","_id":"cif6xck1d000frwmwmdzt8rzd"},{"name":"golang","_id":"cif6xck1h000krwmwpo2w51m4"},{"name":"cpp","_id":"cif6xck200017rwmwup5tbh7q"},{"name":"algorithms","_id":"cif6xck2c001lrwmw3pqkkmro"}],"Data":[],"Page":[{"_content":"layout: tags\ntitle: tags\n___\n","source":"tags/index.md","raw":"layout: tags\ntitle: tags\n___\n","date":"2015-09-30T11:15:03.000Z","updated":"2015-04-30T10:36:50.000Z","path":"tags/index.html","title":"","comments":1,"layout":"page","_id":"cif6xck0e0000rwmw63vtehfe"},{"title":"About me","_content":"\n目前，本人就读于北京邮电大学网络技术研究院，这是我的技术博客，在将来的一段时间里，我会在这里慢慢地记录下学习过程中值得记录的东西，希望能够有个积淀\n\n合抱之木，生于毫末\n\n九层之台，起于累土\n\n千里之行，始于足下","source":"about/index.md","raw":"---\ntitle:  About me\n---\n\n目前，本人就读于北京邮电大学网络技术研究院，这是我的技术博客，在将来的一段时间里，我会在这里慢慢地记录下学习过程中值得记录的东西，希望能够有个积淀\n\n合抱之木，生于毫末\n\n九层之台，起于累土\n\n千里之行，始于足下","date":"2015-09-30T11:15:03.000Z","updated":"2015-04-30T14:38:36.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cif6xck0p0001rwmwsndw64kv"}],"Post":[{"layout":"post","title":"LeetCode: Add Digits","date":"2015-09-30T13:49:20.000Z","_content":"\n> Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\n\n> For example:\n\n> Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.\n\n此题如果用一般的方法解决，很容易，代码如下：\n\n``` cpp\nclass Solution {\npublic:\n    int addDigits(int num) {\n        while (num >= 10) {\n            int tmp = 0;\n            while (num != 0) {\n                tmp += num % 10;\n                num = num / 10;\n            }\n            num = tmp;\n        }\n        return num;\n    }\n};\n```\n\n但是题中还提到可以不用循环就可以解决，但一般这都属于一些比较技巧性的东西，见多就好，如果临时想起，必然是大神了。\n\n下面记录一下从别处看来的解法：\n\n假设输入的num是一个5位的数字，各位数分别为$a, b, c, d, e$。那么$num = (a+b+c+d+e)+(a\\times9999+b\\times999+c\\times99+d\\times9)$。\n\n然后对$a+b+c+d+e$重复进行此操作，最后将得到$num=x+y$,其中$1<=x<=9$,$y$则是一个能被9整除的表达式。我们所需要的结果就是$x$。\n\n而$x=(x-1)\\%9 + 1$,（此处是因为$x$可能为9），亦即$x=(num-1)\\%9+1$，（因为$y$能被9整除）。\n\n所以答案就更简单了：\n``` cpp\nclass Solution {\npublic:\n    int addDigits(int num) {\n        return (num - 1) % 9 + 1;\n    }\n};\n```\n\n\n\n","source":"_posts/2015-09-30-leetcode-add-digits.md","raw":"---\nlayout: post\ntitle:  \"LeetCode: Add Digits\"\ncategories: LeetCode\ndate:   2015-09-30 21:49:20\n---\n\n> Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\n\n> For example:\n\n> Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.\n\n此题如果用一般的方法解决，很容易，代码如下：\n\n``` cpp\nclass Solution {\npublic:\n    int addDigits(int num) {\n        while (num >= 10) {\n            int tmp = 0;\n            while (num != 0) {\n                tmp += num % 10;\n                num = num / 10;\n            }\n            num = tmp;\n        }\n        return num;\n    }\n};\n```\n\n但是题中还提到可以不用循环就可以解决，但一般这都属于一些比较技巧性的东西，见多就好，如果临时想起，必然是大神了。\n\n下面记录一下从别处看来的解法：\n\n假设输入的num是一个5位的数字，各位数分别为$a, b, c, d, e$。那么$num = (a+b+c+d+e)+(a\\times9999+b\\times999+c\\times99+d\\times9)$。\n\n然后对$a+b+c+d+e$重复进行此操作，最后将得到$num=x+y$,其中$1<=x<=9$,$y$则是一个能被9整除的表达式。我们所需要的结果就是$x$。\n\n而$x=(x-1)\\%9 + 1$,（此处是因为$x$可能为9），亦即$x=(num-1)\\%9+1$，（因为$y$能被9整除）。\n\n所以答案就更简单了：\n``` cpp\nclass Solution {\npublic:\n    int addDigits(int num) {\n        return (num - 1) % 9 + 1;\n    }\n};\n```\n\n\n\n","slug":"2015-09-30-leetcode-add-digits","published":1,"updated":"2015-09-30T14:55:26.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck0s0002rwmw817ikfgp"},{"layout":"post","title":"Docker文件系统","date":"2015-05-20T05:11:20.000Z","_content":"\n##Docker文件系统概述\n\n典型的Linux文件系统由bootfs和rootfs两部分组成，bootfs(boot file system)主要包含 bootloader和kernel，bootloader主要是引导加载kernel，当kernel被加载到内存中后 bootfs就被umount了。 rootfs (root file system) 包含的就是典型 Linux 系统中的/dev，/proc，/bin，/etc等标准目录和文件。\n\n![](/img/docker-filesystem-1.png)\n\n联合文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。\n\n联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。另外，不同 Docker 容器就可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。\nAufs也是一种Union FS, 支持将不同的目录挂载到同一个虚拟文件系统下，并实现一种layer的概念。Aufs将挂载到同一虚拟文件系统下的多个目录分别设置成read-only，read-write以及whiteout-able权限，对read-only目录只能读，而写操作只能实施在read-write目录中。重点在于，写操作是在read-only上的一种增量操作，不影响read-only目录。当挂载目录的时候要严格按照各目录之间的这种增量关系，将被增量操作的目录优先于在它基础上增量操作的目录挂载，待所有目录挂载结束了，继续挂载一个read-write目录，如此便形成了一种层次结构。\n\nDocker镜像的典型结构如下图。传统的Linux加载bootfs时会先将rootfs设为read-only，然后在系统自检之后将rootfs从read-only改为read-write，然后我们就可以在rootfs上进行写和读的操作了。但Docker的镜像却不是这样，它在bootfs自检完毕之后并不会把rootfs的read-only改为read-write。而是利用union mount（UnionFS的一种挂载机制）将一个或多个read-only的rootfs加载到之前的read-only的rootfs层之上。在加载了这么多层的rootfs之后，仍然让它看起来只像是一个文件系统，在Docker的体系里把union mount的这些read-only的rootfs叫做Docker的镜像。但是，此时的每一层rootfs都是read-only的，我们此时还不能对其进行操作。当我们创建一个容器，也就是将Docker镜像进行实例化，系统会在一层或是多层read-only的rootfs之上分配一层空的read-write的rootfs。\n\n![](/img/docker-filesystem-2.png)\n\nDocker 目前支持的联合文件系统种类包括 AUFS, btrfs, vfs 和 DeviceMapper。\n\n##Docker的文件系统驱动\n\nDocker定义了一个驱动原型的接口，`ProtoDriver`:\n\n``` go\ntype ProtoDriver interface {\n    String() string\n    Create(id, parent string) error\n    Remove(id string) error\n    Get(id, mountLabel string) (dir string, err error)\n    Put(id string) error\n    Exists(id string) bool\n    Status() [][2]string\n    Cleanup() error\n}\n```\n\n还定义了一个`Driver`的接口，该接口继承了`ProtoDriver`:\n``` go\ntype Driver interface {\n    ProtoDriver\n    Diff(id, parent string) (archive.Archive, error)\n    Changes(id, parent string) ([]archive.Change, error)\n    ApplyDiff(id, parent string, diff archive.ArchiveReader) (size int64, err error)\n    DiffSize(id, parent string) (size int64, err error)\n}\n```\n\nProtoDriver中定义了一些各个文件系统所需要的基本操作，比如Create,Remove等。Driver继承了ProtoDriver，并增加了几个函数，比如Diff,ApplyDiff等，这主要是为了向aufs这种有layer概念的文件系统，还有像devicemapper这种有snapshot概念的文件系统构建设备提供方便。\n像aufs直接是支持Diff,ApplyDiff等操作的，所以aufs的驱动直接实现了这个Driver这个接口。但是devicemapper并不直接支持这种操作，所以这里又定义了一个naiveDiffDriver的struct，也继承了ProtoDriver,但是又添加了Driver中多出的几个函数。这样，devicemapper等不直接支持那些操作的文件系统也可以间接得通过naiveDiffDriver实现这些功能。\n\n## Docker对文件系统的初始化\n\n![](/img/docker-filesystem-3.png)\n\n在initFunc中，会调用已经注册的文件系统驱动来进行初始化，或者如果没有注册过驱动，会按照文件系统的优先级来对文件系统进行初始化。\n例如，在支持aufs的文件系统中，就会调用aufs文件系统提供的initFunc进行初始化；在支持devicemapper的文件系统中，就会调用devicemapper的initFunc进行初始化。\n\n##关键流程\n\n###下载镜像\n\n![](/img/docker-filesystem-4.png)\n\n从上图可以看出，在下载镜像时，docker先把镜像从hub上下载下来，然后注册该镜像。注册的流程就是以该镜像的parent的设备为基础，构建一个新的设备。然后将下载下来的image所做的改动应用到新建的设备上，这样就形成了一个以该image的ID为名的设备了。其实就是一个镜像。\n\n###创建容器\n![](/img/docker-filesystem-5.png)\n\n从上图我们可以看到，在创建容器时，docker创建了两个设备，一个设备的名称为container.ID-init，简称为initID,另一个名称为container.ID。intid是根据imageId这个设备创建的，从前面下载镜像的流程中我们可以知道，只要存在image，那么imageID这个镜像也就会存在。创建完成initID后，会对该设备进行初始化操作，比如说导入一些跟容器相关的配置文件等。然后根据初始化完成的设备initID构建一个名为container.ID的设备，这个设备就是容器的设备了，将该设备挂载到相应的挂载点上，我们就可以看到创建的容器了。Docker本身也是这么做的。\n\n###创建镜像\n\n创建镜像的流程如下：\n![](/img/docker-filesystem-6.png)\n当我们使用commit命令创建一个镜像时，首先导出我们在容器中所做的修改，这个功能由函数Diff来实现。此时将要创建的image的ID为imgID,而容器所使用的镜像ID为parentId。我们首先根据parentID这个设备来新建一个名为imgID的设备。然后我们将得到的修改rwTar添加到imgID这个设备中。这样，我们就得到了一个新的镜像。\n\n##Devicemapper\n###背景介绍\n#### Snapshot\n\nSnapshot是Lvm提供的一种特性，它可以在不中断服务运行的情况下为the origin（original device）创建一个虚拟快照(Snapshot)，它具有以下几个特点：\n\n + 当the origin内容发生变化时，snapshot对变化的部分做一个拷贝以用来对the origin进行重构。\n + 因为只对变化的部分做拷贝，所以Lvm的Snapshot在读操作频繁而写操作不频繁的情况下占用很少的一部分空间便能完成特定任务。\n + 当Snapshot大小耗尽或者远大于实际需求时，我们可以对其大小进行调节。\n + 当对Snapshot的数据进行写操作的时候，Snapshot实施相应操作，并丢弃从the origin的拷贝，以后的操作以写操作之后Snapshot中的数据为准。\n + 在某些发行版的Linux系统下，可以使用lvconvert的--merge选项将Snapshot合并回the origin。\n\n\n####Thin-Provisioning\n\nThin-Provisioning是一项利用虚拟化方法减少物理存储部署的技术，可最大限度提升存储空间利用率。下图中展示了某位用户向服务器管理员请求分配10TB的资源的情形。实际情况中这个数值往往是峰值，根据使用情况，分配2TB就已足够。因此，系统管理员准备2TB的物理存储，并给服务器分配10TB的虚拟卷。服务器即可基于仅占虚拟卷容量1/5的现有物理磁盘池开始运行。这样的“始于小”方案能够实现更高效地利用存储容量。\n\n![](/img/docker-filesystem-7.png)\n\nThin-provisioning Snapshot结合Thin-Provisioning和Snapshot两种技术，允许多个虚拟设备同时挂载到一个数据卷以达到数据共享的目的。Thin-Provisioning Snapshot的特点如下：\n\n+ 可以将不同的snaptshot挂载到同一个the origin上，节省了磁盘空间。\n+ 当多个Snapshot挂载到了同一个the origin上，并在the origin上发生写操作时，将会触发COW操作。这样不会降低效率。\n+ Thin-Provisioning Snapshot支持递归操作，即一个Snapshot可以作为另一个Snapshot的the origin，且没有深度限制。\n+ 在Snapshot上可以创建一个逻辑卷，这个逻辑卷在实际写操作（COW，Snapshot写操作）发生之前是不占用磁盘空间的。\n\nThin-Provisioning Snapshot虽然有诸多优点，但是也有很多不足之处，例如大小固定等问题。\nThin-Provisioning Snapshot是作为device mapper的一个target在内核中实现的。Device mapper 是Linux 2.6内核中提供的一种从逻辑设备到物理设备的映射框架机制。在该机制下，用户可以很方便的根据自己的需要制定实现存储资源的管理策略，如条带化，镜像，快照等。\nDevice Mapper主要包含内核空间的映射和用户空间的device mapper库及dmsetup工具。Device Mapper库是对ioctl、用户空间创建删除Device Mapper逻辑设备所需必要操作的封装，dmsetup是一个提供给用户直接可用的创建删除device mapper设备的命令行工具\n\n###devicemapper概述\nDocker在初始化过程中，会在`/var/lib/docker/devicemapper/devicemapper`目录下创建一个100G的稀疏文件`data`，用于存储数据，和一个2G的稀疏文件`metadata`用于存储元数据然后分别附加到回环块设备`/dev/loop0`和`/dev/loop1`。然后基于回环块设备创建`thin pool`\n``` bash\n/dev/loop0: [64769]:135007216 (/var/lib/docker/devicemapper/devicemapper/data)\n/dev/loop1: [64769]:135007217 (/var/lib/docker/devicemapper/devicemapper/metadata)\n```\n\n在创建容器时，devicemapper会在thin pool中基于一个基础镜像新建一个默认大小为10G的设备，然后将设备的信息写入到metadata中。我们可以通过修改docker的启动参数来调整data文件和metadata文件的大小，比如将data文件的大小修改为200G，metadata文件大小修改为4G，默认设备大小修改为20G：\n```bash\ndocker -d --storage-opt dm.basesize=20G --storage-opt dm.loopdatasize=200G --storage-opt dm.loopmetadatasize=4G\n```\n当修改配置，重启docker服务时，所有的镜像，容器都会被删除，所以在重新设置时要注意做好备份。\n\n###关键流程\n\n####初始化devicemapper\n![](/img/docker-filesystem-8.png)\n初始化devicemapper时，docker会基于data文件创建一个thin pool，用于存储容器设备。然后建立一个基础镜像baseImage。如果创建设备时没有指定父设备的时候，就会以baseImage为父设备新建一个设备。\n\n####创建设备\n![](/img/docker-filesystem-9.png)\n从上可以看出，devicemapper创建设备的流程为：先根据父设备创建一个快照，生成一个新的设备，然后注册该设备，即将该设备的元数据写入metadata文件中。\n\n##AUFS\n\n###AUFS概述\nAUFS (AnotherUnionFS) 是一种 Union FS, 简单来说就是支持将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)的文件系统。 Aufs driver是docker 最早支持的driver，但是aufs只是linux内核的一个补丁集而且不太可以会被合并加入到linux内核中。但是由于aufs是唯一一个 storage driver可以实现容器间共享可执行及可共享的运行库, 所以当你跑成千上百个拥有相同程序代码或者运行库时时候，aufs是个相当不错的选择。\n\n####镜像存储\n\n在AUFS中，镜像存储的位置为`/var/lib/docker/aufs`。Aufs目录的结构如下：\n```bash\naufs/\n├── diff\n├── layers\n└── mnt\n```\n\n其中`diff`目录下存储的是镜像的具体信息；`layers`目录下存储的是镜像的继承结构,`mnt`是启动容器rootfs的挂载目录。下面分别介绍一下各个目录的具体信息。\n\n+ Layers目录\n`Layer`目录下存放的是每个镜像的继承关系文件。比如说`ubuntu:latest`镜像的imageid为`2103b00b3fdf1d26a86aded36ae73c1c425def0f779a6e69073b3b77377df348`，那么在这个目录下就会存在一个名为`2103b00b3fdf1d26a86aded36ae73c1c425def0f779a6e69073b3b77377df348`的文件，存储了镜像的继承结构，文件的内容为：\n```bash\n4faa69f72743ce3a18508e840ff84598952fc05bd1de5fd54c6bc0f8ca835884\n76b658ecb5644a4aca23b35de695803ad2e223da087d4f8015016021bd970169\nf0dde87450ec8236a64aebd3e8b499fe2772fca5e837ecbfa97bd8ae380c605e\n511136ea3c5a64f264b78b5433614aec563103b4d4702f3ba7d4d2698e22c158\n```\n\n+ Diff目录\n因为docker中，每一个镜像都是基于上一层镜像。所以在`diff`目录下，存储的是每一个镜像相对于上一层镜像所做的增量修改。如果只有`ubuntu:latest`这一个镜像，那么目录下就会存在以下几个目录：\n```bash\n2103b00b3fdf1d26a86aded36ae73c1c425def0f779a6e69073b3b77377df348\n4faa69f72743ce3a18508e840ff84598952fc05bd1de5fd54c6bc0f8ca835884\n76b658ecb5644a4aca23b35de695803ad2e223da087d4f8015016021bd970169\nf0dde87450ec8236a64aebd3e8b499fe2772fca5e837ecbfa97bd8ae380c605e\n511136ea3c5a64f264b78b5433614aec563103b4d4702f3ba7d4d2698e22c158\n```\n每一个目录下保存的即为该层镜像基于上层镜像所做的修改。\n+ mnt目录\n`mnt`是挂载文件系统的目录，比如说启动一个`ubuntu:lastest`的容器，在`mnt`下就能够看到容器id的目录，目录下是容器的rootfs.\n\n####创建容器时的文件操作\n创建一个基于`ubuntu:lastest`的容器并启动，假如容器id为`3eaa0e6ed18f949e0d0cf2ddfaa44c166063e8753676e2ec2c61ed2d2bd134f1`，我们就会发现在`diff`目录下会多出两个目录：\n```bash\n3eaa0e6ed18f949e0d0cf2ddfaa44c166063e8753676e2ec2c61ed2d2bd134f1\n3eaa0e6ed18f949e0d0cf2ddfaa44c166063e8753676e2ec2c61ed2d2bd134f1-init\n```\n\n其中`3eaa0e6ed18f949e0d0cf2ddfaa44c166063e8753676e2ec2c61ed2d2bd134f1-init`存储的是容器的初始信息，比如说一些在启动容器时需要加载的一些配置文件，比如`hosts`, `resolv.conf`等。而`3eaa0e6ed18f949e0d0cf2ddfaa44c166063e8753676e2ec2c61ed2d2bd134f1`目录下存储的是在容器中所做的修改。如果我们在容器中新建一个名为`test`的大小为`10M`的文件，那么我们会在`ec872d7343abdcf14ec900a0667363e78eaf603fee61f09ba6e6b41773f14f85`中看到该`test`文件，而`3eaa0e6ed18f949e0d0cf2ddfaa44c166063e8753676e2ec2c61ed2d2bd134f1-init`目录中不会有什么修改。\n此时，我们如果commit该容器，得到一个imageid为`ec872d7343abdcf14ec900a0667363e78eaf603fee61f09ba6e6b41773f14f85`的镜像。而diff目录下以该imageid为目录名的目录下存储的正是该`test`文件。\n\n###关键流程\n####aufs的初始化\n\nAufs在初始化Init函数中主要完成了以下几个操作：\n\n+ 调用surportsAufs函数加载Aufs模块。\n+ 调用MakePrivate在系统中为/var/lib/docker/aufs创建一个挂载点。这里的实现原理与mount --bind命令一样，只不过mount命令的源文件夹和目的文件夹一样，在系统中只创建了挂载点而已。并且这个挂载点的内容即不受源文件夹的影响也不影响源文件夹。\n+ 最后，在/var/lib/docker/aufs创建mnt， diff， layers文件夹。mnt文件夹为容器的挂载点目录，每一个容器在mnt下都有一个长ID目录，对应为该容器的rootfs的挂载点。diff有着与mnt中对应的长ID目录，这里的每个目录对应Docker 镜像的一个layer层，里面存放的是该layer相比较于父layer变化的内容。注意： 这里才是存放我们在容器中看到的内容的地方，比如/usr, /bin等等。\n\n####创建设备\n![](/img/docker-filesystem-10.png)\n从上可以看出，aufs创建设备的步骤很简单，首先是在mnt,diff目录下创建相应的目录，然后创建layers文件，里面记录的是image的层次关系。\n\n\n\n##参考文献\nhttp://www.infoq.com/cn/articles/analysis-of-docker-file-system-aufs-and-devicemapper/(大部分都是从这摘抄过来的，感谢作者写得这么细致)\n","source":"_posts/2015-05-20-docker-filesystem.md","raw":"---\nlayout: post\ntitle:  \"Docker文件系统\"\ncategories: docker\ndate:   2015-05-20 13:11:20\n---\n\n##Docker文件系统概述\n\n典型的Linux文件系统由bootfs和rootfs两部分组成，bootfs(boot file system)主要包含 bootloader和kernel，bootloader主要是引导加载kernel，当kernel被加载到内存中后 bootfs就被umount了。 rootfs (root file system) 包含的就是典型 Linux 系统中的/dev，/proc，/bin，/etc等标准目录和文件。\n\n![](/img/docker-filesystem-1.png)\n\n联合文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。\n\n联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。另外，不同 Docker 容器就可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。\nAufs也是一种Union FS, 支持将不同的目录挂载到同一个虚拟文件系统下，并实现一种layer的概念。Aufs将挂载到同一虚拟文件系统下的多个目录分别设置成read-only，read-write以及whiteout-able权限，对read-only目录只能读，而写操作只能实施在read-write目录中。重点在于，写操作是在read-only上的一种增量操作，不影响read-only目录。当挂载目录的时候要严格按照各目录之间的这种增量关系，将被增量操作的目录优先于在它基础上增量操作的目录挂载，待所有目录挂载结束了，继续挂载一个read-write目录，如此便形成了一种层次结构。\n\nDocker镜像的典型结构如下图。传统的Linux加载bootfs时会先将rootfs设为read-only，然后在系统自检之后将rootfs从read-only改为read-write，然后我们就可以在rootfs上进行写和读的操作了。但Docker的镜像却不是这样，它在bootfs自检完毕之后并不会把rootfs的read-only改为read-write。而是利用union mount（UnionFS的一种挂载机制）将一个或多个read-only的rootfs加载到之前的read-only的rootfs层之上。在加载了这么多层的rootfs之后，仍然让它看起来只像是一个文件系统，在Docker的体系里把union mount的这些read-only的rootfs叫做Docker的镜像。但是，此时的每一层rootfs都是read-only的，我们此时还不能对其进行操作。当我们创建一个容器，也就是将Docker镜像进行实例化，系统会在一层或是多层read-only的rootfs之上分配一层空的read-write的rootfs。\n\n![](/img/docker-filesystem-2.png)\n\nDocker 目前支持的联合文件系统种类包括 AUFS, btrfs, vfs 和 DeviceMapper。\n\n##Docker的文件系统驱动\n\nDocker定义了一个驱动原型的接口，`ProtoDriver`:\n\n``` go\ntype ProtoDriver interface {\n    String() string\n    Create(id, parent string) error\n    Remove(id string) error\n    Get(id, mountLabel string) (dir string, err error)\n    Put(id string) error\n    Exists(id string) bool\n    Status() [][2]string\n    Cleanup() error\n}\n```\n\n还定义了一个`Driver`的接口，该接口继承了`ProtoDriver`:\n``` go\ntype Driver interface {\n    ProtoDriver\n    Diff(id, parent string) (archive.Archive, error)\n    Changes(id, parent string) ([]archive.Change, error)\n    ApplyDiff(id, parent string, diff archive.ArchiveReader) (size int64, err error)\n    DiffSize(id, parent string) (size int64, err error)\n}\n```\n\nProtoDriver中定义了一些各个文件系统所需要的基本操作，比如Create,Remove等。Driver继承了ProtoDriver，并增加了几个函数，比如Diff,ApplyDiff等，这主要是为了向aufs这种有layer概念的文件系统，还有像devicemapper这种有snapshot概念的文件系统构建设备提供方便。\n像aufs直接是支持Diff,ApplyDiff等操作的，所以aufs的驱动直接实现了这个Driver这个接口。但是devicemapper并不直接支持这种操作，所以这里又定义了一个naiveDiffDriver的struct，也继承了ProtoDriver,但是又添加了Driver中多出的几个函数。这样，devicemapper等不直接支持那些操作的文件系统也可以间接得通过naiveDiffDriver实现这些功能。\n\n## Docker对文件系统的初始化\n\n![](/img/docker-filesystem-3.png)\n\n在initFunc中，会调用已经注册的文件系统驱动来进行初始化，或者如果没有注册过驱动，会按照文件系统的优先级来对文件系统进行初始化。\n例如，在支持aufs的文件系统中，就会调用aufs文件系统提供的initFunc进行初始化；在支持devicemapper的文件系统中，就会调用devicemapper的initFunc进行初始化。\n\n##关键流程\n\n###下载镜像\n\n![](/img/docker-filesystem-4.png)\n\n从上图可以看出，在下载镜像时，docker先把镜像从hub上下载下来，然后注册该镜像。注册的流程就是以该镜像的parent的设备为基础，构建一个新的设备。然后将下载下来的image所做的改动应用到新建的设备上，这样就形成了一个以该image的ID为名的设备了。其实就是一个镜像。\n\n###创建容器\n![](/img/docker-filesystem-5.png)\n\n从上图我们可以看到，在创建容器时，docker创建了两个设备，一个设备的名称为container.ID-init，简称为initID,另一个名称为container.ID。intid是根据imageId这个设备创建的，从前面下载镜像的流程中我们可以知道，只要存在image，那么imageID这个镜像也就会存在。创建完成initID后，会对该设备进行初始化操作，比如说导入一些跟容器相关的配置文件等。然后根据初始化完成的设备initID构建一个名为container.ID的设备，这个设备就是容器的设备了，将该设备挂载到相应的挂载点上，我们就可以看到创建的容器了。Docker本身也是这么做的。\n\n###创建镜像\n\n创建镜像的流程如下：\n![](/img/docker-filesystem-6.png)\n当我们使用commit命令创建一个镜像时，首先导出我们在容器中所做的修改，这个功能由函数Diff来实现。此时将要创建的image的ID为imgID,而容器所使用的镜像ID为parentId。我们首先根据parentID这个设备来新建一个名为imgID的设备。然后我们将得到的修改rwTar添加到imgID这个设备中。这样，我们就得到了一个新的镜像。\n\n##Devicemapper\n###背景介绍\n#### Snapshot\n\nSnapshot是Lvm提供的一种特性，它可以在不中断服务运行的情况下为the origin（original device）创建一个虚拟快照(Snapshot)，它具有以下几个特点：\n\n + 当the origin内容发生变化时，snapshot对变化的部分做一个拷贝以用来对the origin进行重构。\n + 因为只对变化的部分做拷贝，所以Lvm的Snapshot在读操作频繁而写操作不频繁的情况下占用很少的一部分空间便能完成特定任务。\n + 当Snapshot大小耗尽或者远大于实际需求时，我们可以对其大小进行调节。\n + 当对Snapshot的数据进行写操作的时候，Snapshot实施相应操作，并丢弃从the origin的拷贝，以后的操作以写操作之后Snapshot中的数据为准。\n + 在某些发行版的Linux系统下，可以使用lvconvert的--merge选项将Snapshot合并回the origin。\n\n\n####Thin-Provisioning\n\nThin-Provisioning是一项利用虚拟化方法减少物理存储部署的技术，可最大限度提升存储空间利用率。下图中展示了某位用户向服务器管理员请求分配10TB的资源的情形。实际情况中这个数值往往是峰值，根据使用情况，分配2TB就已足够。因此，系统管理员准备2TB的物理存储，并给服务器分配10TB的虚拟卷。服务器即可基于仅占虚拟卷容量1/5的现有物理磁盘池开始运行。这样的“始于小”方案能够实现更高效地利用存储容量。\n\n![](/img/docker-filesystem-7.png)\n\nThin-provisioning Snapshot结合Thin-Provisioning和Snapshot两种技术，允许多个虚拟设备同时挂载到一个数据卷以达到数据共享的目的。Thin-Provisioning Snapshot的特点如下：\n\n+ 可以将不同的snaptshot挂载到同一个the origin上，节省了磁盘空间。\n+ 当多个Snapshot挂载到了同一个the origin上，并在the origin上发生写操作时，将会触发COW操作。这样不会降低效率。\n+ Thin-Provisioning Snapshot支持递归操作，即一个Snapshot可以作为另一个Snapshot的the origin，且没有深度限制。\n+ 在Snapshot上可以创建一个逻辑卷，这个逻辑卷在实际写操作（COW，Snapshot写操作）发生之前是不占用磁盘空间的。\n\nThin-Provisioning Snapshot虽然有诸多优点，但是也有很多不足之处，例如大小固定等问题。\nThin-Provisioning Snapshot是作为device mapper的一个target在内核中实现的。Device mapper 是Linux 2.6内核中提供的一种从逻辑设备到物理设备的映射框架机制。在该机制下，用户可以很方便的根据自己的需要制定实现存储资源的管理策略，如条带化，镜像，快照等。\nDevice Mapper主要包含内核空间的映射和用户空间的device mapper库及dmsetup工具。Device Mapper库是对ioctl、用户空间创建删除Device Mapper逻辑设备所需必要操作的封装，dmsetup是一个提供给用户直接可用的创建删除device mapper设备的命令行工具\n\n###devicemapper概述\nDocker在初始化过程中，会在`/var/lib/docker/devicemapper/devicemapper`目录下创建一个100G的稀疏文件`data`，用于存储数据，和一个2G的稀疏文件`metadata`用于存储元数据然后分别附加到回环块设备`/dev/loop0`和`/dev/loop1`。然后基于回环块设备创建`thin pool`\n``` bash\n/dev/loop0: [64769]:135007216 (/var/lib/docker/devicemapper/devicemapper/data)\n/dev/loop1: [64769]:135007217 (/var/lib/docker/devicemapper/devicemapper/metadata)\n```\n\n在创建容器时，devicemapper会在thin pool中基于一个基础镜像新建一个默认大小为10G的设备，然后将设备的信息写入到metadata中。我们可以通过修改docker的启动参数来调整data文件和metadata文件的大小，比如将data文件的大小修改为200G，metadata文件大小修改为4G，默认设备大小修改为20G：\n```bash\ndocker -d --storage-opt dm.basesize=20G --storage-opt dm.loopdatasize=200G --storage-opt dm.loopmetadatasize=4G\n```\n当修改配置，重启docker服务时，所有的镜像，容器都会被删除，所以在重新设置时要注意做好备份。\n\n###关键流程\n\n####初始化devicemapper\n![](/img/docker-filesystem-8.png)\n初始化devicemapper时，docker会基于data文件创建一个thin pool，用于存储容器设备。然后建立一个基础镜像baseImage。如果创建设备时没有指定父设备的时候，就会以baseImage为父设备新建一个设备。\n\n####创建设备\n![](/img/docker-filesystem-9.png)\n从上可以看出，devicemapper创建设备的流程为：先根据父设备创建一个快照，生成一个新的设备，然后注册该设备，即将该设备的元数据写入metadata文件中。\n\n##AUFS\n\n###AUFS概述\nAUFS (AnotherUnionFS) 是一种 Union FS, 简单来说就是支持将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)的文件系统。 Aufs driver是docker 最早支持的driver，但是aufs只是linux内核的一个补丁集而且不太可以会被合并加入到linux内核中。但是由于aufs是唯一一个 storage driver可以实现容器间共享可执行及可共享的运行库, 所以当你跑成千上百个拥有相同程序代码或者运行库时时候，aufs是个相当不错的选择。\n\n####镜像存储\n\n在AUFS中，镜像存储的位置为`/var/lib/docker/aufs`。Aufs目录的结构如下：\n```bash\naufs/\n├── diff\n├── layers\n└── mnt\n```\n\n其中`diff`目录下存储的是镜像的具体信息；`layers`目录下存储的是镜像的继承结构,`mnt`是启动容器rootfs的挂载目录。下面分别介绍一下各个目录的具体信息。\n\n+ Layers目录\n`Layer`目录下存放的是每个镜像的继承关系文件。比如说`ubuntu:latest`镜像的imageid为`2103b00b3fdf1d26a86aded36ae73c1c425def0f779a6e69073b3b77377df348`，那么在这个目录下就会存在一个名为`2103b00b3fdf1d26a86aded36ae73c1c425def0f779a6e69073b3b77377df348`的文件，存储了镜像的继承结构，文件的内容为：\n```bash\n4faa69f72743ce3a18508e840ff84598952fc05bd1de5fd54c6bc0f8ca835884\n76b658ecb5644a4aca23b35de695803ad2e223da087d4f8015016021bd970169\nf0dde87450ec8236a64aebd3e8b499fe2772fca5e837ecbfa97bd8ae380c605e\n511136ea3c5a64f264b78b5433614aec563103b4d4702f3ba7d4d2698e22c158\n```\n\n+ Diff目录\n因为docker中，每一个镜像都是基于上一层镜像。所以在`diff`目录下，存储的是每一个镜像相对于上一层镜像所做的增量修改。如果只有`ubuntu:latest`这一个镜像，那么目录下就会存在以下几个目录：\n```bash\n2103b00b3fdf1d26a86aded36ae73c1c425def0f779a6e69073b3b77377df348\n4faa69f72743ce3a18508e840ff84598952fc05bd1de5fd54c6bc0f8ca835884\n76b658ecb5644a4aca23b35de695803ad2e223da087d4f8015016021bd970169\nf0dde87450ec8236a64aebd3e8b499fe2772fca5e837ecbfa97bd8ae380c605e\n511136ea3c5a64f264b78b5433614aec563103b4d4702f3ba7d4d2698e22c158\n```\n每一个目录下保存的即为该层镜像基于上层镜像所做的修改。\n+ mnt目录\n`mnt`是挂载文件系统的目录，比如说启动一个`ubuntu:lastest`的容器，在`mnt`下就能够看到容器id的目录，目录下是容器的rootfs.\n\n####创建容器时的文件操作\n创建一个基于`ubuntu:lastest`的容器并启动，假如容器id为`3eaa0e6ed18f949e0d0cf2ddfaa44c166063e8753676e2ec2c61ed2d2bd134f1`，我们就会发现在`diff`目录下会多出两个目录：\n```bash\n3eaa0e6ed18f949e0d0cf2ddfaa44c166063e8753676e2ec2c61ed2d2bd134f1\n3eaa0e6ed18f949e0d0cf2ddfaa44c166063e8753676e2ec2c61ed2d2bd134f1-init\n```\n\n其中`3eaa0e6ed18f949e0d0cf2ddfaa44c166063e8753676e2ec2c61ed2d2bd134f1-init`存储的是容器的初始信息，比如说一些在启动容器时需要加载的一些配置文件，比如`hosts`, `resolv.conf`等。而`3eaa0e6ed18f949e0d0cf2ddfaa44c166063e8753676e2ec2c61ed2d2bd134f1`目录下存储的是在容器中所做的修改。如果我们在容器中新建一个名为`test`的大小为`10M`的文件，那么我们会在`ec872d7343abdcf14ec900a0667363e78eaf603fee61f09ba6e6b41773f14f85`中看到该`test`文件，而`3eaa0e6ed18f949e0d0cf2ddfaa44c166063e8753676e2ec2c61ed2d2bd134f1-init`目录中不会有什么修改。\n此时，我们如果commit该容器，得到一个imageid为`ec872d7343abdcf14ec900a0667363e78eaf603fee61f09ba6e6b41773f14f85`的镜像。而diff目录下以该imageid为目录名的目录下存储的正是该`test`文件。\n\n###关键流程\n####aufs的初始化\n\nAufs在初始化Init函数中主要完成了以下几个操作：\n\n+ 调用surportsAufs函数加载Aufs模块。\n+ 调用MakePrivate在系统中为/var/lib/docker/aufs创建一个挂载点。这里的实现原理与mount --bind命令一样，只不过mount命令的源文件夹和目的文件夹一样，在系统中只创建了挂载点而已。并且这个挂载点的内容即不受源文件夹的影响也不影响源文件夹。\n+ 最后，在/var/lib/docker/aufs创建mnt， diff， layers文件夹。mnt文件夹为容器的挂载点目录，每一个容器在mnt下都有一个长ID目录，对应为该容器的rootfs的挂载点。diff有着与mnt中对应的长ID目录，这里的每个目录对应Docker 镜像的一个layer层，里面存放的是该layer相比较于父layer变化的内容。注意： 这里才是存放我们在容器中看到的内容的地方，比如/usr, /bin等等。\n\n####创建设备\n![](/img/docker-filesystem-10.png)\n从上可以看出，aufs创建设备的步骤很简单，首先是在mnt,diff目录下创建相应的目录，然后创建layers文件，里面记录的是image的层次关系。\n\n\n\n##参考文献\nhttp://www.infoq.com/cn/articles/analysis-of-docker-file-system-aufs-and-devicemapper/(大部分都是从这摘抄过来的，感谢作者写得这么细致)\n","slug":"2015-05-20-docker-filesystem","published":1,"updated":"2015-09-30T11:41:43.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck0y0005rwmwti07owir"},{"layout":"post","title":"操作系统的一些笔记","date":"2015-05-03T04:53:20.000Z","_content":"\n###死锁\n\n两个或多个进程无线地等待一个事件，而该时间只可能由这些等待进程之一来产生。当出现这样的状态时，这些进程就称为死锁(deadlocked)。","source":"_posts/2015-05-03-operating-system.md","raw":"---\nlayout: post\ntitle:  \"操作系统的一些笔记\"\ndate:   2015-5-3 12:53:20\ncategories:   操作系统\n---\n\n###死锁\n\n两个或多个进程无线地等待一个事件，而该时间只可能由这些等待进程之一来产生。当出现这样的状态时，这些进程就称为死锁(deadlocked)。","slug":"2015-05-03-operating-system","published":1,"updated":"2015-05-03T04:56:36.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck100008rwmwplxisvn7"},{"layout":"post","title":"chroot的使用与构建一个简单的rootfs","date":"2015-04-30T08:21:20.000Z","_content":"\n###什么是chroot\nchroot，即 change root directory (更改 root 目录)。在 linux 系统中，系统默认的目录结构都是以 `/`，即是以根 (root) 开始的。而在使用 chroot 之后，系统的目录结构将以指定的位置作为 `/` 位置。\n\n###为何使用chroot\n在经过 chroot 之后，系统读取到的目录和文件将不在是旧系统根下的而是新根下(即被指定的新的位置)的目录结构和文件，因此它带来的好处大致有以下3个：\n\n+ 增加了系统的安全性，限制了用户的权力；\n\n    在经过 chroot 之后，在新根下将访问不到旧系统的根目录结构和文件，这样就增强了系统的安全性。这个一般是在登录 (login) 前使用 chroot，以此达到用户不能访问一些特定的文件。\n\n+ 建立一个与原系统隔离的系统目录结构，方便用户的开发；\n\n    使用 chroot 后，系统读取的是新根下的目录和文件，这是一个与原系统根下文件不相关的目录结构。在这个新的环境中，可以用来测试软件的静态编译以及一些与系统不相关的独立开发。\n\n+ 切换系统的根目录位置，引导 Linux 系统启动以及急救系统等。\n\n    chroot 的作用就是切换系统的根位置，而这个作用最为明显的是在系统初始引导磁盘的处理过程中使用，从初始 RAM 磁盘 (initrd) 切换系统的根位置并执行真正的 init。另外，当系统出现一些问题时，我们也可以使用 chroot 来切换到一个临时的系统。\n\n###构建一个简单的新根目录\n\n我们首先新建一个目录\n\n``` bash\n$ mkdir rootfs\n$ mkdir bin\n```\n拷贝/bin/bash命令到bin目录下：\n\n``` bash\n$ cp /bin/bash ./bin\n```\n\n使用`ldd`命令得到所需要的动态库：\n``` bash\n$ ldd /bin/bash\n    linux-vdso.so.1 =>  (0x00007fff5f225000)\n    libtinfo.so.5 => /lib64/libtinfo.so.5 (0x00007fc515981000)\n    libdl.so.2 => /lib64/libdl.so.2 (0x00007fc51577c000)\n    libc.so.6 => /lib64/libc.so.6 (0x00007fc5153bb000)\n    /lib64/ld-linux-x86-64.so.2 (0x00007fc515bb3000)\n```\n\n然后将这些动态链接库复制到rootfs目录下。这样就可以使用`chroot`来进入这个目录下了：\n``` bash\n$ sudo chroot .\nbash-4.2# pwd\n/\n```\n我们如果再拷贝一些常用的命令以及一些目录，就可以弄成一个像模像样的rootfs了。\n\n\n","source":"_posts/2015-04-30-chroot.md","raw":"---\nlayout: post\ntitle:  \"chroot的使用与构建一个简单的rootfs\"\ncategories: linux\ndate:   2015-04-30 16:21:20\n---\n\n###什么是chroot\nchroot，即 change root directory (更改 root 目录)。在 linux 系统中，系统默认的目录结构都是以 `/`，即是以根 (root) 开始的。而在使用 chroot 之后，系统的目录结构将以指定的位置作为 `/` 位置。\n\n###为何使用chroot\n在经过 chroot 之后，系统读取到的目录和文件将不在是旧系统根下的而是新根下(即被指定的新的位置)的目录结构和文件，因此它带来的好处大致有以下3个：\n\n+ 增加了系统的安全性，限制了用户的权力；\n\n    在经过 chroot 之后，在新根下将访问不到旧系统的根目录结构和文件，这样就增强了系统的安全性。这个一般是在登录 (login) 前使用 chroot，以此达到用户不能访问一些特定的文件。\n\n+ 建立一个与原系统隔离的系统目录结构，方便用户的开发；\n\n    使用 chroot 后，系统读取的是新根下的目录和文件，这是一个与原系统根下文件不相关的目录结构。在这个新的环境中，可以用来测试软件的静态编译以及一些与系统不相关的独立开发。\n\n+ 切换系统的根目录位置，引导 Linux 系统启动以及急救系统等。\n\n    chroot 的作用就是切换系统的根位置，而这个作用最为明显的是在系统初始引导磁盘的处理过程中使用，从初始 RAM 磁盘 (initrd) 切换系统的根位置并执行真正的 init。另外，当系统出现一些问题时，我们也可以使用 chroot 来切换到一个临时的系统。\n\n###构建一个简单的新根目录\n\n我们首先新建一个目录\n\n``` bash\n$ mkdir rootfs\n$ mkdir bin\n```\n拷贝/bin/bash命令到bin目录下：\n\n``` bash\n$ cp /bin/bash ./bin\n```\n\n使用`ldd`命令得到所需要的动态库：\n``` bash\n$ ldd /bin/bash\n    linux-vdso.so.1 =>  (0x00007fff5f225000)\n    libtinfo.so.5 => /lib64/libtinfo.so.5 (0x00007fc515981000)\n    libdl.so.2 => /lib64/libdl.so.2 (0x00007fc51577c000)\n    libc.so.6 => /lib64/libc.so.6 (0x00007fc5153bb000)\n    /lib64/ld-linux-x86-64.so.2 (0x00007fc515bb3000)\n```\n\n然后将这些动态链接库复制到rootfs目录下。这样就可以使用`chroot`来进入这个目录下了：\n``` bash\n$ sudo chroot .\nbash-4.2# pwd\n/\n```\n我们如果再拷贝一些常用的命令以及一些目录，就可以弄成一个像模像样的rootfs了。\n\n\n","slug":"2015-04-30-chroot","published":1,"updated":"2015-04-30T11:07:20.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck12000brwmw7nitrwo3"},{"layout":"post","title":"动态规划: 树形dp-没有上司的舞会","date":"2015-04-29T13:16:20.000Z","_content":"\n###题目描述\n\n>Ural大学有N个职员，编号为1~N。他们有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。每个职员有一个快乐指数。现在有个周年庆宴会，要求与会职员的快乐指数最大。但是，没有职员愿和直接上司一起与会。意思是如果某人直接上司去了，那么他就不去。\n\n###输入描述\n>第一行一个整数N。(1<=N<=6000)\n>接下来N行，第i+1行表示i号职员的快乐指数Ri。(-128<=Ri<=127)\n>接下来N-1行，每行输入一对整数L,K。表示K是L的直接上司。\n>最后一行输入0,0。\n\n###输出描述\n>输出最大的快乐指数。\n\n###样例输入\n>7\n>1\n>1\n>1\n>1\n>1\n>1\n>1\n>1 3\n>2 3\n>6 4\n>7 4\n>4 5\n>3 5\n>0 0\n\n###样例输出\n>5\n\n###思路\n\n设状态f[k][0],表示k不参加舞会时最大的快乐指数，f[k][1]表示k参加舞会时的最大快乐指数\n状态转移方程如下：\n\n$f[k][0]=\\sum max \\left( f[l][0], f[l][1] \\right) $\n\n$f[k][1]=\\sum f[l][0] + happy[k] $\n\n\n树形dp的以大特点就是数据是分好几块的，相互之间并不影响，比如说处理左子树和右子树时，两边的数据是不会相互影响的，即只用到了一部分数据。而一般的dp算法都是从0-n一步一步算出来的。\n\n``` cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 6000;\n\nint n;\nvector<int> G[MAX_N + 1];\nint happy[MAX_N + 1];\nint f[MAX_N + 1][2];\nint has_boss[MAX_N + 1];\n\n\nvoid dp(int k) {\n    f[k][1] = happy[k];\n    for (int i = 0; i < G[k].size(); i++) {\n        int l = G[k][i];\n        dp(l);\n        f[k][1] += f[l][0];\n        f[k][0] += max(f[l][0], f[l][1]);\n    }\n}\n\nvoid solve() {\n    int i = 0;\n    for (i = 1; i <= n; i++) {\n        if (!has_boss[i])\n            break;\n    }\n    dp(i);\n    cout<<max(f[i][0], f[i][1])<<endl;\n}\n\nint main() {\n    cin>>n;\n    for (int i = 1; i <= n; i++) {\n        cin>>happy[i];\n    }\n    \n    int l, k;\n    for (int i = 1; i <= n - 1; i++) {\n        cin>>l>>k;\n        G[k].push_back(l);\n        has_boss[l] = 1;\n    }\n    \n    cin>>l>>k;\n    \n    solve();\n}\n```","source":"_posts/2015-04-29-ball-without-boss.md","raw":"---\nlayout: post\ntitle:  \"动态规划: 树形dp-没有上司的舞会\"\ndate:   2015-04-29 21:16:20\ncategories: problems\ntags: [动态规划]\n---\n\n###题目描述\n\n>Ural大学有N个职员，编号为1~N。他们有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。每个职员有一个快乐指数。现在有个周年庆宴会，要求与会职员的快乐指数最大。但是，没有职员愿和直接上司一起与会。意思是如果某人直接上司去了，那么他就不去。\n\n###输入描述\n>第一行一个整数N。(1<=N<=6000)\n>接下来N行，第i+1行表示i号职员的快乐指数Ri。(-128<=Ri<=127)\n>接下来N-1行，每行输入一对整数L,K。表示K是L的直接上司。\n>最后一行输入0,0。\n\n###输出描述\n>输出最大的快乐指数。\n\n###样例输入\n>7\n>1\n>1\n>1\n>1\n>1\n>1\n>1\n>1 3\n>2 3\n>6 4\n>7 4\n>4 5\n>3 5\n>0 0\n\n###样例输出\n>5\n\n###思路\n\n设状态f[k][0],表示k不参加舞会时最大的快乐指数，f[k][1]表示k参加舞会时的最大快乐指数\n状态转移方程如下：\n\n$f[k][0]=\\sum max \\left( f[l][0], f[l][1] \\right) $\n\n$f[k][1]=\\sum f[l][0] + happy[k] $\n\n\n树形dp的以大特点就是数据是分好几块的，相互之间并不影响，比如说处理左子树和右子树时，两边的数据是不会相互影响的，即只用到了一部分数据。而一般的dp算法都是从0-n一步一步算出来的。\n\n``` cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 6000;\n\nint n;\nvector<int> G[MAX_N + 1];\nint happy[MAX_N + 1];\nint f[MAX_N + 1][2];\nint has_boss[MAX_N + 1];\n\n\nvoid dp(int k) {\n    f[k][1] = happy[k];\n    for (int i = 0; i < G[k].size(); i++) {\n        int l = G[k][i];\n        dp(l);\n        f[k][1] += f[l][0];\n        f[k][0] += max(f[l][0], f[l][1]);\n    }\n}\n\nvoid solve() {\n    int i = 0;\n    for (i = 1; i <= n; i++) {\n        if (!has_boss[i])\n            break;\n    }\n    dp(i);\n    cout<<max(f[i][0], f[i][1])<<endl;\n}\n\nint main() {\n    cin>>n;\n    for (int i = 1; i <= n; i++) {\n        cin>>happy[i];\n    }\n    \n    int l, k;\n    for (int i = 1; i <= n - 1; i++) {\n        cin>>l>>k;\n        G[k].push_back(l);\n        has_boss[l] = 1;\n    }\n    \n    cin>>l>>k;\n    \n    solve();\n}\n```","slug":"2015-04-29-ball-without-boss","published":1,"updated":"2015-05-04T13:38:28.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck1c000erwmw21ekseud"},{"layout":"post","title":"golang--sort包中的Interface","date":"2015-04-28T01:56:20.000Z","_content":"\ngolang的sort包中定义了一个名为Interface的interface，还有一个Sort(Interface)的函数：\n\n``` go\ntype Interface interface {\n        // Len is the number of elements in the collection.\n        Len() int\n        // Less reports whether the element with\n        // index i should sort before the element with index j.\n        Less(i, j int) bool\n        // Swap swaps the elements with indexes i and j.\n        Swap(i, j int)\n}\n\nfunc Sort(data Interface)\n```\n\n所以，只要一个类型实现了Interface接口，都可以调用Sort函数进行排序，在某些方面用起来感觉比c++中的sort()函数要更直观一点。\n\n放一个官方的例子, ByAge实现了Interface，这样就可以根据自己规定的排序方式，来对ByAge进行排序：\n\n``` go\npackage main\n\nimport (\n        \"fmt\"\n        \"sort\"\n)\n\ntype Person struct {\n        Name string\n        Age  int\n}\n\nfunc (p Person) String() string {\n        return fmt.Sprintf(\"%s: %d\", p.Name, p.Age)\n}\n\n// ByAge implements sort.Interface for []Person based on\n// the Age field.\ntype ByAge []Person\n\nfunc (a ByAge) Len() int           { return len(a) }\nfunc (a ByAge) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\nfunc (a ByAge) Less(i, j int) bool { return a[i].Age < a[j].Age }\n\nfunc main() {\n        people := []Person{\n                {\"Bob\", 31},\n                {\"John\", 42},\n                {\"Michael\", 17},\n                {\"Jenny\", 26},\n        }\n\n        fmt.Println(people)\n        sort.Sort(ByAge(people))\n        fmt.Println(people)\n\n}\n\n```","source":"_posts/2015-04-28-go-sort-interface.md","raw":"---\nlayout: post\ntitle:  \"golang--sort包中的Interface\"\ndate:   2015-04-28 09:56:20\ncategories:   golang\n---\n\ngolang的sort包中定义了一个名为Interface的interface，还有一个Sort(Interface)的函数：\n\n``` go\ntype Interface interface {\n        // Len is the number of elements in the collection.\n        Len() int\n        // Less reports whether the element with\n        // index i should sort before the element with index j.\n        Less(i, j int) bool\n        // Swap swaps the elements with indexes i and j.\n        Swap(i, j int)\n}\n\nfunc Sort(data Interface)\n```\n\n所以，只要一个类型实现了Interface接口，都可以调用Sort函数进行排序，在某些方面用起来感觉比c++中的sort()函数要更直观一点。\n\n放一个官方的例子, ByAge实现了Interface，这样就可以根据自己规定的排序方式，来对ByAge进行排序：\n\n``` go\npackage main\n\nimport (\n        \"fmt\"\n        \"sort\"\n)\n\ntype Person struct {\n        Name string\n        Age  int\n}\n\nfunc (p Person) String() string {\n        return fmt.Sprintf(\"%s: %d\", p.Name, p.Age)\n}\n\n// ByAge implements sort.Interface for []Person based on\n// the Age field.\ntype ByAge []Person\n\nfunc (a ByAge) Len() int           { return len(a) }\nfunc (a ByAge) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\nfunc (a ByAge) Less(i, j int) bool { return a[i].Age < a[j].Age }\n\nfunc main() {\n        people := []Person{\n                {\"Bob\", 31},\n                {\"John\", 42},\n                {\"Michael\", 17},\n                {\"Jenny\", 26},\n        }\n\n        fmt.Println(people)\n        sort.Sort(ByAge(people))\n        fmt.Println(people)\n\n}\n\n```","slug":"2015-04-28-go-sort-interface","published":1,"updated":"2015-04-30T13:20:35.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck1f000jrwmwzajgxgjr"},{"layout":"post","title":"goroutine与调度器","date":"2015-04-28T05:33:20.000Z","_content":"\n> 本文为转载，原文地址：https://github.com/Unknwon/gcblog/blob/master/content/11-golang-schedule.md\n\n我们都知道 Go 语言是原生支持语言级并发的，这个并发的最小逻辑单元就是 goroutine。goroutine 就是 Go 语言提供的一种用户态线程，当然这种用户态线程是跑在内核级线程之上的。当我们创建了很多的 goroutine，并且它们都是跑在同一个内核线程之上的时候，就需要一个调度器来维护这些 goroutine，确保所有的 goroutine 都使用 cpu，并且是尽可能公平的使用 cpu 资源。\n\n这个调度器的原理以及实现值得我们去深入研究一下。支撑整个调度器的主要有 4 个重要结构，分别是 M、G、P、Sched，前三个定义在 runtime.h 中，Sched 定义在 proc.c 中。\n\nSched 结构就是调度器，它维护有存储M和G的队列以及调度器的一些状态信息等。\nM 代表内核级线程，一个M就是一个线程，goroutine 就是跑在 M 之上的；M是一个很大的结构，里面维护小对象内存 cache（mcache）、当前执行的 goroutine、随机数发生器等等非常多的信息。\nP 全称是 Processor，处理器，它的主要用途就是用来执行 goroutine 的，所以它也维护了一个 goroutine 队列，里面存储了所有需要它来执行的 goroutine，这个P的角色可能有一点让人迷惑，一开始容易和 M 冲突，后面重点聊一下它们的关系。\nG 就是 goroutine 实现的核心结构了，G 维护了 goroutine 需要的栈、程序计数器以及它所在的 M 等信息。\n理解 M、P、G 三者的关系对理解整个调度器非常重要，我从网络上找了一个图来说明其三者关系：\n\n![](/img/golang-car.jpg)\n\n地鼠(gopher)用小车运着一堆待加工的砖。M 就可以看作图中的地鼠，P 就是小车，G 就是小车里装的砖。一图胜千言啊，弄清楚了它们三者的关系，下面我们就开始重点聊地鼠是如何在搬运砖块的。\n\n\n### 启动过程\n\n在关心绝大多数程序的内部原理的时候，我们都试图去弄明白其启动初始化过程，弄明白这个过程对后续的深入分析至关重要。在 asm_amd64.s 文件中的汇编代码 _rt0_amd64 就是整个启动过程，核心过程如下：\n\n    CALL    runtime·args(SB)\n    CALL    runtime·osinit(SB)\n    CALL    runtime·hashinit(SB)\n    CALL    runtime·schedinit(SB)\n\n    // create a new goroutine to start program\n    PUSHQ   $runtime·main·f(SB)     // entry\n    PUSHQ   $0          // arg size\n    CALL    runtime·newproc(SB)\n    POPQ    AX\n    POPQ    AX\n\n    // start this M\n    CALL    runtime·mstart(SB)\n\n\n启动过程做了调度器初始化 runtime·schedinit 后，调用 runtime·newproc 创建出第一个 goroutine，这个 goroutine 将执行的函数是 runtime·main，这第一个 goroutine 也就是所谓的主 goroutine。我们写的最简单的 Go 程序 ”hello，world” 就是完全跑在这个 goroutine 里，当然任何一个 Go 程序的入口都是从这个 goroutine 开始的。最后调用的 runtime·mstart 就是真正的执行上一步创建的主 goroutine。\n\n启动过程中的调度器初始化 runtime·schedinit 函数主要根据用户设置的 GOMAXPROCS 值来创建一批小车(P)，不管 GOMAXPROCS 设置为多大，最多也只能创建 256 个小车(P)。这些小车(p)初始创建好后都是闲置状态，也就是还没开始使用，所以它们都放置在调度器结构(Sched)的 pidle 字段维护的链表中存储起来了，以备后续之需。\n\n查看 runtime·main 函数可以了解到主 goroutine 开始执行后，做的第一件事情是创建了一个新的内核线程(地鼠 M)，不过这个线程是一个特殊线程，它在整个运行期专门负责做特定的事情——系统监控(sysmon)。接下来就是进入 Go 程序的 main 函数开始 Go 程序的执行。\n\n至此，Go 程序就被启动起来开始运行了。一个真正干活的 Go 程序，一定创建有不少的 goroutine，所以在 Go 程序开始运行后，就会向调度器添加 goroutine，调度器就要负责维护好这些 goroutine 的正常执行。\n\n### 创建 goroutine(G)\n\n在Go程序中，时常会有类似代码：\n\n    go do_something()\n    \ngo 关键字就是用来创建一个 goroutine 的，后面的函数就是这个 goroutine 需要执行的代码逻辑。go 关键字对应到调度器的接口就是 runtime·newproc。`runtime·newproc` 干的事情很简单，就负责制造一块砖(G)，然后将这块砖(G)放入当前这个地鼠(M)的小车(P)中。\n\n每个新的 goroutine 都需要有一个自己的栈，G结构的 `sched` 字段维护了栈地址以及程序计数器等信息，这是最基本的调度信息，也就是说这个 goroutine 放弃 cpu 的时候需要保存这些信息，待下次重新获得 cpu 的时候，需要将这些信息装载到对应的 cpu 寄存器中。\n\n假设这个时候已经创建了大量的 goroutne，就轮到调度器去维护这些 goroutine 了。\n\n### 创建内核线程(M)\n\n![](/img/golang-car.jpg)\n\nGo 程序中没有语言级的关键字让你去创建一个内核线程，你只能创建 goroutine，内核线程只能由 runtime 根据实际情况去创建。runtime 什么时候创建线程？以地鼠运砖图来讲，砖(G)太多了，地鼠(M)又太少了，实在忙不过来，刚好还有空闲的小车(P)没有使用，那就从别处再借些地鼠(M)过来直到把小车(p)用完为止。这里有一个地鼠(M)不够用，从别处借地鼠(M)的过程，这个过程就是创建一个内核线程(M)。创建M的接口函数是:\n\n    void newm(void (*fn)(void), P *p)\n\nnewm 函数的核心行为就是调用 clone 系统调用创建一个内核线程，每个内核线程的开始执行位置都是 runtime·mstart 函数。参数 p 就是一辆空闲的小车(p)。\n\n每个创建好的内核线程都从 runtime·mstart 函数开始执行了，它们将用分配给自己小车去搬砖了。\n\n### 调度核心\n\nnewm 接口只是给新创建的M分配了一个空闲的 P，也就是相当于告诉借来的地鼠(M)——“接下来的日子，你将使用 1 号小车搬砖，记住是 1 号小车；待会自己到停车场拿车。”，地鼠(M)去拿小车(P)这个过程就是 `acquirep`。 runtime·mstart 在进入 `schedule` 之前会给当前 M 装配上 P，runtime·mstart 函数中的代码：\n\n    \n    } else if(m != &runtime·m0) {\n        acquirep(m->nextp);\n        m->nextp = nil;\n    }\n    schedule();\n    \n\nif 分支的内容就是为当前 M 装配上 P，`nextp` 就是 newm 分配的空闲小车(P)，只是到这个时候才真正拿到手罢了。没有 P，M 是无法执行 goroutine 的，就像地鼠没有小车无法运砖一样的道理。对应 acquirep 的动作是 releasep，把 M 装配的 P 给载掉；活干完了，地鼠需要休息了，就把小车还到停车场，然后睡觉去。\n\n地鼠(M)拿到属于自己的小车(P)后，就进入工场开始干活了，也就是上面的 `schedule` 调用。简化 schedule 的代码如下：\n\n    static void\n    schedule(void)\n    {\n        G *gp;\n\n        gp = runqget(m->p);\n        if(gp == nil)\n            gp = findrunnable();\n\n        if (m->p->runqhead != m->p->runqtail &&\n            runtime·atomicload(&runtime·sched.nmspinning) == 0 &&\n            runtime·atomicload(&runtime·sched.npidle) > 0)  // TODO: fast atomic\n            wakep();\n\n        execute(gp);\n    }\n\nschedule 函数被我简化了太多，主要是我不喜欢贴大段大段的代码，因此只保留主干代码了。这里涉及到 4 大步逻辑：\n\n![](/img/gopher-bz.jpg)\n\n1. `runqget`, 地鼠(M)试图从自己的小车(P)取出一块砖(G)，当然结果可能失败，也就是这个地鼠的小车已经空了，没有砖了。\n2. `findrunnable`, 如果地鼠自己的小车中没有砖，那也不能闲着不干活是吧，所以地鼠就会试图跑去工场仓库取一块砖来处理；工场仓库也可能没砖啊，出现这种情况的时候，这个地鼠也没有偷懒停下干活，而是悄悄跑出去，随机盯上一个小伙伴(地鼠)，然后从它的车里试图偷一半砖到自己车里。如果多次尝试偷砖都失败了，那说明实在没有砖可搬了，这个时候地鼠就会把小车还回停车场，然后 `睡觉` 休息了。如果地鼠睡觉了，下面的过程当然都停止了，地鼠睡觉也就是线程 sleep 了。\n3. `wakep`, 到这个过程的时候，可怜的地鼠发现自己小车里有好多砖啊，自己根本处理不过来；再回头一看停车场居然有闲置的小车，立马跑到宿舍一看，你妹，居然还有小伙伴在睡觉，直接给屁股一脚，“你妹，居然还在睡觉，老子都快累死了，赶紧起来干活，分担点工作。”，小伙伴醒了，拿上自己的小车，乖乖干活去了。有时候，可怜的地鼠跑到宿舍却发现没有在睡觉的小伙伴，于是会很失望，最后只好向工场老板说——”停车场还有闲置的车啊，我快干不动了，赶紧从别的工场借个地鼠来帮忙吧。”，最后工场老板就搞来一个新的地鼠干活了。\n4. `execute`，地鼠拿着砖放入火种欢快的烧练起来。\n\n*注： “地鼠偷砖”叫 [work stealing](http://supertech.csail.mit.edu/papers/steal.pdf)，一种调度算法。*\n\n### 调度点\n\n当我们翻看 channel 的实现代码可以发现，对 channel 读写操作的时候会触发调用 runtime·park 函数。 goroutine 调用 park 后，这个 goroutine 就会被设置位 waiting 状态，放弃 cpu。被 park 的 goroutine 处于 waiting 状态，并且这个 goroutine 不在小车(P)中，如果不对其调用 runtime·ready，它是永远不会再被执行的。除了 channel 操作外，定时器中，网络 poll 等都有可能 park goroutine。\n\n除了 park 可以放弃 cpu 外，调用 runtime·gosched 函数也可以让当前 goroutine 放弃 cpu，但和 park 完全不同；gosched 是将 goroutine 设置为 runnable 状态，然后放入到调度器全局等待队列（也就是上面提到的工场仓库，这下就明白为何工场仓库会有砖块(G)了吧）。\n\n除此之外，就轮到系统调用了，有些系统调用也会触发重新调度。Go 语言完全是自己封装的系统调用，所以在封装系统调用的时候，可以做不少手脚，也就是进入系统调用的时候执行 entersyscall，退出后又执行 exitsyscall 函数。 也只有封装了 entersyscall 的系统调用才有可能触发重新调度，它将改变小车(P)的状态为 syscall。还记一开始提到的 sysmon 线程吗？这个系统监控线程会扫描所有的小车(P)，发现一个小车(P)处于了 syscall 的状态，就知道这个小车(P)遇到了 goroutine 在做系统调用，于是系统监控线程就会创建一个新的地鼠(M)去把这个处于 syscall 的小车给抢过来，开始干活，这样这个小车中的所有砖块(G)就可以绕过之前系统调用的等待了。被抢走小车的地鼠等系统调用返回后，发现自己的车没，不能继续干活了，于是只能把执行系统调用的 goroutine 放回到工场仓库，自己 `睡觉` 去了。\n\n从 goroutine 的调度点可以看出，调度器还是挺粗暴的，调度粒度有点过大，公平性也没有想想的那么好。总之，这个调度器还是比较简单的。\n\n### 现场处理\n\ngoroutine 在 cpu 上换入换出，不断上下文切换的时候，必须要保证的事情就是 `保存现场` 和 `恢复现场`，保存现场就是在 goroutine 放弃 cpu 的时候，将相关寄存器的值给保存到内存中；恢复现场就是在 goroutine 重新获得 cpu 的时候，需要从内存把之前的寄存器信息全部放回到相应寄存器中去。\n\ngoroutine 在主动放弃 cpu 的时候(park/gosched)，都会涉及到调用 runtime·mcall 函数，此函数也是汇编实现，主要将 goroutine 的栈地址和程序计数器保存到 G 结构的 `sched` 字段中，mcall 就完成了现场保存。恢复现场的函数是 runtime·gogocall，这个函数主要在 `execute` 中调用，就是在执行 goroutine 前，需要重新装载相应的寄存器。","source":"_posts/2015-04-28-go-schedule.md","raw":"---\nlayout: post\ntitle:  \"goroutine与调度器\"\ndate:   2015-04-28 13:33:20\ncategories:   golang\n---\n\n> 本文为转载，原文地址：https://github.com/Unknwon/gcblog/blob/master/content/11-golang-schedule.md\n\n我们都知道 Go 语言是原生支持语言级并发的，这个并发的最小逻辑单元就是 goroutine。goroutine 就是 Go 语言提供的一种用户态线程，当然这种用户态线程是跑在内核级线程之上的。当我们创建了很多的 goroutine，并且它们都是跑在同一个内核线程之上的时候，就需要一个调度器来维护这些 goroutine，确保所有的 goroutine 都使用 cpu，并且是尽可能公平的使用 cpu 资源。\n\n这个调度器的原理以及实现值得我们去深入研究一下。支撑整个调度器的主要有 4 个重要结构，分别是 M、G、P、Sched，前三个定义在 runtime.h 中，Sched 定义在 proc.c 中。\n\nSched 结构就是调度器，它维护有存储M和G的队列以及调度器的一些状态信息等。\nM 代表内核级线程，一个M就是一个线程，goroutine 就是跑在 M 之上的；M是一个很大的结构，里面维护小对象内存 cache（mcache）、当前执行的 goroutine、随机数发生器等等非常多的信息。\nP 全称是 Processor，处理器，它的主要用途就是用来执行 goroutine 的，所以它也维护了一个 goroutine 队列，里面存储了所有需要它来执行的 goroutine，这个P的角色可能有一点让人迷惑，一开始容易和 M 冲突，后面重点聊一下它们的关系。\nG 就是 goroutine 实现的核心结构了，G 维护了 goroutine 需要的栈、程序计数器以及它所在的 M 等信息。\n理解 M、P、G 三者的关系对理解整个调度器非常重要，我从网络上找了一个图来说明其三者关系：\n\n![](/img/golang-car.jpg)\n\n地鼠(gopher)用小车运着一堆待加工的砖。M 就可以看作图中的地鼠，P 就是小车，G 就是小车里装的砖。一图胜千言啊，弄清楚了它们三者的关系，下面我们就开始重点聊地鼠是如何在搬运砖块的。\n\n\n### 启动过程\n\n在关心绝大多数程序的内部原理的时候，我们都试图去弄明白其启动初始化过程，弄明白这个过程对后续的深入分析至关重要。在 asm_amd64.s 文件中的汇编代码 _rt0_amd64 就是整个启动过程，核心过程如下：\n\n    CALL    runtime·args(SB)\n    CALL    runtime·osinit(SB)\n    CALL    runtime·hashinit(SB)\n    CALL    runtime·schedinit(SB)\n\n    // create a new goroutine to start program\n    PUSHQ   $runtime·main·f(SB)     // entry\n    PUSHQ   $0          // arg size\n    CALL    runtime·newproc(SB)\n    POPQ    AX\n    POPQ    AX\n\n    // start this M\n    CALL    runtime·mstart(SB)\n\n\n启动过程做了调度器初始化 runtime·schedinit 后，调用 runtime·newproc 创建出第一个 goroutine，这个 goroutine 将执行的函数是 runtime·main，这第一个 goroutine 也就是所谓的主 goroutine。我们写的最简单的 Go 程序 ”hello，world” 就是完全跑在这个 goroutine 里，当然任何一个 Go 程序的入口都是从这个 goroutine 开始的。最后调用的 runtime·mstart 就是真正的执行上一步创建的主 goroutine。\n\n启动过程中的调度器初始化 runtime·schedinit 函数主要根据用户设置的 GOMAXPROCS 值来创建一批小车(P)，不管 GOMAXPROCS 设置为多大，最多也只能创建 256 个小车(P)。这些小车(p)初始创建好后都是闲置状态，也就是还没开始使用，所以它们都放置在调度器结构(Sched)的 pidle 字段维护的链表中存储起来了，以备后续之需。\n\n查看 runtime·main 函数可以了解到主 goroutine 开始执行后，做的第一件事情是创建了一个新的内核线程(地鼠 M)，不过这个线程是一个特殊线程，它在整个运行期专门负责做特定的事情——系统监控(sysmon)。接下来就是进入 Go 程序的 main 函数开始 Go 程序的执行。\n\n至此，Go 程序就被启动起来开始运行了。一个真正干活的 Go 程序，一定创建有不少的 goroutine，所以在 Go 程序开始运行后，就会向调度器添加 goroutine，调度器就要负责维护好这些 goroutine 的正常执行。\n\n### 创建 goroutine(G)\n\n在Go程序中，时常会有类似代码：\n\n    go do_something()\n    \ngo 关键字就是用来创建一个 goroutine 的，后面的函数就是这个 goroutine 需要执行的代码逻辑。go 关键字对应到调度器的接口就是 runtime·newproc。`runtime·newproc` 干的事情很简单，就负责制造一块砖(G)，然后将这块砖(G)放入当前这个地鼠(M)的小车(P)中。\n\n每个新的 goroutine 都需要有一个自己的栈，G结构的 `sched` 字段维护了栈地址以及程序计数器等信息，这是最基本的调度信息，也就是说这个 goroutine 放弃 cpu 的时候需要保存这些信息，待下次重新获得 cpu 的时候，需要将这些信息装载到对应的 cpu 寄存器中。\n\n假设这个时候已经创建了大量的 goroutne，就轮到调度器去维护这些 goroutine 了。\n\n### 创建内核线程(M)\n\n![](/img/golang-car.jpg)\n\nGo 程序中没有语言级的关键字让你去创建一个内核线程，你只能创建 goroutine，内核线程只能由 runtime 根据实际情况去创建。runtime 什么时候创建线程？以地鼠运砖图来讲，砖(G)太多了，地鼠(M)又太少了，实在忙不过来，刚好还有空闲的小车(P)没有使用，那就从别处再借些地鼠(M)过来直到把小车(p)用完为止。这里有一个地鼠(M)不够用，从别处借地鼠(M)的过程，这个过程就是创建一个内核线程(M)。创建M的接口函数是:\n\n    void newm(void (*fn)(void), P *p)\n\nnewm 函数的核心行为就是调用 clone 系统调用创建一个内核线程，每个内核线程的开始执行位置都是 runtime·mstart 函数。参数 p 就是一辆空闲的小车(p)。\n\n每个创建好的内核线程都从 runtime·mstart 函数开始执行了，它们将用分配给自己小车去搬砖了。\n\n### 调度核心\n\nnewm 接口只是给新创建的M分配了一个空闲的 P，也就是相当于告诉借来的地鼠(M)——“接下来的日子，你将使用 1 号小车搬砖，记住是 1 号小车；待会自己到停车场拿车。”，地鼠(M)去拿小车(P)这个过程就是 `acquirep`。 runtime·mstart 在进入 `schedule` 之前会给当前 M 装配上 P，runtime·mstart 函数中的代码：\n\n    \n    } else if(m != &runtime·m0) {\n        acquirep(m->nextp);\n        m->nextp = nil;\n    }\n    schedule();\n    \n\nif 分支的内容就是为当前 M 装配上 P，`nextp` 就是 newm 分配的空闲小车(P)，只是到这个时候才真正拿到手罢了。没有 P，M 是无法执行 goroutine 的，就像地鼠没有小车无法运砖一样的道理。对应 acquirep 的动作是 releasep，把 M 装配的 P 给载掉；活干完了，地鼠需要休息了，就把小车还到停车场，然后睡觉去。\n\n地鼠(M)拿到属于自己的小车(P)后，就进入工场开始干活了，也就是上面的 `schedule` 调用。简化 schedule 的代码如下：\n\n    static void\n    schedule(void)\n    {\n        G *gp;\n\n        gp = runqget(m->p);\n        if(gp == nil)\n            gp = findrunnable();\n\n        if (m->p->runqhead != m->p->runqtail &&\n            runtime·atomicload(&runtime·sched.nmspinning) == 0 &&\n            runtime·atomicload(&runtime·sched.npidle) > 0)  // TODO: fast atomic\n            wakep();\n\n        execute(gp);\n    }\n\nschedule 函数被我简化了太多，主要是我不喜欢贴大段大段的代码，因此只保留主干代码了。这里涉及到 4 大步逻辑：\n\n![](/img/gopher-bz.jpg)\n\n1. `runqget`, 地鼠(M)试图从自己的小车(P)取出一块砖(G)，当然结果可能失败，也就是这个地鼠的小车已经空了，没有砖了。\n2. `findrunnable`, 如果地鼠自己的小车中没有砖，那也不能闲着不干活是吧，所以地鼠就会试图跑去工场仓库取一块砖来处理；工场仓库也可能没砖啊，出现这种情况的时候，这个地鼠也没有偷懒停下干活，而是悄悄跑出去，随机盯上一个小伙伴(地鼠)，然后从它的车里试图偷一半砖到自己车里。如果多次尝试偷砖都失败了，那说明实在没有砖可搬了，这个时候地鼠就会把小车还回停车场，然后 `睡觉` 休息了。如果地鼠睡觉了，下面的过程当然都停止了，地鼠睡觉也就是线程 sleep 了。\n3. `wakep`, 到这个过程的时候，可怜的地鼠发现自己小车里有好多砖啊，自己根本处理不过来；再回头一看停车场居然有闲置的小车，立马跑到宿舍一看，你妹，居然还有小伙伴在睡觉，直接给屁股一脚，“你妹，居然还在睡觉，老子都快累死了，赶紧起来干活，分担点工作。”，小伙伴醒了，拿上自己的小车，乖乖干活去了。有时候，可怜的地鼠跑到宿舍却发现没有在睡觉的小伙伴，于是会很失望，最后只好向工场老板说——”停车场还有闲置的车啊，我快干不动了，赶紧从别的工场借个地鼠来帮忙吧。”，最后工场老板就搞来一个新的地鼠干活了。\n4. `execute`，地鼠拿着砖放入火种欢快的烧练起来。\n\n*注： “地鼠偷砖”叫 [work stealing](http://supertech.csail.mit.edu/papers/steal.pdf)，一种调度算法。*\n\n### 调度点\n\n当我们翻看 channel 的实现代码可以发现，对 channel 读写操作的时候会触发调用 runtime·park 函数。 goroutine 调用 park 后，这个 goroutine 就会被设置位 waiting 状态，放弃 cpu。被 park 的 goroutine 处于 waiting 状态，并且这个 goroutine 不在小车(P)中，如果不对其调用 runtime·ready，它是永远不会再被执行的。除了 channel 操作外，定时器中，网络 poll 等都有可能 park goroutine。\n\n除了 park 可以放弃 cpu 外，调用 runtime·gosched 函数也可以让当前 goroutine 放弃 cpu，但和 park 完全不同；gosched 是将 goroutine 设置为 runnable 状态，然后放入到调度器全局等待队列（也就是上面提到的工场仓库，这下就明白为何工场仓库会有砖块(G)了吧）。\n\n除此之外，就轮到系统调用了，有些系统调用也会触发重新调度。Go 语言完全是自己封装的系统调用，所以在封装系统调用的时候，可以做不少手脚，也就是进入系统调用的时候执行 entersyscall，退出后又执行 exitsyscall 函数。 也只有封装了 entersyscall 的系统调用才有可能触发重新调度，它将改变小车(P)的状态为 syscall。还记一开始提到的 sysmon 线程吗？这个系统监控线程会扫描所有的小车(P)，发现一个小车(P)处于了 syscall 的状态，就知道这个小车(P)遇到了 goroutine 在做系统调用，于是系统监控线程就会创建一个新的地鼠(M)去把这个处于 syscall 的小车给抢过来，开始干活，这样这个小车中的所有砖块(G)就可以绕过之前系统调用的等待了。被抢走小车的地鼠等系统调用返回后，发现自己的车没，不能继续干活了，于是只能把执行系统调用的 goroutine 放回到工场仓库，自己 `睡觉` 去了。\n\n从 goroutine 的调度点可以看出，调度器还是挺粗暴的，调度粒度有点过大，公平性也没有想想的那么好。总之，这个调度器还是比较简单的。\n\n### 现场处理\n\ngoroutine 在 cpu 上换入换出，不断上下文切换的时候，必须要保证的事情就是 `保存现场` 和 `恢复现场`，保存现场就是在 goroutine 放弃 cpu 的时候，将相关寄存器的值给保存到内存中；恢复现场就是在 goroutine 重新获得 cpu 的时候，需要从内存把之前的寄存器信息全部放回到相应寄存器中去。\n\ngoroutine 在主动放弃 cpu 的时候(park/gosched)，都会涉及到调用 runtime·mcall 函数，此函数也是汇编实现，主要将 goroutine 的栈地址和程序计数器保存到 G 结构的 `sched` 字段中，mcall 就完成了现场保存。恢复现场的函数是 runtime·gogocall，这个函数主要在 `execute` 中调用，就是在执行 goroutine 前，需要重新装载相应的寄存器。","slug":"2015-04-28-go-schedule","published":1,"updated":"2015-04-30T13:28:57.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck1j000mrwmwogm17sra"},{"layout":"post","title":"golang中interface需要注意的一点地方","date":"2015-04-28T01:56:20.000Z","_content":"\n先看代码：\n\n``` go\npackage main\n\nimport (\n        \"fmt\"\n)\n\ntype List []int\nfunc (l List) Len() int { return len(l) }\nfunc (l *List) Append(val int) { *l = append(*l, val) }\n\ntype Appender interface {\n        Append(int)\n}\n\nfunc CountInto(a Appender, start, end int) {\n        for i := start; i <= end; i++ {\n                a.Append(i)\n        }\n}\n\ntype Lener interface {\n        Len() int\n}\n\nfunc LongEnough(l Lener) bool {\n        return l.Len()*10 > 42\n}\n\nfunc main() {\n        var lst List\n        // compiler error:\n        // cannot use lst (type List) as type Appender in function argument:\n        // List does not implement Appender (Append method requires pointer receiver)\n        // INVALID: Append has a pointer receiver\n        // CountInto(lst, 1, 10) \n\n        if LongEnough(lst) {  // VALID: Identical receiver type\n                fmt.Printf(\" - lst is long enough\")\n        }\n\n        // A pointer value\n        plst := new(List)\n        CountInto(plst, 1, 10) // VALID: Identical receiver type\n        if LongEnough(plst) {  // VALID: a *List can be dereferenced for the receiver\n                fmt.Printf(\" - plst is long enough\")  //  - plst is long enoug\n        }      \n}\n\n```\n\n在上面的例子中，`CountInto(1st, 1, 10)`这一句编译时会报错，因为List实现Appender接口时的receiver是指针类型，所以调用时也必须使用指针类型。\n\n所以interface这和struct自身的method调用时不同，interface使用时receiver的类型必须和实现时的类型完全一样，而struct调用自身的method时会自动转换类型。","source":"_posts/2015-04-28-go-interface.md","raw":"---\nlayout: post\ntitle:  \"golang中interface需要注意的一点地方\"\ndate:   2015-04-28 09:56:20\ncategories:   golang\n---\n\n先看代码：\n\n``` go\npackage main\n\nimport (\n        \"fmt\"\n)\n\ntype List []int\nfunc (l List) Len() int { return len(l) }\nfunc (l *List) Append(val int) { *l = append(*l, val) }\n\ntype Appender interface {\n        Append(int)\n}\n\nfunc CountInto(a Appender, start, end int) {\n        for i := start; i <= end; i++ {\n                a.Append(i)\n        }\n}\n\ntype Lener interface {\n        Len() int\n}\n\nfunc LongEnough(l Lener) bool {\n        return l.Len()*10 > 42\n}\n\nfunc main() {\n        var lst List\n        // compiler error:\n        // cannot use lst (type List) as type Appender in function argument:\n        // List does not implement Appender (Append method requires pointer receiver)\n        // INVALID: Append has a pointer receiver\n        // CountInto(lst, 1, 10) \n\n        if LongEnough(lst) {  // VALID: Identical receiver type\n                fmt.Printf(\" - lst is long enough\")\n        }\n\n        // A pointer value\n        plst := new(List)\n        CountInto(plst, 1, 10) // VALID: Identical receiver type\n        if LongEnough(plst) {  // VALID: a *List can be dereferenced for the receiver\n                fmt.Printf(\" - plst is long enough\")  //  - plst is long enoug\n        }      \n}\n\n```\n\n在上面的例子中，`CountInto(1st, 1, 10)`这一句编译时会报错，因为List实现Appender接口时的receiver是指针类型，所以调用时也必须使用指针类型。\n\n所以interface这和struct自身的method调用时不同，interface使用时receiver的类型必须和实现时的类型完全一样，而struct调用自身的method时会自动转换类型。","slug":"2015-04-28-go-interface","published":1,"updated":"2015-04-30T13:29:51.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck1l000orwmww6cx7cqi"},{"layout":"post","title":"动态规划: 树形dp-访问艺术馆","date":"2015-04-27T13:58:20.000Z","_content":"\n###题目描述\n\n>皮尔是一个出了名的盗画者，他经过数月的精心准备，打算到艺术馆盗画。艺术馆的结构，每条走廊要么分叉为二条走廊，要么通向一个展览室。皮尔知道每个展室里藏画的数量，并且他精确地测量了通过每条走廊的时间，由于经验老道，他拿下一副画需要5秒的时间。你的任务是设计一个程序，计算在警察赶来之前(警察到达时皮尔回到了入口也算)，他最多能偷到多少幅画。\n![trie1](/img/visit_gallary.jpg)\n\n###输入描述\n>第1行是警察赶到得时间，以s为单位。第2行描述了艺术馆得结构，是一串非负整数，成对地出现：每一对得第一个数是走过一条走廊得时间，第2个数是它末端得藏画数量；如果第2个数是0，那么说明这条走廊分叉为两条另外得走廊。数据按照深度优先得次序给出，请看样例\n\n###输出描述\n>输出偷到得画得数量\n\n###样例输入\n>60\n>7 0 8 0 3 1 14 2 10 0 12 4 6 2\n\n###样例输出\n>2\n\n``` cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 1010;\n\nint LIMIT, T[MAX_N], P[MAX_N];\n\nint n, L[MAX_N], R[MAX_N];\n\nint dp[MAX_N][MAX_N];\n\nint build_tree() {\n    n++;\n    cin>>T[n]>>P[n];\n    \n    T[n] *= 2; //进去还得出来，所以要两倍的时间\n    int now = n;\n    if (P[now] == 0) {\n        L[now] = build_tree();\n        R[now] = build_tree();\n    }\n    return now;\n}\n\nint solve(int root, int time) {\n    if (dp[root][time] != -1)\n        return dp[root][time];\n    if (time <= 0)\n        return dp[root][time] = 0;\n    \n    int ct = time - T[root];\n    if (!L[root] && !R[root]) {\n        if (P[root] * 5 <= ct)\n            return dp[root][time] = P[root];\n        else\n            return dp[root][time] = ct / 5;\n    }\n    \n    dp[root][time] = 0;\n    for (int t = 0; t <= ct; t++) {\n        int lp = solve(L[root], ct - t);\n        int rp = solve(R[root], t);\n        dp[root][time] = max(dp[root][time], lp + rp);\n    }\n    \n    return dp[root][time];\n}\n\nint main() {\n    n = 0;\n    cin>>LIMIT;\n    build_tree();\n    memset(dp, -1, sizeof(dp));\n    solve(1, LIMIT);\n    cout<<dp[1][LIMIT]<<endl;\n}\n```","source":"_posts/2015-04-27-visit-gallary.md","raw":"---\nlayout: post\ntitle:  \"动态规划: 树形dp-访问艺术馆\"\ndate:   2015-04-27 21:58:20\ncategories: problems\ntags: [动态规划]\n---\n\n###题目描述\n\n>皮尔是一个出了名的盗画者，他经过数月的精心准备，打算到艺术馆盗画。艺术馆的结构，每条走廊要么分叉为二条走廊，要么通向一个展览室。皮尔知道每个展室里藏画的数量，并且他精确地测量了通过每条走廊的时间，由于经验老道，他拿下一副画需要5秒的时间。你的任务是设计一个程序，计算在警察赶来之前(警察到达时皮尔回到了入口也算)，他最多能偷到多少幅画。\n![trie1](/img/visit_gallary.jpg)\n\n###输入描述\n>第1行是警察赶到得时间，以s为单位。第2行描述了艺术馆得结构，是一串非负整数，成对地出现：每一对得第一个数是走过一条走廊得时间，第2个数是它末端得藏画数量；如果第2个数是0，那么说明这条走廊分叉为两条另外得走廊。数据按照深度优先得次序给出，请看样例\n\n###输出描述\n>输出偷到得画得数量\n\n###样例输入\n>60\n>7 0 8 0 3 1 14 2 10 0 12 4 6 2\n\n###样例输出\n>2\n\n``` cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 1010;\n\nint LIMIT, T[MAX_N], P[MAX_N];\n\nint n, L[MAX_N], R[MAX_N];\n\nint dp[MAX_N][MAX_N];\n\nint build_tree() {\n    n++;\n    cin>>T[n]>>P[n];\n    \n    T[n] *= 2; //进去还得出来，所以要两倍的时间\n    int now = n;\n    if (P[now] == 0) {\n        L[now] = build_tree();\n        R[now] = build_tree();\n    }\n    return now;\n}\n\nint solve(int root, int time) {\n    if (dp[root][time] != -1)\n        return dp[root][time];\n    if (time <= 0)\n        return dp[root][time] = 0;\n    \n    int ct = time - T[root];\n    if (!L[root] && !R[root]) {\n        if (P[root] * 5 <= ct)\n            return dp[root][time] = P[root];\n        else\n            return dp[root][time] = ct / 5;\n    }\n    \n    dp[root][time] = 0;\n    for (int t = 0; t <= ct; t++) {\n        int lp = solve(L[root], ct - t);\n        int rp = solve(R[root], t);\n        dp[root][time] = max(dp[root][time], lp + rp);\n    }\n    \n    return dp[root][time];\n}\n\nint main() {\n    n = 0;\n    cin>>LIMIT;\n    build_tree();\n    memset(dp, -1, sizeof(dp));\n    solve(1, LIMIT);\n    cout<<dp[1][LIMIT]<<endl;\n}\n```","slug":"2015-04-27-visit-gallary","published":1,"updated":"2015-05-04T13:40:51.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck1o000qrwmwkudn09p5"},{"layout":"post","title":"Math: Divide Two Integers","date":"2015-04-23T01:56:20.000Z","_content":"\n>Divide two integers without using multiplication, division and mod operator.\n>\n>If it is overflow, return MAX_INT.\n\n``` cpp\n/*\n这里需要注意的就是溢出的问题，我们知道，int的范围为\n-2147483648 ~ 2147483647\n所以需要考虑的情况就是当-2147483648 / -1时，会溢出\n*/\nclass Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        long long a = dividend >= 0 ? dividend : -(long long) dividend;\n        long long b = divisor >= 0 ? divisor : -(long long) divisor;\n        \n        long long result = 0;\n        while (a >= b) {\n            long long c = b;\n            for (int i = 0; a >= c; ++i, c <<= 1) {\n                a -= c;\n                result += 1 << i;\n            }\n        }\n        \n        result = ((dividend ^ divisor) >> 31) ? -result : result;\n        \n        return result >= INT_MAX ? INT_MAX : result;\n    }\n};\n```","source":"_posts/2015-04-23-leetcode-Divide-Two-Integers.md","raw":"---\nlayout: post\ntitle:  \"Math: Divide Two Integers\"\ndate:   2015-04-23 09:56:20\ncategories: problems\n---\n\n>Divide two integers without using multiplication, division and mod operator.\n>\n>If it is overflow, return MAX_INT.\n\n``` cpp\n/*\n这里需要注意的就是溢出的问题，我们知道，int的范围为\n-2147483648 ~ 2147483647\n所以需要考虑的情况就是当-2147483648 / -1时，会溢出\n*/\nclass Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        long long a = dividend >= 0 ? dividend : -(long long) dividend;\n        long long b = divisor >= 0 ? divisor : -(long long) divisor;\n        \n        long long result = 0;\n        while (a >= b) {\n            long long c = b;\n            for (int i = 0; a >= c; ++i, c <<= 1) {\n                a -= c;\n                result += 1 << i;\n            }\n        }\n        \n        result = ((dividend ^ divisor) >> 31) ? -result : result;\n        \n        return result >= INT_MAX ? INT_MAX : result;\n    }\n};\n```","slug":"2015-04-23-leetcode-Divide-Two-Integers","published":1,"updated":"2015-04-30T13:14:08.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck1q000trwmwl01y037w"},{"layout":"post","title":"动态规划: Palindrome Partitioning II ","date":"2015-04-23T03:38:20.000Z","_content":"\n>Given a string s, partition s such that every substring of the partition is a palindrome.\n>\n>Return the minimum cuts needed for a palindrome partitioning of s.\n>\n>For example, given s = \"aab\",\n>Return 1 since the palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut.\n\n``` cpp\n/*\n这里用到了两个dp，\n一个是判断字符串s[i][j]是否为回文，\n一个是记录s[0..i]最小的切割数\n\n经典题\n*/\n\nclass Solution {\npublic:\n    int minCut(string s) {\n        int n = s.size();\n        vector<vector<bool> > isPal(n, vector<bool>(n, false));\n        vector<int> cut(n, 0);\n        for (int j = 0; j < n; j++) {\n            cut[j] = j;\n            for (int i = 0; i <= j; i++) {\n                //如果子串 s[i...j]是回文串\n                if (s[i] == s[j] && (j - i <= 1 || isPal[i + 1][j - 1])) {\n                    isPal[i][j] = true;\n                    if (i > 0)\n                        cut[j] = min(cut[j], cut[i - 1] + 1);\n                    else\n                        cut[j] = 0; //如果 s[0...j]是回文串，则说明不需要切割\n                }\n            }\n        }\n        return cut[n - 1];\n    }\n};\n```","source":"_posts/2015-04-23-Palindrome_Partitioning_II .md","raw":"---\nlayout: post\ntitle:  \"动态规划: Palindrome Partitioning II \"\ndate:   2015-04-23 11:38:20\ncategories: problems\ntags: [动态规划]\n---\n\n>Given a string s, partition s such that every substring of the partition is a palindrome.\n>\n>Return the minimum cuts needed for a palindrome partitioning of s.\n>\n>For example, given s = \"aab\",\n>Return 1 since the palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut.\n\n``` cpp\n/*\n这里用到了两个dp，\n一个是判断字符串s[i][j]是否为回文，\n一个是记录s[0..i]最小的切割数\n\n经典题\n*/\n\nclass Solution {\npublic:\n    int minCut(string s) {\n        int n = s.size();\n        vector<vector<bool> > isPal(n, vector<bool>(n, false));\n        vector<int> cut(n, 0);\n        for (int j = 0; j < n; j++) {\n            cut[j] = j;\n            for (int i = 0; i <= j; i++) {\n                //如果子串 s[i...j]是回文串\n                if (s[i] == s[j] && (j - i <= 1 || isPal[i + 1][j - 1])) {\n                    isPal[i][j] = true;\n                    if (i > 0)\n                        cut[j] = min(cut[j], cut[i - 1] + 1);\n                    else\n                        cut[j] = 0; //如果 s[0...j]是回文串，则说明不需要切割\n                }\n            }\n        }\n        return cut[n - 1];\n    }\n};\n```","slug":"2015-04-23-Palindrome_Partitioning_II ","published":1,"updated":"2015-05-04T13:40:59.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck1s000vrwmwesz7ts28"},{"layout":"post","title":"动态规划：背包问题","date":"2015-04-11T15:21:20.000Z","_content":"\n###1.01背包问题\n\n>有n个重量和价值分别为wi和vi的物品。从这些物品中挑选出总重量不超过W的物品，求所有\n挑选方案中价值总和的最大值。\n>其中`1 < n < 100`, `1 < wi, vi < 100`, `1 < W < 10000`\n\n在前面的博客中说过01背包可以用DFS来解，但是使用DFS来解得话时间复杂度很高，所以可以使用动态规划\n来解这道题。\n\n首先，可以得到递推关系式：\n\n令dp[i + 1][j]表示从前i个物品中选出总重量不超过j的物品时总价值的最大值，那么：\n\n```\n    dp[0][j] = 0;\n\n                    dp[i][j]    j < w[i]\n    dp[i+1][j] = \n                    max{dp[i][j], dp[j-w[i]] + vi}\n```\n\n代码如下：\n``` cpp\n/*\n 此题见于挑战一书51页\n */\n#include <iostream>\nusing namespace std;\n\nconst int MAX_N = 100;\n\nint n, W;\nint w[MAX_N], v[MAX_N];\nint dp[MAX_N + 1][MAX_N + 1];\n\nvoid solve() {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= W; j++) {\n            if (j < w[i]) {\n                dp[i+1][j] = dp[i][j];\n            } else {\n                dp[i+1][j] = max(dp[i][j], dp[i][j-w[i]] + v[i]);\n            }\n        }\n    }\n    cout<<dp[n][W]<<endl;\n}\n\nint main() {\n    cin>>n;\n    for (int i = 0; i < n; i++) {\n        cin>>w[i]>>v[i];\n    }\n    cin>>W;\n    memset(dp, 0, sizeof(dp));\n    solve();\n} \n```\n\n###2.完全背包问题\n>有n种重量和价值分别为wi和vi的物品。从这些物品中挑选出总重量不超过W的物品，求所有\n挑选方案中价值总和的最大值。这里每种物品可以挑选任意多件。\n>其中`1 < n < 100`, `1 < wi, vi < 100`, `1 < W < 10000`\n\n这个问题和上一个问题的区别在于每种物品都可以挑选任意多件。但是递推关系和上一个问题差不多。\n\n令dp[i + 1][j]表示从前i个物品中选出总重量不超过j的物品时总价值的最大值，那么：\n```\n    dp[0][j] = 0;\n               \n    dp[i+1][j] = max{dp[i][j - k*w[i]] + k*v[i] | k >= 0}\n```\n\n代码如下：\n\n``` cpp\n/*\n 此题见于挑战一书51页\n */\n#include <iostream>\nusing namespace std;\n\nconst int MAX_N = 100;\n\nint n, W;\nint w[MAX_N], v[MAX_N];\nint dp[MAX_N + 1][MAX_N + 1];\n\nvoid solve() {\n    for (int i = 0; i < n; i ++) {\n        for (int j = 0; j <= W; j++) {\n            for (int k = 0; k*w[i] <= j; k++) {\n                dp[i+1][j] = max(dp[i+1][j], dp[i][j - k*w[i]] + k*v[i]);\n            }\n        }\n    }\n    \n    cout<<dp[n][W];\n}\n\nint main() {\n    cin>>n;\n    for (int i = 0; i < n; i++) {\n        cin>>w[i]>>v[i];\n    }\n    cin>>W;\n    memset(dp, 0, sizeof(dp));\n    solve();\n}\n```\n\n但是上面这种解法的时间复杂度可能达到O(nW^2),所以可以继续对题进行优化，在dp[i+1][j]的计算中选择k(k>=1)个i物品的情况与在dp[j+1][j-w[i]]的计算中选择k-1个i物品的情况\n是一样的，所以dp[i+1][j]的递推中k>=1的部分计算已经在dp[i+1][j-w[i]]的计算中完成\n了。所以可以按照如下方式变形：\n```\n\tdp[i+1][j] = max{dp[i][j - k*wi] - k*vi | k >= 0}\n\t\t   \t   = max{dp[i][j], max{ dp[i][j - k*wi] + k*vi | k >= 1} }\n\t\t   \t   = max{dp[i][j], max{dp[i][(j - wi) - k*wi] + k*vi | k >= 0} + vi}\n\t\t   \t   = max{dp[i][j], dp[i+1][j-wi] + vi}\n```\n\n代码如下：\n\n``` cpp\n/*\n 此题见于挑战一书51页\n */\n#include <iostream>\nusing namespace std;\n\nconst int MAX_N = 100;\n\nint n, W;\nint w[MAX_N], v[MAX_N];\nint dp[MAX_N + 1][MAX_N + 1];\n\nvoid solve() {\n    for (int i = 0; i < n; i ++) {\n        for (int j = 0; j <= W; j++) {\n            if (j < w[i]) {\n                dp[i + 1][j] = dp[i][j];\n            } else {\n                dp[i + 1][j] = max(dp[i][j], dp[i + 1][j - w[i]] + v[i]);\n            }\n        }\n    }\n    \n    cout<<dp[n][W];\n}\n\nint main() {\n    cin>>n;\n    for (int i = 0; i < n; i++) {\n        cin>>w[i]>>v[i];\n    }\n    cin>>W;\n    memset(dp, 0, sizeof(dp));\n    solve();\n}\n```\n\n###3.使用滚动数组来减少空间复杂度\n对这种一行一行计算结果的情况，我们有时可以用重复利用一个滚动数组来降低空间复杂度。\n\n``` cpp\nint dp[MAX_W + 1]\n\n/*\n01背包问题\n*/\n\nvoid solve() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = W; j >= w[i]; j--) {\n\t\t\tdp[j] = max(dp[j], dp[i - w[i]] + v[i]);\n\t\t}\n\t}\n\tcout<<dp[W]<<endl;\n}\n\n/*\n完全背包问题\n*/\n\nvoid solve() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = w[i]; j <= W; j++) {\n\t\t\tdp[j] = max(dp[j], dp[j - w[i]] + v[i]);\n\t\t}\n\t}\n\tcout<<dp[W]<<endl;\n}\n```","source":"_posts/2015-04-11-bag-problem.md","raw":"---\nlayout: post\ntitle:  \"动态规划：背包问题\"\ndate:   2015-4-11 23:21:20\ncategories:   problems\ntags: [动态规划]\n---\n\n###1.01背包问题\n\n>有n个重量和价值分别为wi和vi的物品。从这些物品中挑选出总重量不超过W的物品，求所有\n挑选方案中价值总和的最大值。\n>其中`1 < n < 100`, `1 < wi, vi < 100`, `1 < W < 10000`\n\n在前面的博客中说过01背包可以用DFS来解，但是使用DFS来解得话时间复杂度很高，所以可以使用动态规划\n来解这道题。\n\n首先，可以得到递推关系式：\n\n令dp[i + 1][j]表示从前i个物品中选出总重量不超过j的物品时总价值的最大值，那么：\n\n```\n    dp[0][j] = 0;\n\n                    dp[i][j]    j < w[i]\n    dp[i+1][j] = \n                    max{dp[i][j], dp[j-w[i]] + vi}\n```\n\n代码如下：\n``` cpp\n/*\n 此题见于挑战一书51页\n */\n#include <iostream>\nusing namespace std;\n\nconst int MAX_N = 100;\n\nint n, W;\nint w[MAX_N], v[MAX_N];\nint dp[MAX_N + 1][MAX_N + 1];\n\nvoid solve() {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= W; j++) {\n            if (j < w[i]) {\n                dp[i+1][j] = dp[i][j];\n            } else {\n                dp[i+1][j] = max(dp[i][j], dp[i][j-w[i]] + v[i]);\n            }\n        }\n    }\n    cout<<dp[n][W]<<endl;\n}\n\nint main() {\n    cin>>n;\n    for (int i = 0; i < n; i++) {\n        cin>>w[i]>>v[i];\n    }\n    cin>>W;\n    memset(dp, 0, sizeof(dp));\n    solve();\n} \n```\n\n###2.完全背包问题\n>有n种重量和价值分别为wi和vi的物品。从这些物品中挑选出总重量不超过W的物品，求所有\n挑选方案中价值总和的最大值。这里每种物品可以挑选任意多件。\n>其中`1 < n < 100`, `1 < wi, vi < 100`, `1 < W < 10000`\n\n这个问题和上一个问题的区别在于每种物品都可以挑选任意多件。但是递推关系和上一个问题差不多。\n\n令dp[i + 1][j]表示从前i个物品中选出总重量不超过j的物品时总价值的最大值，那么：\n```\n    dp[0][j] = 0;\n               \n    dp[i+1][j] = max{dp[i][j - k*w[i]] + k*v[i] | k >= 0}\n```\n\n代码如下：\n\n``` cpp\n/*\n 此题见于挑战一书51页\n */\n#include <iostream>\nusing namespace std;\n\nconst int MAX_N = 100;\n\nint n, W;\nint w[MAX_N], v[MAX_N];\nint dp[MAX_N + 1][MAX_N + 1];\n\nvoid solve() {\n    for (int i = 0; i < n; i ++) {\n        for (int j = 0; j <= W; j++) {\n            for (int k = 0; k*w[i] <= j; k++) {\n                dp[i+1][j] = max(dp[i+1][j], dp[i][j - k*w[i]] + k*v[i]);\n            }\n        }\n    }\n    \n    cout<<dp[n][W];\n}\n\nint main() {\n    cin>>n;\n    for (int i = 0; i < n; i++) {\n        cin>>w[i]>>v[i];\n    }\n    cin>>W;\n    memset(dp, 0, sizeof(dp));\n    solve();\n}\n```\n\n但是上面这种解法的时间复杂度可能达到O(nW^2),所以可以继续对题进行优化，在dp[i+1][j]的计算中选择k(k>=1)个i物品的情况与在dp[j+1][j-w[i]]的计算中选择k-1个i物品的情况\n是一样的，所以dp[i+1][j]的递推中k>=1的部分计算已经在dp[i+1][j-w[i]]的计算中完成\n了。所以可以按照如下方式变形：\n```\n\tdp[i+1][j] = max{dp[i][j - k*wi] - k*vi | k >= 0}\n\t\t   \t   = max{dp[i][j], max{ dp[i][j - k*wi] + k*vi | k >= 1} }\n\t\t   \t   = max{dp[i][j], max{dp[i][(j - wi) - k*wi] + k*vi | k >= 0} + vi}\n\t\t   \t   = max{dp[i][j], dp[i+1][j-wi] + vi}\n```\n\n代码如下：\n\n``` cpp\n/*\n 此题见于挑战一书51页\n */\n#include <iostream>\nusing namespace std;\n\nconst int MAX_N = 100;\n\nint n, W;\nint w[MAX_N], v[MAX_N];\nint dp[MAX_N + 1][MAX_N + 1];\n\nvoid solve() {\n    for (int i = 0; i < n; i ++) {\n        for (int j = 0; j <= W; j++) {\n            if (j < w[i]) {\n                dp[i + 1][j] = dp[i][j];\n            } else {\n                dp[i + 1][j] = max(dp[i][j], dp[i + 1][j - w[i]] + v[i]);\n            }\n        }\n    }\n    \n    cout<<dp[n][W];\n}\n\nint main() {\n    cin>>n;\n    for (int i = 0; i < n; i++) {\n        cin>>w[i]>>v[i];\n    }\n    cin>>W;\n    memset(dp, 0, sizeof(dp));\n    solve();\n}\n```\n\n###3.使用滚动数组来减少空间复杂度\n对这种一行一行计算结果的情况，我们有时可以用重复利用一个滚动数组来降低空间复杂度。\n\n``` cpp\nint dp[MAX_W + 1]\n\n/*\n01背包问题\n*/\n\nvoid solve() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = W; j >= w[i]; j--) {\n\t\t\tdp[j] = max(dp[j], dp[i - w[i]] + v[i]);\n\t\t}\n\t}\n\tcout<<dp[W]<<endl;\n}\n\n/*\n完全背包问题\n*/\n\nvoid solve() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = w[i]; j <= W; j++) {\n\t\t\tdp[j] = max(dp[j], dp[j - w[i]] + v[i]);\n\t\t}\n\t}\n\tcout<<dp[W]<<endl;\n}\n```","slug":"2015-04-11-bag-problem","published":1,"updated":"2015-05-04T13:41:09.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck1u000yrwmwzzvn3ghe"},{"layout":"post","title":"动态规划: Dungeon Game","date":"2015-04-10T06:47:20.000Z","_content":"\n>The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.\n>\n>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\n>\n>Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers).\n>\n>In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.\n\n[原题链接](https://leetcode.com/problems/dungeon-game/)\n\n``` cpp\n/*\n    这道题和以前求最短路径的题有点相似，但是又不是求最短路径，因为要时刻保持英雄血量为正\n\n    但是我们还是可以使用动态规划来解决，我们约定一个数组dp[rows][cols]，其中\n    dp[i][j]表示进来(i, j)之前所需要的最少血量，则我们要求的结果就是dp[0][0]\n\n    那么我们可以得到一个递归式：\n    dp[i][j] = min(max(1, dp[i+1][j] - dungeon[i][j], max(1, dp[i][j+1] - dungeon[i][j])))\n    \n    可以这么理解，英雄进来（i, j）室后，有两条路出去，那么他出去之后所需的血量是接下来需要进入的\n    密室所需要的最低血量，即dp[i+1][j]和dp[i][j+1],那么他进来这个密室之前所需要的最低血量是多少\n    呢，那就很容易知道了，我们肯定选择一个出去时所需血量最少的，这样进来之前所需要的血量也是最少，\n    但是，需要注意的是，英雄的血量必须时刻保持为正，所以我们取max(1, exit_HP - dungeon[i][j])\n\n*/\n\nclass Solution {\npublic:\n    int calculateMinimumHP(vector<vector<int> > &dungeon) {\n        int rows = dungeon.size();\n        int cols = rows > 0 ? dungeon[0].size() : 0;\n        \n        vector<int> dp(cols, INT_MAX);\n        dp[cols - 1] = 1;\n\n        for (int i = rows - 1; i >= 0; i--) {\n            dp[cols - 1] = max(1, dp[cols - 1] - dungeon[i][cols - 1]);\n\n            for (int j = cols - 2; j >= 0; j--) {\n                dp[j] = max(1, min(dp[j], dp[j + 1]) - dungeon[i][j]);\n            }          \n        }\n        return dp[0];\n    }\n};\n```","source":"_posts/2015-04-10-leetcode-Dungeon-Game.md","raw":"---\nlayout: post\ntitle:  \"动态规划: Dungeon Game\"\ndate:   2015-04-10 14:47:20\ncategories: problems\ntags: [动态规划]\n---\n\n>The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.\n>\n>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\n>\n>Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers).\n>\n>In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.\n\n[原题链接](https://leetcode.com/problems/dungeon-game/)\n\n``` cpp\n/*\n    这道题和以前求最短路径的题有点相似，但是又不是求最短路径，因为要时刻保持英雄血量为正\n\n    但是我们还是可以使用动态规划来解决，我们约定一个数组dp[rows][cols]，其中\n    dp[i][j]表示进来(i, j)之前所需要的最少血量，则我们要求的结果就是dp[0][0]\n\n    那么我们可以得到一个递归式：\n    dp[i][j] = min(max(1, dp[i+1][j] - dungeon[i][j], max(1, dp[i][j+1] - dungeon[i][j])))\n    \n    可以这么理解，英雄进来（i, j）室后，有两条路出去，那么他出去之后所需的血量是接下来需要进入的\n    密室所需要的最低血量，即dp[i+1][j]和dp[i][j+1],那么他进来这个密室之前所需要的最低血量是多少\n    呢，那就很容易知道了，我们肯定选择一个出去时所需血量最少的，这样进来之前所需要的血量也是最少，\n    但是，需要注意的是，英雄的血量必须时刻保持为正，所以我们取max(1, exit_HP - dungeon[i][j])\n\n*/\n\nclass Solution {\npublic:\n    int calculateMinimumHP(vector<vector<int> > &dungeon) {\n        int rows = dungeon.size();\n        int cols = rows > 0 ? dungeon[0].size() : 0;\n        \n        vector<int> dp(cols, INT_MAX);\n        dp[cols - 1] = 1;\n\n        for (int i = rows - 1; i >= 0; i--) {\n            dp[cols - 1] = max(1, dp[cols - 1] - dungeon[i][cols - 1]);\n\n            for (int j = cols - 2; j >= 0; j--) {\n                dp[j] = max(1, min(dp[j], dp[j + 1]) - dungeon[i][j]);\n            }          \n        }\n        return dp[0];\n    }\n};\n```","slug":"2015-04-10-leetcode-Dungeon-Game","published":1,"updated":"2015-05-04T13:41:15.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck1w0011rwmw7evryd2b"},{"layout":"post","title":"golang中的sync","date":"2015-03-11T05:11:20.000Z","_content":"\n在golang中使用并发时，除了使用channel用来同步以外，还可以使用sync包来实现。\n\nsync包中的WaitGroup实现了一个类似任务队列的结构，你可以向队列中加入任务，任务完成后就把任务从队列中移除，如果队列中的任务没有全部完成，队列就会触发阻塞以阻止程序继续运行。\n\n这种情况就适用于各个goroutine之间不需要交换什么数据，只是完成一些相互独立的功能。例如写一个爬虫，爬曲各个不同页面，就可以使用sync。\n\n下面是golang官网的代码：\n\n``` go\nvar wg sync.WaitGroup\nvar urls = []string{\n        \"http://www.golang.org/\",\n        \"http://www.google.com/\",\n        \"http://www.somestupidname.com/\",\n}\nfor _, url := range urls {\n        // Increment the WaitGroup counter.\n        wg.Add(1)\n        // Launch a goroutine to fetch the URL.\n        go func(url string) {\n                // Decrement the counter when the goroutine completes.\n                defer wg.Done()\n                // Fetch the URL.\n                http.Get(url)\n        }(url)\n}\n// Wait for all HTTP fetches to complete.\nwg.Wait()\n```","source":"_posts/2015-03-11-go-sync.md","raw":"---\nlayout: post\ntitle:  \"golang中的sync\"\ndate:   2015-03-11 13:11:20\ncategories:   golang\n---\n\n在golang中使用并发时，除了使用channel用来同步以外，还可以使用sync包来实现。\n\nsync包中的WaitGroup实现了一个类似任务队列的结构，你可以向队列中加入任务，任务完成后就把任务从队列中移除，如果队列中的任务没有全部完成，队列就会触发阻塞以阻止程序继续运行。\n\n这种情况就适用于各个goroutine之间不需要交换什么数据，只是完成一些相互独立的功能。例如写一个爬虫，爬曲各个不同页面，就可以使用sync。\n\n下面是golang官网的代码：\n\n``` go\nvar wg sync.WaitGroup\nvar urls = []string{\n        \"http://www.golang.org/\",\n        \"http://www.google.com/\",\n        \"http://www.somestupidname.com/\",\n}\nfor _, url := range urls {\n        // Increment the WaitGroup counter.\n        wg.Add(1)\n        // Launch a goroutine to fetch the URL.\n        go func(url string) {\n                // Decrement the counter when the goroutine completes.\n                defer wg.Done()\n                // Fetch the URL.\n                http.Get(url)\n        }(url)\n}\n// Wait for all HTTP fetches to complete.\nwg.Wait()\n```","slug":"2015-03-11-go-sync","published":1,"updated":"2015-04-30T13:12:40.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck1y0014rwmw8gn6acn9"},{"layout":"post","title":"c++中fill与fill_n函数","date":"2015-01-29T12:01:20.000Z","_content":"\n###fill函数\n\nfill函数的作用是：将一个区间的元素都赋予val值。函数参数：fill(first,last,val);//first为容器的首迭代器，last为容器的末迭代器，val为将要替换的值。\n\n``` cpp\n// fill algorithm example\n#include <iostream>     // std::cout\n#include <algorithm>    // std::fill\n#include <vector>       // std::vector\n\nint main () {\n  std::vector<int> myvector (8);                       // myvector: 0 0 0 0 0 0 0 0\n\n  std::fill (myvector.begin(),myvector.begin()+4,5);   // myvector: 5 5 5 5 0 0 0 0\n  std::fill (myvector.begin()+3,myvector.end()-2,8);   // myvector: 5 5 5 8 8 8 0 0\n\n  std::cout << \"myvector contains:\";\n  for (std::vector<int>::iterator it=myvector.begin(); it!=myvector.end(); ++it)\n    std::cout << ' ' << *it;\n  std::cout << '\\n';\n\n  return 0;\n}\n```\n\n###fill_n函数\n\nfill_n函数的作用是：给你一个起始点，然后再给你一个数值count和val。把从起始点开始依次赋予count个元素val的值。\n\n与fill函数的区别就是fill_n直接指定元素的个数，fill只是指定一个区间\n\n``` cpp\n\n// fill_n example\n#include <iostream>     // std::cout\n#include <algorithm>    // std::fill_n\n#include <vector>       // std::vector\n\nint main () {\n  std::vector<int> myvector (8,10);        // myvector: 10 10 10 10 10 10 10 10\n\n  std::fill_n (myvector.begin(),4,20);     // myvector: 20 20 20 20 10 10 10 10\n  std::fill_n (myvector.begin()+3,3,33);   // myvector: 20 20 20 33 33 33 10 10\n\n  std::cout << \"myvector contains:\";\n  for (std::vector<int>::iterator it=myvector.begin(); it!=myvector.end(); ++it)\n    std::cout << ' ' << *it;\n  std::cout << '\\n';\n\n  return 0;\n}\n```","source":"_posts/2015-01-29-cpp-fill.md","raw":"---\nlayout: post\ntitle:  \"c++中fill与fill_n函数\"\ndate:   2015-1-29 20:01:20\ncategories:   cpp\n---\n\n###fill函数\n\nfill函数的作用是：将一个区间的元素都赋予val值。函数参数：fill(first,last,val);//first为容器的首迭代器，last为容器的末迭代器，val为将要替换的值。\n\n``` cpp\n// fill algorithm example\n#include <iostream>     // std::cout\n#include <algorithm>    // std::fill\n#include <vector>       // std::vector\n\nint main () {\n  std::vector<int> myvector (8);                       // myvector: 0 0 0 0 0 0 0 0\n\n  std::fill (myvector.begin(),myvector.begin()+4,5);   // myvector: 5 5 5 5 0 0 0 0\n  std::fill (myvector.begin()+3,myvector.end()-2,8);   // myvector: 5 5 5 8 8 8 0 0\n\n  std::cout << \"myvector contains:\";\n  for (std::vector<int>::iterator it=myvector.begin(); it!=myvector.end(); ++it)\n    std::cout << ' ' << *it;\n  std::cout << '\\n';\n\n  return 0;\n}\n```\n\n###fill_n函数\n\nfill_n函数的作用是：给你一个起始点，然后再给你一个数值count和val。把从起始点开始依次赋予count个元素val的值。\n\n与fill函数的区别就是fill_n直接指定元素的个数，fill只是指定一个区间\n\n``` cpp\n\n// fill_n example\n#include <iostream>     // std::cout\n#include <algorithm>    // std::fill_n\n#include <vector>       // std::vector\n\nint main () {\n  std::vector<int> myvector (8,10);        // myvector: 10 10 10 10 10 10 10 10\n\n  std::fill_n (myvector.begin(),4,20);     // myvector: 20 20 20 20 10 10 10 10\n  std::fill_n (myvector.begin()+3,3,33);   // myvector: 20 20 20 33 33 33 10 10\n\n  std::cout << \"myvector contains:\";\n  for (std::vector<int>::iterator it=myvector.begin(); it!=myvector.end(); ++it)\n    std::cout << ' ' << *it;\n  std::cout << '\\n';\n\n  return 0;\n}\n```","slug":"2015-01-29-cpp-fill","published":1,"updated":"2015-04-30T13:11:23.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck1z0016rwmww0xxw00c"},{"layout":"post","title":"常量指针和指针常量","date":"2014-11-30T06:41:20.000Z","_content":"\n###常量指针\n常量指针是说指针所指向的内容是常量。\n\n比如:\n``` cpp\nchar a[10] = \"hello\";\nconst char *p = a;\n*p = 'a'; //这样是不行的，因为申明的是一个常量指针\n```\n\n###指针常量\n指针常量说的是指针是一个常量，不能够更改指针的值。\n\n比如：\n``` cpp\nchar a[10] = \"hello\";\nchar b[10] = \"world\";\nchar * const p = &a;\np = &b; //这样是不行的，因为申明的是一个指针常量\n```","source":"_posts/2014-11-30-c-constant-pointer.md","raw":"---\nlayout: post\ntitle:  \"常量指针和指针常量\"\ndate:   2014-11-30 14:41:20\ncategories:   cpp\n---\n\n###常量指针\n常量指针是说指针所指向的内容是常量。\n\n比如:\n``` cpp\nchar a[10] = \"hello\";\nconst char *p = a;\n*p = 'a'; //这样是不行的，因为申明的是一个常量指针\n```\n\n###指针常量\n指针常量说的是指针是一个常量，不能够更改指针的值。\n\n比如：\n``` cpp\nchar a[10] = \"hello\";\nchar b[10] = \"world\";\nchar * const p = &a;\np = &b; //这样是不行的，因为申明的是一个指针常量\n```","slug":"2014-11-30-c-constant-pointer","published":1,"updated":"2015-04-30T13:11:07.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck220019rwmwiflvncjx"},{"layout":"post","title":"动态规划: Maximum Product Subarray","date":"2014-11-26T13:45:20.000Z","_content":"\n> Find the contiguous subarray within an array (containing at least one number) which has the largest product.\n>\n> For example, given the array `[2,3,-2,4]`,\n>\n>the contiguous subarray `[2,3]` has the largest product = `6`.\n\n\n``` cpp\n/*\n\nf(k) = Largest product subarray, from index 0 up to k, but must multiply A[k].\ng(k) = Smallest product subarray, from index 0 up to k, but must multiply A[k].\n\n在f(k)和g(k)中，\nf(k)是指从0~k,最后乘以A[k]的最大值，\ng(k)是指从0~k,最后乘以A[k]的最小值.\n所以这也是为什么f(k)，g(k)并不是全局的最大值和最小值，之所以一定要乘上A[k]，是因为\n求的是连续的范围，只有这样，才能够往下继续遍历。\n\nf(k) = max( f(k-1) * A[k], A[k], g(k-1) * A[k] )\ng(k) = min( g(k-1) * A[k], A[k], f(k-1) * A[k] )\n\n在递推公式中，如果f(k)为A[k]，表示从k重新开始。\n比如{2,3,-2,4}，k=2时，f(k)=-2,表示从-2处重新开始计算最大值。\n\n\n*/\nclass Solution {\npublic:\n    int maxProduct(int A[], int n) {\n        int min_tmp = A[0];\n        int max_tmp = A[0];\n        int result = max_tmp;\n        \n        for (int i = 1; i < n; i++) {\n            int a = min_tmp * A[i];\n            int b = max_tmp * A[i];\n            min_tmp = min(min(a, b), A[i]);\n            max_tmp = max(max(a, b), A[i]);\n            result = max(result, max_tmp);\n        }\n        return result;\n    }\n};\n```\n","source":"_posts/2014-11-26-leetcode-maximum-product-subarray.md","raw":"---\nlayout: post\ntitle:  \"动态规划: Maximum Product Subarray\"\ndate:   2014-11-26 21:45:20\ncategories: problems\ntags: [动态规划]\n---\n\n> Find the contiguous subarray within an array (containing at least one number) which has the largest product.\n>\n> For example, given the array `[2,3,-2,4]`,\n>\n>the contiguous subarray `[2,3]` has the largest product = `6`.\n\n\n``` cpp\n/*\n\nf(k) = Largest product subarray, from index 0 up to k, but must multiply A[k].\ng(k) = Smallest product subarray, from index 0 up to k, but must multiply A[k].\n\n在f(k)和g(k)中，\nf(k)是指从0~k,最后乘以A[k]的最大值，\ng(k)是指从0~k,最后乘以A[k]的最小值.\n所以这也是为什么f(k)，g(k)并不是全局的最大值和最小值，之所以一定要乘上A[k]，是因为\n求的是连续的范围，只有这样，才能够往下继续遍历。\n\nf(k) = max( f(k-1) * A[k], A[k], g(k-1) * A[k] )\ng(k) = min( g(k-1) * A[k], A[k], f(k-1) * A[k] )\n\n在递推公式中，如果f(k)为A[k]，表示从k重新开始。\n比如{2,3,-2,4}，k=2时，f(k)=-2,表示从-2处重新开始计算最大值。\n\n\n*/\nclass Solution {\npublic:\n    int maxProduct(int A[], int n) {\n        int min_tmp = A[0];\n        int max_tmp = A[0];\n        int result = max_tmp;\n        \n        for (int i = 1; i < n; i++) {\n            int a = min_tmp * A[i];\n            int b = max_tmp * A[i];\n            min_tmp = min(min(a, b), A[i]);\n            max_tmp = max(max(a, b), A[i]);\n            result = max(result, max_tmp);\n        }\n        return result;\n    }\n};\n```\n","slug":"2014-11-26-leetcode-maximum-product-subarray","published":1,"updated":"2015-05-04T13:41:38.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck24001brwmwd4zds3ke"},{"layout":"post","title":"STL:iterator的一些常见操作","date":"2014-11-25T02:20:20.000Z","_content":"\n有时在做题时，碰到vector之类的容器时，如果我要制定一个容器的范围，那么我就不得不声明三个形参，一个vector，两个下标。但是在这里我们还可以实用迭代器来实现，这样，就只需要实用两个形参就可以了。\n\niterator在实际题目中的使用见重建二叉树部分。\n\n下面，举出一些iterator的常用函数：\n\n+ begin(), end()\n\n``` cpp\n#include <iostream>     // std::cout\n#include <vector>       // std::vector, std::begin, std::end\n\nint main () {\n  int foo[] = {a};\n  std::vector<int> bar;\n\n  // iterate foo: inserting into bar\n  //数组也可以使用\n  for (auto it = std::begin(foo); it!=std::end(foo); ++it)\n    bar.push_back(*it);\n\n  // iterate bar: print contents:\n  std::cout << \"bar contains:\";\n  for (auto it = std::begin(bar); it!=std::end(bar); ++it)\n    std::cout << ' ' << *it;\n  std::cout << '\\n';\n\n  return 0;\n}\n```\n\n+ distance()\n\n``` cpp\n// advance example\n#include <iostream>     // std::cout\n#include <iterator>     // std::distance\n#include <list>         // std::list\n\nint main () {\n  std::list<int> mylist;\n  for (int i=0; i<10; i++) mylist.push_back (i*10);\n\n  std::list<int>::iterator first = mylist.begin();\n  std::list<int>::iterator last = mylist.end();\n\n  std::cout << \"The distance is: \" << std::distance(first,last) << '\\n';\n\n  return 0;\n}\n```\n\n+ next()\n\n``` cpp\n// next example\n#include <iostream>     // std::cout\n#include <iterator>     // std::next\n#include <list>         // std::list\n#include <algorithm>    // std::for_each\n\nint main () {\n  std::list<int> mylist;\n  for (int i=0; i<10; i++) mylist.push_back (i*10);\n\n  std::cout << \"mylist:\";\n  std::for_each (mylist.begin(),\n                 std::next(mylist.begin(),5),\n                 [](int x) {std::cout << ' ' << x;} );\n\n  std::cout << '\\n';\n\n  return 0;\n}\n```\n\n+ pre()\n\n``` cpp\n// prev example\n#include <iostream>     // std::cout\n#include <iterator>     // std::next\n#include <list>         // std::list\n#include <algorithm>    // std::for_each\n\nint main () {\n  std::list<int> mylist;\n  for (int i=0; i<10; i++) mylist.push_back (i*10);\n\n  std::cout << \"The last element is \" << *std::prev(mylist.end()) << '\\n';\n\n  return 0;\n}\n```\n\n+ reverse_iterator()\n\n``` cpp\n// reverse_iterator example\n#include <iostream>     // std::cout\n#include <iterator>     // std::reverse_iterator\n#include <vector>       // std::vector\n\nint main () {\n  std::vector<int> myvector;\n  for (int i=0; i<10; i++) myvector.push_back(i);\n\n  typedef std::vector<int>::iterator iter_type;\n                                                         // ? 0 1 2 3 4 5 6 7 8 9 ?\n  iter_type from (myvector.begin());                     //   ^\n                                                         //         ------>\n  iter_type until (myvector.end());                      //                       ^\n                                                         //\n  std::reverse_iterator<iter_type> rev_until (from);     // ^\n                                                         //         <------\n  std::reverse_iterator<iter_type> rev_from (until);     //                     ^\n\n  std::cout << \"myvector:\";\n  while (rev_from != rev_until)\n    std::cout << ' ' << *rev_from++;\n  std::cout << '\\n';\n\n  return 0;\n}\n```\n","source":"_posts/2014-11-25-stl-iterator.md","raw":"---\nlayout: post\ntitle:  \"STL:iterator的一些常见操作\"\ndate:   2014-11-25 10:20:20\ncategories:   cpp\n---\n\n有时在做题时，碰到vector之类的容器时，如果我要制定一个容器的范围，那么我就不得不声明三个形参，一个vector，两个下标。但是在这里我们还可以实用迭代器来实现，这样，就只需要实用两个形参就可以了。\n\niterator在实际题目中的使用见重建二叉树部分。\n\n下面，举出一些iterator的常用函数：\n\n+ begin(), end()\n\n``` cpp\n#include <iostream>     // std::cout\n#include <vector>       // std::vector, std::begin, std::end\n\nint main () {\n  int foo[] = {a};\n  std::vector<int> bar;\n\n  // iterate foo: inserting into bar\n  //数组也可以使用\n  for (auto it = std::begin(foo); it!=std::end(foo); ++it)\n    bar.push_back(*it);\n\n  // iterate bar: print contents:\n  std::cout << \"bar contains:\";\n  for (auto it = std::begin(bar); it!=std::end(bar); ++it)\n    std::cout << ' ' << *it;\n  std::cout << '\\n';\n\n  return 0;\n}\n```\n\n+ distance()\n\n``` cpp\n// advance example\n#include <iostream>     // std::cout\n#include <iterator>     // std::distance\n#include <list>         // std::list\n\nint main () {\n  std::list<int> mylist;\n  for (int i=0; i<10; i++) mylist.push_back (i*10);\n\n  std::list<int>::iterator first = mylist.begin();\n  std::list<int>::iterator last = mylist.end();\n\n  std::cout << \"The distance is: \" << std::distance(first,last) << '\\n';\n\n  return 0;\n}\n```\n\n+ next()\n\n``` cpp\n// next example\n#include <iostream>     // std::cout\n#include <iterator>     // std::next\n#include <list>         // std::list\n#include <algorithm>    // std::for_each\n\nint main () {\n  std::list<int> mylist;\n  for (int i=0; i<10; i++) mylist.push_back (i*10);\n\n  std::cout << \"mylist:\";\n  std::for_each (mylist.begin(),\n                 std::next(mylist.begin(),5),\n                 [](int x) {std::cout << ' ' << x;} );\n\n  std::cout << '\\n';\n\n  return 0;\n}\n```\n\n+ pre()\n\n``` cpp\n// prev example\n#include <iostream>     // std::cout\n#include <iterator>     // std::next\n#include <list>         // std::list\n#include <algorithm>    // std::for_each\n\nint main () {\n  std::list<int> mylist;\n  for (int i=0; i<10; i++) mylist.push_back (i*10);\n\n  std::cout << \"The last element is \" << *std::prev(mylist.end()) << '\\n';\n\n  return 0;\n}\n```\n\n+ reverse_iterator()\n\n``` cpp\n// reverse_iterator example\n#include <iostream>     // std::cout\n#include <iterator>     // std::reverse_iterator\n#include <vector>       // std::vector\n\nint main () {\n  std::vector<int> myvector;\n  for (int i=0; i<10; i++) myvector.push_back(i);\n\n  typedef std::vector<int>::iterator iter_type;\n                                                         // ? 0 1 2 3 4 5 6 7 8 9 ?\n  iter_type from (myvector.begin());                     //   ^\n                                                         //         ------>\n  iter_type until (myvector.end());                      //                       ^\n                                                         //\n  std::reverse_iterator<iter_type> rev_until (from);     // ^\n                                                         //         <------\n  std::reverse_iterator<iter_type> rev_from (until);     //                     ^\n\n  std::cout << \"myvector:\";\n  while (rev_from != rev_until)\n    std::cout << ' ' << *rev_from++;\n  std::cout << '\\n';\n\n  return 0;\n}\n```\n","slug":"2014-11-25-stl-iterator","published":1,"updated":"2015-04-30T13:16:04.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck27001erwmwscta5tm1"},{"layout":"post","title":"STL: upper_bound & lower_bound","date":"2014-11-23T03:39:20.000Z","_content":"\n有时候，我们用到二分搜索的时候需要求出大于等于一个数的最小值和小于等于一个数的最大值，这个时候我们除了自己写出二分搜索的代码外，还可以使用这两个函数。\n\n``` cpp\n// lower_bound/upper_bound example\n#include <iostream>     // std::cout\n#include <algorithm>    // std::lower_bound, std::upper_bound, std::sort\n#include <vector>       // std::vector\n\nint main () {\n  int myints[] = {10,20,30,30,20,10,10,20};\n  std::vector<int> v(myints,myints+8);           // 10 20 30 30 20 10 10 20\n\n  std::sort (v.begin(), v.end());                // 10 10 10 20 20 20 30 30\n\n  std::vector<int>::iterator low,up;\n  low=std::lower_bound (v.begin(), v.end(), 20); //          ^\n  up= std::upper_bound (v.begin(), v.end(), 20); //                   ^\n\n  std::cout << \"lower_bound at position \" << (low- v.begin()) << '\\n';\n  std::cout << \"upper_bound at position \" << (up - v.begin()) << '\\n';\n\n  return 0;\n}\n```","source":"_posts/2014-11-23-upper-bound-lower-bound.md","raw":"---\nlayout: post\ntitle:  \"STL: upper_bound & lower_bound\"\ndate:   2014-11-23 11:39:20\ncategories:   cpp\ntags: [二分搜索]\n---\n\n有时候，我们用到二分搜索的时候需要求出大于等于一个数的最小值和小于等于一个数的最大值，这个时候我们除了自己写出二分搜索的代码外，还可以使用这两个函数。\n\n``` cpp\n// lower_bound/upper_bound example\n#include <iostream>     // std::cout\n#include <algorithm>    // std::lower_bound, std::upper_bound, std::sort\n#include <vector>       // std::vector\n\nint main () {\n  int myints[] = {10,20,30,30,20,10,10,20};\n  std::vector<int> v(myints,myints+8);           // 10 20 30 30 20 10 10 20\n\n  std::sort (v.begin(), v.end());                // 10 10 10 20 20 20 30 30\n\n  std::vector<int>::iterator low,up;\n  low=std::lower_bound (v.begin(), v.end(), 20); //          ^\n  up= std::upper_bound (v.begin(), v.end(), 20); //                   ^\n\n  std::cout << \"lower_bound at position \" << (low- v.begin()) << '\\n';\n  std::cout << \"upper_bound at position \" << (up - v.begin()) << '\\n';\n\n  return 0;\n}\n```","slug":"2014-11-23-upper-bound-lower-bound","published":1,"updated":"2015-05-04T13:54:41.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck28001grwmwyu3vdlpv"},{"layout":"post","title":"二分搜索","date":"2014-11-23T03:38:20.000Z","_content":"\n我们可以很快地写出在已排序数组中查找某一个数的代码，但是如果我们要找出某个数的上界和下届有时候就会多费点心思，在这里我们可以看看这三种方式的不同之处,另外，在实际应用中，我们可以不用自己是实现，直接使用STL中的upper_bound和lower_bound函数就可以了。\n\n``` cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n//精确查找某一个值\n//如果有的话，返回第一个找到的值\n//如果没有的话，返回-1\nint binarySearch(vector<int> &A, int x) {\n    int size = (int)A.size();\n    int lb = 0, ub = size - 1;\n    while (lb <= ub) {\n        int mb = lb + (ub - lb)/2;\n        if (A[mb] == x)\n            return mb;\n        else if (A[mb] > x)\n            ub = mb - 1;\n        else\n            lb = mb + 1;\n    }\n    return -1;\n}\n\n//在数组中查找x的上界,即小于等于x的最大值\n//如果有，返回上界\n//如果没有，返回-1\nint upperBound(vector<int> &A, int x) {\n    int size = (int)A.size();\n    int lb = -1, ub = size;\n    while (ub - lb > 1) {\n        int md = lb + (ub - lb) / 2;\n        //如果满足条件，那么符合条件的范围就是[mid,ub)\n        if (A[md] <= x)\n            lb = md;\n        else\n            ub = md;\n    }\n    return lb;\n}\n\n//在数组中查找x的下界,即大于等于x的最小值\n//如果有，返回下界\n//如果没有，返回n\nint lowerBound(vector<int> &A, int x) {\n    int size = (int)A.size();\n    int lb = -1, ub = size;\n    while (ub - lb > 1) {\n        int md = lb + (ub - lb) / 2;\n        //如果满足条件，那么符合条件的范围就是(mid, ub]\n        if (A[md] >= x)\n            ub = md;\n        else\n            lb = md;\n    }\n    return ub;\n}\n\n//10 10 10 20 20 20 30 30\nint main() {\n    int myints[] = {10,20,30,30,20,10,10,20};\n    vector<int> test(myints, myints + 8);\n    sort(test.begin(), test.end());\n    cout<<binarySearch(test, 15)<<endl;\n    cout<<upperBound(test, 38)<<endl;\n    cout<<lowerBound(test, 5)<<endl;\n}\n```","source":"_posts/2014-11-23-binary-search.md","raw":"---\nlayout: post\ntitle:  \"二分搜索\"\ndate:   2014-11-23 11:38:20\ncategories:   algorithms\n---\n\n我们可以很快地写出在已排序数组中查找某一个数的代码，但是如果我们要找出某个数的上界和下届有时候就会多费点心思，在这里我们可以看看这三种方式的不同之处,另外，在实际应用中，我们可以不用自己是实现，直接使用STL中的upper_bound和lower_bound函数就可以了。\n\n``` cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n//精确查找某一个值\n//如果有的话，返回第一个找到的值\n//如果没有的话，返回-1\nint binarySearch(vector<int> &A, int x) {\n    int size = (int)A.size();\n    int lb = 0, ub = size - 1;\n    while (lb <= ub) {\n        int mb = lb + (ub - lb)/2;\n        if (A[mb] == x)\n            return mb;\n        else if (A[mb] > x)\n            ub = mb - 1;\n        else\n            lb = mb + 1;\n    }\n    return -1;\n}\n\n//在数组中查找x的上界,即小于等于x的最大值\n//如果有，返回上界\n//如果没有，返回-1\nint upperBound(vector<int> &A, int x) {\n    int size = (int)A.size();\n    int lb = -1, ub = size;\n    while (ub - lb > 1) {\n        int md = lb + (ub - lb) / 2;\n        //如果满足条件，那么符合条件的范围就是[mid,ub)\n        if (A[md] <= x)\n            lb = md;\n        else\n            ub = md;\n    }\n    return lb;\n}\n\n//在数组中查找x的下界,即大于等于x的最小值\n//如果有，返回下界\n//如果没有，返回n\nint lowerBound(vector<int> &A, int x) {\n    int size = (int)A.size();\n    int lb = -1, ub = size;\n    while (ub - lb > 1) {\n        int md = lb + (ub - lb) / 2;\n        //如果满足条件，那么符合条件的范围就是(mid, ub]\n        if (A[md] >= x)\n            ub = md;\n        else\n            lb = md;\n    }\n    return ub;\n}\n\n//10 10 10 20 20 20 30 30\nint main() {\n    int myints[] = {10,20,30,30,20,10,10,20};\n    vector<int> test(myints, myints + 8);\n    sort(test.begin(), test.end());\n    cout<<binarySearch(test, 15)<<endl;\n    cout<<upperBound(test, 38)<<endl;\n    cout<<lowerBound(test, 5)<<endl;\n}\n```","slug":"2014-11-23-binary-search","published":1,"updated":"2015-04-30T13:07:23.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck2b001krwmwms53lgn7"},{"layout":"post","title":"图：Floyd-Warshall算法","date":"2014-11-22T03:40:20.000Z","_content":"\nFloyd-Warshall算法是一种动态规划算法，动规算法的话只要得出递推公式，那么程序就会非常简洁。\n\n这里也不给出算法的递推公式，详见算法导论第25章。\n\n在这里，需要强调的一点就是，动规算法一般是需要辅助的数组来存储中间值的，但是有时我们可以巧妙的利用算法的执行顺序，使用滚动数组就可以避免使用辅助数组。\n\n在这个算法中，我们也并没有使用辅助数组，是因为我们在执行本轮计算的时候，并没有改变本轮所有计算所需要的前一轮的结果。所以我们并不需要一个辅助数组来存储上一轮的值。\n\n``` cpp\n#include <iostream>\nusing namespace std;\n\nconst int MAX_N = 100;\nconst int NIL = -1;\nint G[MAX_N][MAX_N];\nint P[MAX_N][MAX_N];\nint n;\n\n//算法主体\nvoid floydWarshall() {\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                //根据递推公式来更新距离矩阵和路径矩阵\n                if (G[i][j] > G[i][k] + G[k][j]) {\n                    G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n                    P[i][j] = P[k][j];\n                }\n            }\n        }\n    }\n}\n\n//输出两个顶点之间的路径\nvoid printPath(int i, int j) {\n    if (i == j)\n        cout<<i;\n    else if (P[i][j] == NIL)\n        cout<<\"there is no path from \"<<i<<\" to \"<<j<<endl;\n    else {\n        printPath(i, P[i][j]);\n        cout<<\"->\"<<j;\n    }\n}\n\nint main() {\n    /*\n     example input:\n     5\n     0\t3 \t8\t1000\t-4\n     1000\t0\t1000\t1\t7\n     1000\t4\t0\t1000\t1000\n     2\t1000\t-5\t0\t1000\n     1000\t1000\t1000\t6\t0\n     */\n    cin>>n; //输入顶点个数\n    //输入邻接矩阵，同时初始化前驱矩阵\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin>>G[i][j];\n            //初始化前驱矩阵\n            if (i != j && G[i][j] != 1000)\n                P[i][j] = i;\n            else\n                P[i][j] = NIL;\n        }\n    }\n    \n    floydWarshall();\n    \n    cout<<\"result matrix:\"<<endl;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout<<G[i][j]<<\"\\t\";\n        }\n        cout<<endl;\n    }\n    \n    cout<<\"path matrix:\"<<endl;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout<<P[i][j]<<\"\\t\";\n        }\n        cout<<endl;\n    }\n    \n    cout<<\"paths:\"<<endl;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout<<\"\\npath \"<<i<<\" to \"<<j<<\", length is\"<<G[i][j]<<endl;\n            printPath(i, j);\n        }\n    }\n}\n``` \n\n```\n\t5\n\t0\t3 \t8\t1000\t-4\n\t1000\t0\t1000\t1\t7\n\t1000\t4\t0\t1000\t1000\n\t2\t1000\t-5\t0\t1000\n\t1000\t1000\t1000\t6\t0\n\tresult matrix:\n\t0\t1\t-3\t2\t-4\t\n\t3\t0\t-4\t1\t-1\t\n\t7\t4\t0\t5\t3\t\n\t2\t-1\t-5\t0\t-2\t\n\t8\t5\t1\t6\t0\t\n\tpath matrix:\n\t-1\t2\t3\t4\t0\t\n\t3\t-1\t3\t1\t0\t\n\t3\t2\t-1\t1\t0\t\n\t3\t2\t3\t-1\t0\t\n\t3\t2\t3\t4\t-1\t\n\tpaths:\n\n\tpath 0 to 0, length is0\n\t0\n\tpath 0 to 1, length is1\n\t0->4->3->2->1\n\tpath 0 to 2, length is-3\n\t0->4->3->2\n\tpath 0 to 3, length is2\n\t0->4->3\n\tpath 0 to 4, length is-4\n\t0->4\n\tpath 1 to 0, length is3\n\t1->3->0\n\tpath 1 to 1, length is0\n\t1\n\tpath 1 to 2, length is-4\n\t1->3->2\n\tpath 1 to 3, length is1\n\t1->3\n\tpath 1 to 4, length is-1\n\t1->3->0->4\n\tpath 2 to 0, length is7\n\t2->1->3->0\n\tpath 2 to 1, length is4\n\t2->1\n\tpath 2 to 2, length is0\n\t2\n\tpath 2 to 3, length is5\n\t2->1->3\n\tpath 2 to 4, length is3\n\t2->1->3->0->4\n\tpath 3 to 0, length is2\n\t3->0\n\tpath 3 to 1, length is-1\n\t3->2->1\n\tpath 3 to 2, length is-5\n\t3->2\n\tpath 3 to 3, length is0\n\t3\n\tpath 3 to 4, length is-2\n\t3->0->4\n\tpath 4 to 0, length is8\n\t4->3->0\n\tpath 4 to 1, length is5\n\t4->3->2->1\n\tpath 4 to 2, length is1\n\t4->3->2\n\tpath 4 to 3, length is6\n\t4->3\n\tpath 4 to 4, length is0\n\t4\n```","source":"_posts/2014-11-22-floyd-warshall.md","raw":"---\nlayout: post\ntitle:  \"图：Floyd-Warshall算法\"\ndate:   2014-11-22 11:40:20\ncategories:   algorithms\n---\n\nFloyd-Warshall算法是一种动态规划算法，动规算法的话只要得出递推公式，那么程序就会非常简洁。\n\n这里也不给出算法的递推公式，详见算法导论第25章。\n\n在这里，需要强调的一点就是，动规算法一般是需要辅助的数组来存储中间值的，但是有时我们可以巧妙的利用算法的执行顺序，使用滚动数组就可以避免使用辅助数组。\n\n在这个算法中，我们也并没有使用辅助数组，是因为我们在执行本轮计算的时候，并没有改变本轮所有计算所需要的前一轮的结果。所以我们并不需要一个辅助数组来存储上一轮的值。\n\n``` cpp\n#include <iostream>\nusing namespace std;\n\nconst int MAX_N = 100;\nconst int NIL = -1;\nint G[MAX_N][MAX_N];\nint P[MAX_N][MAX_N];\nint n;\n\n//算法主体\nvoid floydWarshall() {\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                //根据递推公式来更新距离矩阵和路径矩阵\n                if (G[i][j] > G[i][k] + G[k][j]) {\n                    G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n                    P[i][j] = P[k][j];\n                }\n            }\n        }\n    }\n}\n\n//输出两个顶点之间的路径\nvoid printPath(int i, int j) {\n    if (i == j)\n        cout<<i;\n    else if (P[i][j] == NIL)\n        cout<<\"there is no path from \"<<i<<\" to \"<<j<<endl;\n    else {\n        printPath(i, P[i][j]);\n        cout<<\"->\"<<j;\n    }\n}\n\nint main() {\n    /*\n     example input:\n     5\n     0\t3 \t8\t1000\t-4\n     1000\t0\t1000\t1\t7\n     1000\t4\t0\t1000\t1000\n     2\t1000\t-5\t0\t1000\n     1000\t1000\t1000\t6\t0\n     */\n    cin>>n; //输入顶点个数\n    //输入邻接矩阵，同时初始化前驱矩阵\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin>>G[i][j];\n            //初始化前驱矩阵\n            if (i != j && G[i][j] != 1000)\n                P[i][j] = i;\n            else\n                P[i][j] = NIL;\n        }\n    }\n    \n    floydWarshall();\n    \n    cout<<\"result matrix:\"<<endl;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout<<G[i][j]<<\"\\t\";\n        }\n        cout<<endl;\n    }\n    \n    cout<<\"path matrix:\"<<endl;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout<<P[i][j]<<\"\\t\";\n        }\n        cout<<endl;\n    }\n    \n    cout<<\"paths:\"<<endl;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout<<\"\\npath \"<<i<<\" to \"<<j<<\", length is\"<<G[i][j]<<endl;\n            printPath(i, j);\n        }\n    }\n}\n``` \n\n```\n\t5\n\t0\t3 \t8\t1000\t-4\n\t1000\t0\t1000\t1\t7\n\t1000\t4\t0\t1000\t1000\n\t2\t1000\t-5\t0\t1000\n\t1000\t1000\t1000\t6\t0\n\tresult matrix:\n\t0\t1\t-3\t2\t-4\t\n\t3\t0\t-4\t1\t-1\t\n\t7\t4\t0\t5\t3\t\n\t2\t-1\t-5\t0\t-2\t\n\t8\t5\t1\t6\t0\t\n\tpath matrix:\n\t-1\t2\t3\t4\t0\t\n\t3\t-1\t3\t1\t0\t\n\t3\t2\t-1\t1\t0\t\n\t3\t2\t3\t-1\t0\t\n\t3\t2\t3\t4\t-1\t\n\tpaths:\n\n\tpath 0 to 0, length is0\n\t0\n\tpath 0 to 1, length is1\n\t0->4->3->2->1\n\tpath 0 to 2, length is-3\n\t0->4->3->2\n\tpath 0 to 3, length is2\n\t0->4->3\n\tpath 0 to 4, length is-4\n\t0->4\n\tpath 1 to 0, length is3\n\t1->3->0\n\tpath 1 to 1, length is0\n\t1\n\tpath 1 to 2, length is-4\n\t1->3->2\n\tpath 1 to 3, length is1\n\t1->3\n\tpath 1 to 4, length is-1\n\t1->3->0->4\n\tpath 2 to 0, length is7\n\t2->1->3->0\n\tpath 2 to 1, length is4\n\t2->1\n\tpath 2 to 2, length is0\n\t2\n\tpath 2 to 3, length is5\n\t2->1->3\n\tpath 2 to 4, length is3\n\t2->1->3->0->4\n\tpath 3 to 0, length is2\n\t3->0\n\tpath 3 to 1, length is-1\n\t3->2->1\n\tpath 3 to 2, length is-5\n\t3->2\n\tpath 3 to 3, length is0\n\t3\n\tpath 3 to 4, length is-2\n\t3->0->4\n\tpath 4 to 0, length is8\n\t4->3->0\n\tpath 4 to 1, length is5\n\t4->3->2->1\n\tpath 4 to 2, length is1\n\t4->3->2\n\tpath 4 to 3, length is6\n\t4->3\n\tpath 4 to 4, length is0\n\t4\n```","slug":"2014-11-22-floyd-warshall","published":1,"updated":"2015-04-30T13:07:50.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck2d001nrwmwua2vosmm"},{"layout":"post","title":"重建二叉树","date":"2014-11-21T10:08:20.000Z","_content":"\n重建二叉树就是给定二叉树的两种遍历的结果，比如前序遍历，中序遍历，然后根据这两种遍历结果来重建二叉树。\n\n比如说给定一个二叉树\n\n+ 前序遍历：$[1, 2, 4, 5, 3, 6, 7]$\n+ 中序遍历：$[4, 2, 5, 1, 6, 3, 7]$\n\n然后根据这两个遍历结果重建二叉树。\n\n重建二叉树的思想很简单，比如说根据前序遍历的结果，我们能够知道$1$为树的根节点，但是我们不能知道它的两个子树是哪些节点；但是根据中序遍历，我们就知道，在根节点左边的为左子树，根节点右边的为右子树，所以左子树为$[4,2,5]$,右子树为$[6, 3, 7]$.然后我们再递归的重建两个子树就可以了。\n\n代码实现如下，方法很简单，但是值得学习的就是在这两个方法中迭代器的漂亮使用以及代码的精简实现。\n\n###根据前序遍历和中序遍历的结果构建二叉树\n\n``` cpp\nclass Solution {\npublic:\n    TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {\n        return buildTree(begin(preorder), end(preorder),\n                         begin(inorder), end(inorder));\n    }\n    \n    template <typename InputIterator>\n    TreeNode *buildTree(InputIterator pre_first, InputIterator pre_last,\n                        InputIterator in_first, InputIterator in_last) {\n     \n        //如果序列中已经没有元素,那么返回空指针\n        if (pre_first == pre_last) return nullptr;\n        if (in_first == in_last) return nullptr;\n        \n        auto root = new TreeNode(*pre_first);\n        auto in_root_pos = find(in_first, in_last, *pre_first);\n        auto left_size = distance(in_first, in_root_pos);\n        \n        //在这里需要注意的是，序列的范围都是一个左闭右开的区间，即[first, last),\n        root->left = buildTree(next(pre_first), next(pre_first, left_size + 1),\n                               in_first, in_root_pos);\n        \n        root->right = buildTree(next(pre_first, left_size + 1),\n                                pre_last, next(in_root_pos), in_last);\n        \n        return root;\n    }\n};\n```\n\n###根据中序遍历和后序遍历的结果构建二叉树\n``` cpp\nclass Solution {\npublic:\n    TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {\n        return buildTree(begin(inorder), end(inorder),\n                         begin(postorder), end(postorder));\n    }\n    \n    template <typename InputIterator>\n    TreeNode *buildTree(InputIterator in_first, InputIterator in_last,\n                        InputIterator post_first, InputIterator post_last) {\n     \n        //如果序列中已经没有元素,那么返回空指针\n        if (in_first == in_last) return nullptr;\n        if (post_first == post_last) return nullptr;\n        \n        auto val = *prev(post_last);\n        auto root = new TreeNode(val);\n        auto in_root_pos = find(in_first, in_last, val);\n        auto left_size = distance(in_first, in_root_pos);\n        auto post_left_last = next(post_first, left_size);\n        \n        //在这里需要注意的是，序列的范围都是一个左闭右开的区间，即[first, last),\n        root->left = buildTree(in_first, in_root_pos,\n                               post_first, post_left_last);\n        \n        root->right = buildTree(next(in_root_pos), in_last,\n                                post_left_last, prev(post_last));\n        \n        return root;\n    }\n};\n```","source":"_posts/2014-11-21-rebuild-binary-tree.md","raw":"---\nlayout: post\ntitle:  \"重建二叉树\"\ndate:   2014-11-21 18:08:20\ncategories:   algorithms\ntags: [二叉树]\n---\n\n重建二叉树就是给定二叉树的两种遍历的结果，比如前序遍历，中序遍历，然后根据这两种遍历结果来重建二叉树。\n\n比如说给定一个二叉树\n\n+ 前序遍历：$[1, 2, 4, 5, 3, 6, 7]$\n+ 中序遍历：$[4, 2, 5, 1, 6, 3, 7]$\n\n然后根据这两个遍历结果重建二叉树。\n\n重建二叉树的思想很简单，比如说根据前序遍历的结果，我们能够知道$1$为树的根节点，但是我们不能知道它的两个子树是哪些节点；但是根据中序遍历，我们就知道，在根节点左边的为左子树，根节点右边的为右子树，所以左子树为$[4,2,5]$,右子树为$[6, 3, 7]$.然后我们再递归的重建两个子树就可以了。\n\n代码实现如下，方法很简单，但是值得学习的就是在这两个方法中迭代器的漂亮使用以及代码的精简实现。\n\n###根据前序遍历和中序遍历的结果构建二叉树\n\n``` cpp\nclass Solution {\npublic:\n    TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {\n        return buildTree(begin(preorder), end(preorder),\n                         begin(inorder), end(inorder));\n    }\n    \n    template <typename InputIterator>\n    TreeNode *buildTree(InputIterator pre_first, InputIterator pre_last,\n                        InputIterator in_first, InputIterator in_last) {\n     \n        //如果序列中已经没有元素,那么返回空指针\n        if (pre_first == pre_last) return nullptr;\n        if (in_first == in_last) return nullptr;\n        \n        auto root = new TreeNode(*pre_first);\n        auto in_root_pos = find(in_first, in_last, *pre_first);\n        auto left_size = distance(in_first, in_root_pos);\n        \n        //在这里需要注意的是，序列的范围都是一个左闭右开的区间，即[first, last),\n        root->left = buildTree(next(pre_first), next(pre_first, left_size + 1),\n                               in_first, in_root_pos);\n        \n        root->right = buildTree(next(pre_first, left_size + 1),\n                                pre_last, next(in_root_pos), in_last);\n        \n        return root;\n    }\n};\n```\n\n###根据中序遍历和后序遍历的结果构建二叉树\n``` cpp\nclass Solution {\npublic:\n    TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {\n        return buildTree(begin(inorder), end(inorder),\n                         begin(postorder), end(postorder));\n    }\n    \n    template <typename InputIterator>\n    TreeNode *buildTree(InputIterator in_first, InputIterator in_last,\n                        InputIterator post_first, InputIterator post_last) {\n     \n        //如果序列中已经没有元素,那么返回空指针\n        if (in_first == in_last) return nullptr;\n        if (post_first == post_last) return nullptr;\n        \n        auto val = *prev(post_last);\n        auto root = new TreeNode(val);\n        auto in_root_pos = find(in_first, in_last, val);\n        auto left_size = distance(in_first, in_root_pos);\n        auto post_left_last = next(post_first, left_size);\n        \n        //在这里需要注意的是，序列的范围都是一个左闭右开的区间，即[first, last),\n        root->left = buildTree(in_first, in_root_pos,\n                               post_first, post_left_last);\n        \n        root->right = buildTree(next(in_root_pos), in_last,\n                                post_left_last, prev(post_last));\n        \n        return root;\n    }\n};\n```","slug":"2014-11-21-rebuild-binary-tree","published":1,"updated":"2015-05-04T13:48:16.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck2g001prwmwcshtxra3"},{"layout":"post","title":"二分搜索: Insert Interval","date":"2014-11-20T09:40:20.000Z","_content":"\n<a href=\"https://oj.leetcode.com/problems/insert-interval/\">Insert Interval</a>\n\nGiven a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).\n\nYou may assume that the intervals were initially sorted according to their start times.\n\nExample 1:\n\nGiven intervals $[1,3],[6,9]$, insert and merge $[2,5]$ in as $[1,5],[6,9]$.\n\nExample 2:\n\nGiven $[1,2],[3,5],[6,7],[8,10],[12,16]$, insert and merge $[4,9]$ in as $[1,2],[3,10],[12,16]$.\n\nThis is because the new interval $[4,9]$ overlaps with $[3,5],[6,7],[8,10]$.\n\n###分析:\n\n这个题算是一个很典型的二分搜索的题，但是首先我们要明确到底我们需要查找的什么。\n\n比如举个最简单的例子：\n\n我们要在$[4,5],[8,9],[12,13]$里插入一个$[6,7]$，那么我们需要找的是在intervals中interval.end小于newInerval.start的最大值，也就是第一个；同时我们还需要找出在intervals中interval.start大于newInterval.end的最小值，也就是第二个。所以我们就知道我们要插入的地方就是第一个和第二个之间。但是在这里，我们又需要注意还有两个小问题，就是newInterval.start可能要大于后一个的end，而newInterval.end可能又会小于前一个的start。\n\n还有一个需要注意的就是在这个题中所用的二分搜索的方法，由于我们这里不精确求一个等于某个数值的位置，所以就不能像以前的二分查找一样。我们这里查找的是一个半闭半开的区间。\n\n如果熟悉了这里的两个查找，那么二分查找基本上算了解了。\n\n``` cpp\n/**\n * Definition for an interval.\n * struct Interval {\n *     int start;\n *     int end;\n *     Interval() : start(0), end(0) {}\n *     Interval(int s, int e) : start(s), end(e) {}\n * };\n */\nclass Solution {\npublic:\n    vector<Interval> insert(vector<Interval> &intervals, Interval newInterval) {\n        vector<Interval> result;\n        if (intervals.size() == 0) {\n            result.push_back(newInterval);\n            return result;\n        }\n        int left = searchRight(intervals, newInterval.start);   //找出小于start的最大值\n        int right = searchLeft(intervals, newInterval.end);    //找出大于end的最小值\n        \n        int start = newInterval.start;\n        int end = newInterval.end;\n\n        int tmp_start = start, tmp_end = end;\n        if ((left + 1) < intervals.size() && start >= intervals[left + 1].start) \n            tmp_start = intervals[left + 1].start;\n        if ((right - 1) >= 0 && end <= intervals[right - 1].end) \n            tmp_end = intervals[right - 1].end;\n        Interval tmp(tmp_start, tmp_end);\n        result.push_back(tmp);\n        \n        for (int i = 0; i <= left; i++)\n            result.push_back(intervals[i]);\n\n        for (int i = right; i < intervals.size(); i++) \n            result.push_back(intervals[i]);\n        \n        return result;\n    }\n    \n    //找出intervals中interval.start大于val的最小值\n    int searchLeft(vector<Interval> &intervals, int val) {\n        int start = -1, end = intervals.size();\n        while (end - start > 1) {\n            int mid = start + (end - start)/2;\n            if (intervals[mid].start > val) {\n            \t//如果mid满足条件，那么解的存在范围为(start, mid]\n                end = mid;\n            } else {\n            \t//如果mid不满足条件，那么解的存在范围为(mid, end]\n                start = mid;\n            }\n        }\n        return end;\n    }\n    \n    //找出intervals中interval.end小于val的最大值\n    int searchRight(vector<Interval> &intervals, int val) {\n        int start = -1, end = intervals.size();\n        while (end - start > 1) {\n            int mid = start + (end - start)/2;\n            if (intervals[mid].end < val) {\n            \t//如果mid满足条件，那么解的存在范围为[mid, end)\n                start = mid;\n            } else {\n            \t//如果mid不满足条件，那么解的存在范围为[start, mid)\n                end = mid;\n            }\n        }\n        return start;\n    }\n};\n```","source":"_posts/2014-11-20-leetcode-insert-intervals.md","raw":"---\nlayout: post\ntitle:  \"二分搜索: Insert Interval\"\ndate:   2014-11-20 17:40:20\ncategories: problems\n---\n\n<a href=\"https://oj.leetcode.com/problems/insert-interval/\">Insert Interval</a>\n\nGiven a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).\n\nYou may assume that the intervals were initially sorted according to their start times.\n\nExample 1:\n\nGiven intervals $[1,3],[6,9]$, insert and merge $[2,5]$ in as $[1,5],[6,9]$.\n\nExample 2:\n\nGiven $[1,2],[3,5],[6,7],[8,10],[12,16]$, insert and merge $[4,9]$ in as $[1,2],[3,10],[12,16]$.\n\nThis is because the new interval $[4,9]$ overlaps with $[3,5],[6,7],[8,10]$.\n\n###分析:\n\n这个题算是一个很典型的二分搜索的题，但是首先我们要明确到底我们需要查找的什么。\n\n比如举个最简单的例子：\n\n我们要在$[4,5],[8,9],[12,13]$里插入一个$[6,7]$，那么我们需要找的是在intervals中interval.end小于newInerval.start的最大值，也就是第一个；同时我们还需要找出在intervals中interval.start大于newInterval.end的最小值，也就是第二个。所以我们就知道我们要插入的地方就是第一个和第二个之间。但是在这里，我们又需要注意还有两个小问题，就是newInterval.start可能要大于后一个的end，而newInterval.end可能又会小于前一个的start。\n\n还有一个需要注意的就是在这个题中所用的二分搜索的方法，由于我们这里不精确求一个等于某个数值的位置，所以就不能像以前的二分查找一样。我们这里查找的是一个半闭半开的区间。\n\n如果熟悉了这里的两个查找，那么二分查找基本上算了解了。\n\n``` cpp\n/**\n * Definition for an interval.\n * struct Interval {\n *     int start;\n *     int end;\n *     Interval() : start(0), end(0) {}\n *     Interval(int s, int e) : start(s), end(e) {}\n * };\n */\nclass Solution {\npublic:\n    vector<Interval> insert(vector<Interval> &intervals, Interval newInterval) {\n        vector<Interval> result;\n        if (intervals.size() == 0) {\n            result.push_back(newInterval);\n            return result;\n        }\n        int left = searchRight(intervals, newInterval.start);   //找出小于start的最大值\n        int right = searchLeft(intervals, newInterval.end);    //找出大于end的最小值\n        \n        int start = newInterval.start;\n        int end = newInterval.end;\n\n        int tmp_start = start, tmp_end = end;\n        if ((left + 1) < intervals.size() && start >= intervals[left + 1].start) \n            tmp_start = intervals[left + 1].start;\n        if ((right - 1) >= 0 && end <= intervals[right - 1].end) \n            tmp_end = intervals[right - 1].end;\n        Interval tmp(tmp_start, tmp_end);\n        result.push_back(tmp);\n        \n        for (int i = 0; i <= left; i++)\n            result.push_back(intervals[i]);\n\n        for (int i = right; i < intervals.size(); i++) \n            result.push_back(intervals[i]);\n        \n        return result;\n    }\n    \n    //找出intervals中interval.start大于val的最小值\n    int searchLeft(vector<Interval> &intervals, int val) {\n        int start = -1, end = intervals.size();\n        while (end - start > 1) {\n            int mid = start + (end - start)/2;\n            if (intervals[mid].start > val) {\n            \t//如果mid满足条件，那么解的存在范围为(start, mid]\n                end = mid;\n            } else {\n            \t//如果mid不满足条件，那么解的存在范围为(mid, end]\n                start = mid;\n            }\n        }\n        return end;\n    }\n    \n    //找出intervals中interval.end小于val的最大值\n    int searchRight(vector<Interval> &intervals, int val) {\n        int start = -1, end = intervals.size();\n        while (end - start > 1) {\n            int mid = start + (end - start)/2;\n            if (intervals[mid].end < val) {\n            \t//如果mid满足条件，那么解的存在范围为[mid, end)\n                start = mid;\n            } else {\n            \t//如果mid不满足条件，那么解的存在范围为[start, mid)\n                end = mid;\n            }\n        }\n        return start;\n    }\n};\n```","slug":"2014-11-20-leetcode-insert-intervals","published":1,"updated":"2015-04-30T13:08:14.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck2j001trwmwzew3ebhz"},{"layout":"post","title":"最大流: Edmonds-Karp算法","date":"2014-11-20T07:03:20.000Z","_content":"\n\nEdmonds-Karp算法是Ford-Fulkerson算法的一种实现，时间复杂度为$O(VE^2)$.\n\n思想就是每次在源点和终点之间都找出一条增广路径，然后根据这条增广路径的容量计算图的残留网络，继续在残留网络上找增广路径，直至找不出增广路径为止，最后得到的增广路径的和即为图的最大流。\n\n\n![trie1](/img/edmonds_karp_1.png)\n\n代码实现入下：\n\n``` cpp\n\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <math.h>\n\nusing namespace std;\n\nconst int MAX_NODE = 100; //最大顶点数\n\nint capacities[MAX_NODE][MAX_NODE]; //网络容量\nint flow[MAX_NODE][MAX_NODE];       //网络流\nint parent[MAX_NODE];               //路径\nint pathCapacity[MAX_NODE];         //路径上的容量\nvector<int> graph[MAX_NODE];        //图的邻接表示\n\nint bfs(int start, int sink){\n    //初始化路径数组和路径容量数组\n    fill(parent, parent + MAX_NODE, -1);\n    fill(pathCapacity, pathCapacity + MAX_NODE, 0);\n    \n    queue<int> q;\n    q.push(start);\n    \n    pathCapacity[start] = INT_MAX;  //设置源点容量\n    \n    while (!q.empty()) {\n        int current = q.front();\n        q.pop();\n        \n        for (int i = 0; i < graph[current].size(); i++) {\n            int to = graph[current][i];\n            \n            //如果邻接节点还没有被访问过且残留路径大于零\n            if (parent[to] == - 1\n                && capacities[current][to] - flow[current][to] > 0) {\n                \n                parent[to] = current;\n                pathCapacity[to] = min(pathCapacity[current],\n                                       capacities[current][to] - flow[current][to]);\n                \n                //如果已经到达终点，那么已经找到了一条路径，返回路径的容量\n                if (to == sink)\n                    return pathCapacity[to];\n                //否则将当前访问节点加入队列\n                q.push(to);\n            }\n        }\n    }\n    return 0;\n}\n\nint edmondsKarp(int start, int sink) {\n    int maxFlow = 0;\n    while (true) {\n        //使用BFS算法先找出一条路径，并且得到路径的容量\n        int cap = bfs(start, sink);\n        //如果路径容量为零，则说明没有增广路径了，跳出循环\n        if (cap == 0)\n            break;\n        \n        //最大流加上路径的容量\n        maxFlow += cap;\n        \n        //根据BFS得到的路径，计算网络流\n        int current = sink;\n        while (current != start) {\n            int previous = parent[current];\n            flow[previous][current] += cap;\n            flow[current][previous] = -flow[previous][current];\n            current = previous;\n        }\n    }\n    return maxFlow;\n}\n\nint main() {\n    \n    /*\n     example input:算导p405\n     \n     6 10\n     0 3\n     0 1 16\n     1 2 12\n     2 3 20\n     1 5 10\n     5 1 4\n     2 5 9\n     4 2 7\n     0 5 13\n     5 4 14\n     4 3 4\n     */\n    int nodesCount, edgesCount;\n    cin>>nodesCount>>edgesCount;\n    int source, sink;\n    cin>>source>>sink;\n    \n    for(int edge=0; edge<edgesCount; edge++)\n    {\n        int from, to, capacity;\n        cin>>from>>to>>capacity;\n        capacities[from][to]=capacity;\n        graph[from].push_back(to);\n    }\n    int maxFlow = edmondsKarp(source, sink);\n    cout<<maxFlow<<endl;\n}\n```","source":"_posts/2014-11-20-edmonds-karp.md","raw":"---\nlayout: post\ntitle:  \"最大流: Edmonds-Karp算法\"\ndate:   2014-11-20 15:03:20\ncategories:   algorithms\n---\n\n\nEdmonds-Karp算法是Ford-Fulkerson算法的一种实现，时间复杂度为$O(VE^2)$.\n\n思想就是每次在源点和终点之间都找出一条增广路径，然后根据这条增广路径的容量计算图的残留网络，继续在残留网络上找增广路径，直至找不出增广路径为止，最后得到的增广路径的和即为图的最大流。\n\n\n![trie1](/img/edmonds_karp_1.png)\n\n代码实现入下：\n\n``` cpp\n\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <math.h>\n\nusing namespace std;\n\nconst int MAX_NODE = 100; //最大顶点数\n\nint capacities[MAX_NODE][MAX_NODE]; //网络容量\nint flow[MAX_NODE][MAX_NODE];       //网络流\nint parent[MAX_NODE];               //路径\nint pathCapacity[MAX_NODE];         //路径上的容量\nvector<int> graph[MAX_NODE];        //图的邻接表示\n\nint bfs(int start, int sink){\n    //初始化路径数组和路径容量数组\n    fill(parent, parent + MAX_NODE, -1);\n    fill(pathCapacity, pathCapacity + MAX_NODE, 0);\n    \n    queue<int> q;\n    q.push(start);\n    \n    pathCapacity[start] = INT_MAX;  //设置源点容量\n    \n    while (!q.empty()) {\n        int current = q.front();\n        q.pop();\n        \n        for (int i = 0; i < graph[current].size(); i++) {\n            int to = graph[current][i];\n            \n            //如果邻接节点还没有被访问过且残留路径大于零\n            if (parent[to] == - 1\n                && capacities[current][to] - flow[current][to] > 0) {\n                \n                parent[to] = current;\n                pathCapacity[to] = min(pathCapacity[current],\n                                       capacities[current][to] - flow[current][to]);\n                \n                //如果已经到达终点，那么已经找到了一条路径，返回路径的容量\n                if (to == sink)\n                    return pathCapacity[to];\n                //否则将当前访问节点加入队列\n                q.push(to);\n            }\n        }\n    }\n    return 0;\n}\n\nint edmondsKarp(int start, int sink) {\n    int maxFlow = 0;\n    while (true) {\n        //使用BFS算法先找出一条路径，并且得到路径的容量\n        int cap = bfs(start, sink);\n        //如果路径容量为零，则说明没有增广路径了，跳出循环\n        if (cap == 0)\n            break;\n        \n        //最大流加上路径的容量\n        maxFlow += cap;\n        \n        //根据BFS得到的路径，计算网络流\n        int current = sink;\n        while (current != start) {\n            int previous = parent[current];\n            flow[previous][current] += cap;\n            flow[current][previous] = -flow[previous][current];\n            current = previous;\n        }\n    }\n    return maxFlow;\n}\n\nint main() {\n    \n    /*\n     example input:算导p405\n     \n     6 10\n     0 3\n     0 1 16\n     1 2 12\n     2 3 20\n     1 5 10\n     5 1 4\n     2 5 9\n     4 2 7\n     0 5 13\n     5 4 14\n     4 3 4\n     */\n    int nodesCount, edgesCount;\n    cin>>nodesCount>>edgesCount;\n    int source, sink;\n    cin>>source>>sink;\n    \n    for(int edge=0; edge<edgesCount; edge++)\n    {\n        int from, to, capacity;\n        cin>>from>>to>>capacity;\n        capacities[from][to]=capacity;\n        graph[from].push_back(to);\n    }\n    int maxFlow = edmondsKarp(source, sink);\n    cout<<maxFlow<<endl;\n}\n```","slug":"2014-11-20-edmonds-karp","published":1,"updated":"2015-04-30T13:08:32.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck2l001vrwmwsqm4k773"},{"layout":"post","title":"数据结构：线段树(segment tree)","date":"2014-11-18T02:39:20.000Z","mathjax":true,"_content":"\n###线段树的概念\n\n线段树是擅长处理区间的，形如下图的数据结构。线段树是一棵完美二叉树（Perfect Binary Tree)（所有的叶子的深度都相同，并且每个节点要么是叶子要么有2个儿子的树）树上的每个节点都维护一个区间。根维护的是整个区间，每个节点维护的是父亲的区间二等分后的其中一个子区间。当有$n$个元素时，对区间的操作可以在$O(\\log{n})$的时间内完成。\n\n![segment tree 1](/img/segment_tree_1.png)\n\n根据节点中维护的数据不同，线段树可以提供不同的功能。比如说可以实现Range Mininum Query(RMQ)操作的线段树。\n\n###基于线段树的RMQ结构\n\n下面要建立的线段树在给定数列 $a _0$, $a_1$, ... ,$a^{n-1}$的情况下，可以在$O(\\log{n})$ 时间内完成如下两种操作\n\n+ 给定$s$和$t$，求$a_s$,$a^{s+1}$,...,$a_t$的最小值\n+ 给定$i$和$x$，把$a_i$的值改成$x$\n\n如图，线段树的每个节点维护对应区间的最下值。在建树时，只要按从下到上的顺序分别取左右儿子的值中的较小值就可以了。\n\n![segment tree 1](/img/segment_tree_2.png)\n\n###基于线段树的RMQ的查询\n\n如果要求$a_0,...,a_6$的最小值，我们只需要求下图中的三个节点的值的最小值即可。\n\n![segment tree 1](/img/segment_tree_3.png)\n\n像这样，即使查询的是一个比较大的区间，由于较靠上的节点对应较大的区间，通过这些瓯可以知道大部分值的最小值，从而只需要访问很少的节点就可以求得最小值。\n\n要求某个区间的最小值，像下面这样递归处理就可以了。\n\n+ 如果所查询的区间和当前节点对应的区间完全没有交集，那么就返回一个不影响答案的值，例如INT_MAX\n+ 如果所查询的区间完全包含了当前节点对应的区间，那么就返回当前节点的值\n+ 以上两种情况都不满足的话，就对两个儿子递归处理，返回两个结果中的较小者。\n\n###基于线段树的RMQ的值的更新\n在更新$a_0$的值时，需要重新计算下图所示的4个节点的值。\n\n![segment tree 1](/img/segment_tree_4.png)\n\n在更新$a_i$的值时，需要对包含的所有区间对应的节点的值重新进行计算。在更新时，可以从下面的节点开始向上不断更新，把每个节点的值更新为左右两个儿子的值的较小者就可以了。\n\n###基于线段树的RMQ的复杂度\n不论哪种操作对于每个深度都最多访问常数个节点。因此对于$n$个元素，每一次操作的复杂度是$O(\\log{n})$。对于二叉搜索树，我们曾经提到过可能有因操作不当而导致退化的情况发生，从而钱剁更这是很糟糕。不过因为线段树不会添加或者删除节点，所以即使是朴素的实现也都能在$O(\\log{n})$时间内进行各种操作。\n\n此外，$n$个元素的线段树的初始化的时间复杂度和总的空间复杂度都是$O(n)$。这是因为节点数是$n+n/2+n/4+...=2n-1$。直觉上很容易1以产生复杂度是$O(n\\log{n})$的错觉，需要注意。\n\n\n>$n+n/2+n/4+...=2n-1$的证明\n><hr>\n>\n>$\\because$ $1+2^1+2^2+...2^k=2^{k+1}-1=2\\cdot2^k-1$(等比数列求和公式)而且$n=2^k$\n>\n>$\\therefore$ $1+2+...n=1+2^1+2^2+...2^k=2n-1$\n\n###基于线段树的RMQ的实现\n为了简单起见，在建立线段树时，把数列所有的值都初始化为INT_MAX。此外，query的参数中不止传入节点的编号，还传入了节点对应的区间。虽然从节点的编号也可以计算出对应的区间但是把区间作为参数传入就可以节省这一步计算，为了简单起见，我们在实现中传入了对应的区间。\n\n``` cpp\n#include <iostream>\n#include <math.h>\n\nusing namespace std;\n\nconst int MAX_N = 1 << 17;\n\nint n, tree[2 * MAX_N - 1];\n\nvoid init(int n_) {\n    //将元素个数扩大到2的幂,这样的话，就能够保证是\n    //完美二叉树\n    n = 1;\n    while (n < n_)\n        n *= 2;\n    \n    //初始化\n    for (int i = 0; i < n; i++)\n        tree[i] = INT_MAX;\n}\n\nvoid update(int k, int a) {\n    //根据公式，第k个叶子节点的下标\n    k += n - 1;\n    tree[k] = a;\n    \n    while (k > 0) {\n        k = (k - 1) / 2;\n        tree[k] = min(tree[k * 2 + 1], tree[k * 2 + 2]);\n     }\n}\n\n/*\n在这种求区间范围的题中，开区间和闭区间还是很重要的，\n在这里，求的是左闭右开区间的值，所以在两个子查询中\n就不用进行加一操作了\n*/\n\n//求[a, b)的最小值,\n//后面的参数是为了计算起来方便而传入的\n//k是节点的编号，l，r表示这个节点对应的是[l, r)区间。\n//在外部调用时，使用query(a, b, 0, 0, n)\n\nint query(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return INT_MAX;\n    \n    if (a <= l && r <= b) return tree[k];\n    else {\n        int vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        int vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n}\n```","source":"_posts/2014-11-18-segment-tree.md","raw":"---\nlayout: post\ntitle:  \"数据结构：线段树(segment tree)\"\ndate:   2014-11-18 10:39:20\ncategories:   algorithms\nmathjax: true\n---\n\n###线段树的概念\n\n线段树是擅长处理区间的，形如下图的数据结构。线段树是一棵完美二叉树（Perfect Binary Tree)（所有的叶子的深度都相同，并且每个节点要么是叶子要么有2个儿子的树）树上的每个节点都维护一个区间。根维护的是整个区间，每个节点维护的是父亲的区间二等分后的其中一个子区间。当有$n$个元素时，对区间的操作可以在$O(\\log{n})$的时间内完成。\n\n![segment tree 1](/img/segment_tree_1.png)\n\n根据节点中维护的数据不同，线段树可以提供不同的功能。比如说可以实现Range Mininum Query(RMQ)操作的线段树。\n\n###基于线段树的RMQ结构\n\n下面要建立的线段树在给定数列 $a _0$, $a_1$, ... ,$a^{n-1}$的情况下，可以在$O(\\log{n})$ 时间内完成如下两种操作\n\n+ 给定$s$和$t$，求$a_s$,$a^{s+1}$,...,$a_t$的最小值\n+ 给定$i$和$x$，把$a_i$的值改成$x$\n\n如图，线段树的每个节点维护对应区间的最下值。在建树时，只要按从下到上的顺序分别取左右儿子的值中的较小值就可以了。\n\n![segment tree 1](/img/segment_tree_2.png)\n\n###基于线段树的RMQ的查询\n\n如果要求$a_0,...,a_6$的最小值，我们只需要求下图中的三个节点的值的最小值即可。\n\n![segment tree 1](/img/segment_tree_3.png)\n\n像这样，即使查询的是一个比较大的区间，由于较靠上的节点对应较大的区间，通过这些瓯可以知道大部分值的最小值，从而只需要访问很少的节点就可以求得最小值。\n\n要求某个区间的最小值，像下面这样递归处理就可以了。\n\n+ 如果所查询的区间和当前节点对应的区间完全没有交集，那么就返回一个不影响答案的值，例如INT_MAX\n+ 如果所查询的区间完全包含了当前节点对应的区间，那么就返回当前节点的值\n+ 以上两种情况都不满足的话，就对两个儿子递归处理，返回两个结果中的较小者。\n\n###基于线段树的RMQ的值的更新\n在更新$a_0$的值时，需要重新计算下图所示的4个节点的值。\n\n![segment tree 1](/img/segment_tree_4.png)\n\n在更新$a_i$的值时，需要对包含的所有区间对应的节点的值重新进行计算。在更新时，可以从下面的节点开始向上不断更新，把每个节点的值更新为左右两个儿子的值的较小者就可以了。\n\n###基于线段树的RMQ的复杂度\n不论哪种操作对于每个深度都最多访问常数个节点。因此对于$n$个元素，每一次操作的复杂度是$O(\\log{n})$。对于二叉搜索树，我们曾经提到过可能有因操作不当而导致退化的情况发生，从而钱剁更这是很糟糕。不过因为线段树不会添加或者删除节点，所以即使是朴素的实现也都能在$O(\\log{n})$时间内进行各种操作。\n\n此外，$n$个元素的线段树的初始化的时间复杂度和总的空间复杂度都是$O(n)$。这是因为节点数是$n+n/2+n/4+...=2n-1$。直觉上很容易1以产生复杂度是$O(n\\log{n})$的错觉，需要注意。\n\n\n>$n+n/2+n/4+...=2n-1$的证明\n><hr>\n>\n>$\\because$ $1+2^1+2^2+...2^k=2^{k+1}-1=2\\cdot2^k-1$(等比数列求和公式)而且$n=2^k$\n>\n>$\\therefore$ $1+2+...n=1+2^1+2^2+...2^k=2n-1$\n\n###基于线段树的RMQ的实现\n为了简单起见，在建立线段树时，把数列所有的值都初始化为INT_MAX。此外，query的参数中不止传入节点的编号，还传入了节点对应的区间。虽然从节点的编号也可以计算出对应的区间但是把区间作为参数传入就可以节省这一步计算，为了简单起见，我们在实现中传入了对应的区间。\n\n``` cpp\n#include <iostream>\n#include <math.h>\n\nusing namespace std;\n\nconst int MAX_N = 1 << 17;\n\nint n, tree[2 * MAX_N - 1];\n\nvoid init(int n_) {\n    //将元素个数扩大到2的幂,这样的话，就能够保证是\n    //完美二叉树\n    n = 1;\n    while (n < n_)\n        n *= 2;\n    \n    //初始化\n    for (int i = 0; i < n; i++)\n        tree[i] = INT_MAX;\n}\n\nvoid update(int k, int a) {\n    //根据公式，第k个叶子节点的下标\n    k += n - 1;\n    tree[k] = a;\n    \n    while (k > 0) {\n        k = (k - 1) / 2;\n        tree[k] = min(tree[k * 2 + 1], tree[k * 2 + 2]);\n     }\n}\n\n/*\n在这种求区间范围的题中，开区间和闭区间还是很重要的，\n在这里，求的是左闭右开区间的值，所以在两个子查询中\n就不用进行加一操作了\n*/\n\n//求[a, b)的最小值,\n//后面的参数是为了计算起来方便而传入的\n//k是节点的编号，l，r表示这个节点对应的是[l, r)区间。\n//在外部调用时，使用query(a, b, 0, 0, n)\n\nint query(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return INT_MAX;\n    \n    if (a <= l && r <= b) return tree[k];\n    else {\n        int vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        int vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n}\n```","slug":"2014-11-18-segment-tree","published":1,"updated":"2015-04-30T13:06:32.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck2m001xrwmwuhlyr0v8"},{"layout":"post","title":"素数","date":"2014-11-15T03:01:20.000Z","math":true,"_content":"\n### 判断一个数是否为素数\n\n很容易想到，我们只要把$2\\rightarrow n-1$遍历一遍，就可以得到一个数是否为素数。但是这样的话时间复杂度将会是O(n).再想想其实我们可以只遍历$2\\rightarrow n/2$，但是这样还是$O(n)$.\n\n那么假设d是n的约数，那么n/d也是n的约数，$$n = d * n/d$$;可以看出$min(d, n/d) \\leq \\sqrt{n}$,所以只要检查$2\\rightarrow\\sqrt{n}$的所有整数就够了，因此能够在$O(\\sqrt{n})$的时间内完成。\n\n``` cpp\nbool is_prime(int n) {\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return n != 1; //1既不是素数也不是合数\n}\n```\n\n### 埃氏筛法\n\n> 给定整数n，请问n以内有多少个素数？\n\n如果对每一个数都进行素性测试，那么复杂度就高了。所以就有了这个解法。\n\n首先，将2到范围内的所有整数写下来。其中最小的数字2是素数。将表中所有2的倍数都划去表中剩余的最小数字是3它不能被更小的数整除，所以是素数。再将表中所有3的倍数都划去依此类推，如果表中剩余的最小数字是m时，m就是素数。然后将表中所有m的倍数都划去。像这样反复操作，就能依次枚举n以内的素数。\n\n``` cpp\nconst int MAX_N = 10e6;\nint prime[MAX_N];\nbool is_prime[MAX_N + 1];\n\nint sieve(int n) {\n    int p = 0;\n    for (int i = 0; i<= n; i++) is_prime[i] = true;\n    is_prime[0] = is_prime[1] = false;\n    \n    for (int i = 2; i <= n; i++) {\n        if (is_prime[i]) {\n            prime[p++] = i;\n            for (int j = 2 * i; j <= n; j += i) is_prime[j] = false;\n        }\n    }\n    return p;\n}\n```","source":"_posts/2014-11-15-math-prime.md","raw":"---\nlayout: post\ntitle:  \"素数\"\ndate:   2014-11-15 11:01:20\ncategories:   algorithms\nmath: true\n---\n\n### 判断一个数是否为素数\n\n很容易想到，我们只要把$2\\rightarrow n-1$遍历一遍，就可以得到一个数是否为素数。但是这样的话时间复杂度将会是O(n).再想想其实我们可以只遍历$2\\rightarrow n/2$，但是这样还是$O(n)$.\n\n那么假设d是n的约数，那么n/d也是n的约数，$$n = d * n/d$$;可以看出$min(d, n/d) \\leq \\sqrt{n}$,所以只要检查$2\\rightarrow\\sqrt{n}$的所有整数就够了，因此能够在$O(\\sqrt{n})$的时间内完成。\n\n``` cpp\nbool is_prime(int n) {\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return n != 1; //1既不是素数也不是合数\n}\n```\n\n### 埃氏筛法\n\n> 给定整数n，请问n以内有多少个素数？\n\n如果对每一个数都进行素性测试，那么复杂度就高了。所以就有了这个解法。\n\n首先，将2到范围内的所有整数写下来。其中最小的数字2是素数。将表中所有2的倍数都划去表中剩余的最小数字是3它不能被更小的数整除，所以是素数。再将表中所有3的倍数都划去依此类推，如果表中剩余的最小数字是m时，m就是素数。然后将表中所有m的倍数都划去。像这样反复操作，就能依次枚举n以内的素数。\n\n``` cpp\nconst int MAX_N = 10e6;\nint prime[MAX_N];\nbool is_prime[MAX_N + 1];\n\nint sieve(int n) {\n    int p = 0;\n    for (int i = 0; i<= n; i++) is_prime[i] = true;\n    is_prime[0] = is_prime[1] = false;\n    \n    for (int i = 2; i <= n; i++) {\n        if (is_prime[i]) {\n            prime[p++] = i;\n            for (int j = 2 * i; j <= n; j += i) is_prime[j] = false;\n        }\n    }\n    return p;\n}\n```","slug":"2014-11-15-math-prime","published":1,"updated":"2015-04-30T12:20:51.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck2o001zrwmwieybftp4"},{"layout":"post","title":"图:单源点最短路之dijkstra算法","date":"2014-11-13T08:02:20.000Z","_content":"\n\ndijkstra算法也是采用的贪心算法，和prim算法非常像，可以比较一下代码，就两三行不同。\n\n思想就是根据各顶点到源点的距离生成一个优先级队列，初始时除了源点距离为零，其它都为INF。这样，每次从队列中取出最短路径的顶点，然后对每个邻接的顶点进行松弛，更新队列。重复操作直至队列为空。\n\n伪代码如下：\n```\n\tDIJKSTRA(G, w, s)\n\t\tINITIALIZE-SINGLE-SOURCE(G, s)\n\t\tS <- null\n\t\tQ <- V[G]\n\t\twhile Q != null\n\t\t\tdo u <- EXTRACT-MIN(Q)\n\t\t\t\tS <- S + u\n\t\t\t\tfor each vertex v in Adj[u]\n\t\t\t\t\tdo RELAX(u, v, w)\n```\n\n当然，在实现的过程中，并没有按照伪代码所写的流程来，因为要更新优先级队列中的值很麻烦，所以采取了prim算法中所使用的方法。\n\ndijkstra算法由于是贪心算法，所以图中不能有负权值的边。\n\n比如\n```\n    1 --  1  --> 2\n\t|\t\t\t |\n\t100        \t 2\n\t|\t\t\t |\n    ﹀\t\t\t ﹀\n    3 -- -99 --> 4\n```\n在上面的图中，我们最后会得到1->4的距离为3，而不是1.\n\ndijkstra算法和prim算法的区别很小，一个在于key中存储的是最短路径，另一个存储的是与其邻接的最小的边。\n\n操作上的不同就是在prim中，直接用邻接的边去更新key的值，而dijkstras中是松弛一条边，然后根据松弛的结果更新key的值。\n\n代码如下：\n\n``` cpp\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define INF 10000\n#define NIL -1\n#define MAX_V 1000      //最大顶点数\nint G[MAX_V][MAX_V];    //图\nint N;                  //顶点个数\n\n//节点\nstruct Node {\n    Node(int vertex = 0, int key = INF) : vertex(vertex), key(key) {}\n    \n    int vertex;\n    int key;\n};\n\nclass MinHeap\n{\npublic:\n    bool operator() (const Node *a, const Node *b) const\n    {\n        return (a->key > b->key);\n    }\n};\n\nvoid dijkstra() {\n    priority_queue<Node *, vector<Node *>, MinHeap> Q;\n    vector<int> P(N, -1);\n    vector<int> keys(N, INF);\n    \n    //初始化第一个元素\n    Q.push(new Node(0, 0));\n    keys[0] = 0;\n    while (!Q.empty()) {\n        Node *top = Q.top();\n        Q.pop();\n        \n        if (top->key > keys[top->vertex]) continue;\n        \n        for (int i = 0; i < N; i++) {\n            if (G[top->vertex][i] != 0 && G[top->vertex][i] != INF) {\n                if ((top->key + G[top->vertex][i]) < keys[i]) {\n                    keys[i] = top->key + G[top->vertex][i];\n                    P[i] = top->vertex;\n                    Q.push(new Node(i, keys[i]));\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    /* example input\n     5\n     0  10  10000   5   10000\n     10000  0   1   2   10000\n     10000  10000   0   10000   4\n     10000  3   9   0   2\n     7  10000   6   10000   0\n     */\n    cin>>N;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            int w;\n            cin>>w;\n            G[i][j] = w;\n        }\n    }\n    dijkstra();\n}\n```","source":"_posts/2014-11-13-dijkstra.md","raw":"---\nlayout: post\ntitle:  \"图:单源点最短路之dijkstra算法\"\ndate:   2014-11-13 16:02:20\ncategories:   algorithms\n---\n\n\ndijkstra算法也是采用的贪心算法，和prim算法非常像，可以比较一下代码，就两三行不同。\n\n思想就是根据各顶点到源点的距离生成一个优先级队列，初始时除了源点距离为零，其它都为INF。这样，每次从队列中取出最短路径的顶点，然后对每个邻接的顶点进行松弛，更新队列。重复操作直至队列为空。\n\n伪代码如下：\n```\n\tDIJKSTRA(G, w, s)\n\t\tINITIALIZE-SINGLE-SOURCE(G, s)\n\t\tS <- null\n\t\tQ <- V[G]\n\t\twhile Q != null\n\t\t\tdo u <- EXTRACT-MIN(Q)\n\t\t\t\tS <- S + u\n\t\t\t\tfor each vertex v in Adj[u]\n\t\t\t\t\tdo RELAX(u, v, w)\n```\n\n当然，在实现的过程中，并没有按照伪代码所写的流程来，因为要更新优先级队列中的值很麻烦，所以采取了prim算法中所使用的方法。\n\ndijkstra算法由于是贪心算法，所以图中不能有负权值的边。\n\n比如\n```\n    1 --  1  --> 2\n\t|\t\t\t |\n\t100        \t 2\n\t|\t\t\t |\n    ﹀\t\t\t ﹀\n    3 -- -99 --> 4\n```\n在上面的图中，我们最后会得到1->4的距离为3，而不是1.\n\ndijkstra算法和prim算法的区别很小，一个在于key中存储的是最短路径，另一个存储的是与其邻接的最小的边。\n\n操作上的不同就是在prim中，直接用邻接的边去更新key的值，而dijkstras中是松弛一条边，然后根据松弛的结果更新key的值。\n\n代码如下：\n\n``` cpp\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define INF 10000\n#define NIL -1\n#define MAX_V 1000      //最大顶点数\nint G[MAX_V][MAX_V];    //图\nint N;                  //顶点个数\n\n//节点\nstruct Node {\n    Node(int vertex = 0, int key = INF) : vertex(vertex), key(key) {}\n    \n    int vertex;\n    int key;\n};\n\nclass MinHeap\n{\npublic:\n    bool operator() (const Node *a, const Node *b) const\n    {\n        return (a->key > b->key);\n    }\n};\n\nvoid dijkstra() {\n    priority_queue<Node *, vector<Node *>, MinHeap> Q;\n    vector<int> P(N, -1);\n    vector<int> keys(N, INF);\n    \n    //初始化第一个元素\n    Q.push(new Node(0, 0));\n    keys[0] = 0;\n    while (!Q.empty()) {\n        Node *top = Q.top();\n        Q.pop();\n        \n        if (top->key > keys[top->vertex]) continue;\n        \n        for (int i = 0; i < N; i++) {\n            if (G[top->vertex][i] != 0 && G[top->vertex][i] != INF) {\n                if ((top->key + G[top->vertex][i]) < keys[i]) {\n                    keys[i] = top->key + G[top->vertex][i];\n                    P[i] = top->vertex;\n                    Q.push(new Node(i, keys[i]));\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    /* example input\n     5\n     0  10  10000   5   10000\n     10000  0   1   2   10000\n     10000  10000   0   10000   4\n     10000  3   9   0   2\n     7  10000   6   10000   0\n     */\n    cin>>N;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            int w;\n            cin>>w;\n            G[i][j] = w;\n        }\n    }\n    dijkstra();\n}\n```","slug":"2014-11-13-dijkstra","published":1,"updated":"2015-04-30T12:21:15.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck2q0021rwmwl06puwyi"},{"layout":"post","title":"位运算与深搜: subsets","date":"2014-11-12T13:00:20.000Z","_content":"\nGiven a set of distinct integers, S, return all possible subsets.\n\nNote:\nElements in a subset must be in non-descending order.\n\nThe solution set must not contain duplicate subsets.\n\nFor example,\n\nIf S = [1,2,3], a solution is:\n\n\t[\n\t  [3],\n\t  [1],\n\t  [2],\n\t  [1,2,3],\n\t  [1,3],\n\t  [2,3],\n\t  [1,2],\n\t  []\n\t]\n\n解法一:使用位运算\n\n``` cpp\nclass Solution {\npublic:\n    //使用位运算来实现\n    //在这个题中数据量应该很小，S的大小应该小于32。。。\n    vector<vector<int> > subsets(vector<int> &S) {\n        vector<vector<int>> result;\n        if (S.size() == 0) return result;\n        \n        int size = S.size();\n        sort(S.begin(), S.end());\n        \n        int pos = 0;        \n        //可以看出，时间复杂度是很高的，是2^size\n        for (int i = 1; i <= pow(2, size); i++) {\n            vector<int> row;\n            for (int j = 0; j < size; j ++) {\n                if ((pos >> j) & 1) row.push_back(S[j]); \n            }\n            result.push_back(row);\n            pos++;\n        }\n        return result;\n    }\n};\n```\n\n解法二: 还是是用位运算\n\n``` cpp\nclass Solution {\npublic:\n    //在上一个解法中，我们只是考虑到S.size() < 32的情况，\n    //在这个解法中，S.size()可以大于32\n    //在这个解法中，使用一个bits的数组来存储各个位的状态，比如我要存储42位\n    //的状态信息，那么我只要获取bits[42/32]中42%32位的值就好了\n    vector<vector<int> > subsets(vector<int> &S) {\n        vector<vector<int>> result;\n        if (S.size() == 0) return result;\n        \n        int size = S.size();\n        sort(S.begin(), S.end());\n        \n        vector<int> bits(size/(8 * sizeof(int)) + 1, 0);\n        while (!shouldStop(bits, size)) {\n            vector<int> row;\n            for (int j = 0; j < size; j ++) {\n                if (getBit(bits, j)) row.push_back(S[j]); \n            }\n            result.push_back(row);\n            addOne(bits);\n        }\n        return result;\n    }\n    \n    bool shouldStop(vector<int> &bits, int size) {\n    \t//如果前size位都为零，但是size+1位为一，那么久溢出了\n        bool flow = false;\n        for(int i = 0; i < size; i++) {\n            flow = flow || getBit(bits, i);\n        }\n        return ~flow && getBit(bits, size); \n    }\n    \n    void addOne(vector<int> &bits) {\n        bool flow = true;\n        for (int i = 0; i < bits.size(); i++) {\n            if (flow && bits[i] < pow(2, sizeof(int)*8) - 1) {\n                bits[i]++;\n                return;\n            } \n            bits[i] = 0;\n        }\n    }\n    \n    bool getBit(vector<int> &bits, int pos) {\n        int p_int = pos / (8 * sizeof(int));\n        int p_bit = pos % (8 * sizeof(int));\n        \n        return (bits[p_int] >> p_bit) & 1;\n    }\n};\n```\n\n解法三: 深搜\n\n``` cpp\nclass Solution {\npublic:\n    vector<vector<int> > subsets(vector<int> &S) {\n        vector<vector<int>> result;\n        if (S.size() == 0) return result;\n        sort(S.begin(), S.end());\n        \n        vector<int> row;\n        dfs(result, row, S, 0);\n        return result;\n    }\n    \n    void dfs(vector<vector<int> > &result, vector<int> row, vector<int> &S, int pos) {\n        if (pos >= S.size())  {\n            result.push_back(row);\n            return;\n        }\n        \n        dfs(result, row, S, pos + 1);\n        row.push_back(S[pos]);\n        dfs(result, row, S, pos + 1);\n    }\n};\n```","source":"_posts/2014-11-12-leetcode-Subsets.md","raw":"---\nlayout: post\ntitle:  \"位运算与深搜: subsets\"\ndate:   2014-11-12 21:00:20\ncategories: problems\n---\n\nGiven a set of distinct integers, S, return all possible subsets.\n\nNote:\nElements in a subset must be in non-descending order.\n\nThe solution set must not contain duplicate subsets.\n\nFor example,\n\nIf S = [1,2,3], a solution is:\n\n\t[\n\t  [3],\n\t  [1],\n\t  [2],\n\t  [1,2,3],\n\t  [1,3],\n\t  [2,3],\n\t  [1,2],\n\t  []\n\t]\n\n解法一:使用位运算\n\n``` cpp\nclass Solution {\npublic:\n    //使用位运算来实现\n    //在这个题中数据量应该很小，S的大小应该小于32。。。\n    vector<vector<int> > subsets(vector<int> &S) {\n        vector<vector<int>> result;\n        if (S.size() == 0) return result;\n        \n        int size = S.size();\n        sort(S.begin(), S.end());\n        \n        int pos = 0;        \n        //可以看出，时间复杂度是很高的，是2^size\n        for (int i = 1; i <= pow(2, size); i++) {\n            vector<int> row;\n            for (int j = 0; j < size; j ++) {\n                if ((pos >> j) & 1) row.push_back(S[j]); \n            }\n            result.push_back(row);\n            pos++;\n        }\n        return result;\n    }\n};\n```\n\n解法二: 还是是用位运算\n\n``` cpp\nclass Solution {\npublic:\n    //在上一个解法中，我们只是考虑到S.size() < 32的情况，\n    //在这个解法中，S.size()可以大于32\n    //在这个解法中，使用一个bits的数组来存储各个位的状态，比如我要存储42位\n    //的状态信息，那么我只要获取bits[42/32]中42%32位的值就好了\n    vector<vector<int> > subsets(vector<int> &S) {\n        vector<vector<int>> result;\n        if (S.size() == 0) return result;\n        \n        int size = S.size();\n        sort(S.begin(), S.end());\n        \n        vector<int> bits(size/(8 * sizeof(int)) + 1, 0);\n        while (!shouldStop(bits, size)) {\n            vector<int> row;\n            for (int j = 0; j < size; j ++) {\n                if (getBit(bits, j)) row.push_back(S[j]); \n            }\n            result.push_back(row);\n            addOne(bits);\n        }\n        return result;\n    }\n    \n    bool shouldStop(vector<int> &bits, int size) {\n    \t//如果前size位都为零，但是size+1位为一，那么久溢出了\n        bool flow = false;\n        for(int i = 0; i < size; i++) {\n            flow = flow || getBit(bits, i);\n        }\n        return ~flow && getBit(bits, size); \n    }\n    \n    void addOne(vector<int> &bits) {\n        bool flow = true;\n        for (int i = 0; i < bits.size(); i++) {\n            if (flow && bits[i] < pow(2, sizeof(int)*8) - 1) {\n                bits[i]++;\n                return;\n            } \n            bits[i] = 0;\n        }\n    }\n    \n    bool getBit(vector<int> &bits, int pos) {\n        int p_int = pos / (8 * sizeof(int));\n        int p_bit = pos % (8 * sizeof(int));\n        \n        return (bits[p_int] >> p_bit) & 1;\n    }\n};\n```\n\n解法三: 深搜\n\n``` cpp\nclass Solution {\npublic:\n    vector<vector<int> > subsets(vector<int> &S) {\n        vector<vector<int>> result;\n        if (S.size() == 0) return result;\n        sort(S.begin(), S.end());\n        \n        vector<int> row;\n        dfs(result, row, S, 0);\n        return result;\n    }\n    \n    void dfs(vector<vector<int> > &result, vector<int> row, vector<int> &S, int pos) {\n        if (pos >= S.size())  {\n            result.push_back(row);\n            return;\n        }\n        \n        dfs(result, row, S, pos + 1);\n        row.push_back(S[pos]);\n        dfs(result, row, S, pos + 1);\n    }\n};\n```","slug":"2014-11-12-leetcode-Subsets","published":1,"updated":"2015-04-30T12:25:10.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck2t0023rwmw7x9l8v9y"},{"layout":"post","title":"DFS,图: Clone Graph","date":"2014-11-01T13:04:20.000Z","_content":"\n>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.\n\n``` cpp\nclass Solution {\npublic:\n    map<int, UndirectedGraphNode *> nodes;  //定义一个map来存储label与相对应的node指针\n    \n    //使用DFS来拷贝图\n    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {\n        //！重要，如果node为空，直接返回空指针\n        if (node == NULL)\n            return NULL;\n        \n        //这里不能使用UndirectedGraphNode root(node->label)，然后返回地址，\n        //这样会出现runtime error\n        UndirectedGraphNode *root = new UndirectedGraphNode(node->label);\n        nodes.insert(make_pair(node->label, root));\n        for (int i = 0; i < node->neighbors.size(); i++) {\n            int label = node->neighbors[i]->label;\n            if (nodes.count(label) != 0) {\n                //如果遍历过了，加入nieghbors\n                root->neighbors.push_back(nodes[label]);\n            } else {\n                //如果没有遍历过，拷贝该节点\n                root->neighbors.push_back(cloneGraph(node->neighbors[i]));\n            }\n        }\n        return root;\n    }\n};\n```","source":"_posts/2014-11-1-leetcode-Clone-Graph.md","raw":"---\nlayout: post\ntitle:  \"DFS,图: Clone Graph\"\ndate:   2014-11-1 21:04:20\ncategories: problems\n---\n\n>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.\n\n``` cpp\nclass Solution {\npublic:\n    map<int, UndirectedGraphNode *> nodes;  //定义一个map来存储label与相对应的node指针\n    \n    //使用DFS来拷贝图\n    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {\n        //！重要，如果node为空，直接返回空指针\n        if (node == NULL)\n            return NULL;\n        \n        //这里不能使用UndirectedGraphNode root(node->label)，然后返回地址，\n        //这样会出现runtime error\n        UndirectedGraphNode *root = new UndirectedGraphNode(node->label);\n        nodes.insert(make_pair(node->label, root));\n        for (int i = 0; i < node->neighbors.size(); i++) {\n            int label = node->neighbors[i]->label;\n            if (nodes.count(label) != 0) {\n                //如果遍历过了，加入nieghbors\n                root->neighbors.push_back(nodes[label]);\n            } else {\n                //如果没有遍历过，拷贝该节点\n                root->neighbors.push_back(cloneGraph(node->neighbors[i]));\n            }\n        }\n        return root;\n    }\n};\n```","slug":"2014-11-1-leetcode-Clone-Graph","published":1,"updated":"2015-04-30T12:17:04.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck2v0025rwmwtsjfblvj"},{"layout":"post","title":"Linux网络虚拟化的一些概念","date":"2014-11-06T16:00:00.000Z","_content":"\n##bridge\nBridge（桥）是 Linux 上用来做 TCP/IP 二层协议交换的设备，与现实世界中的交换机功能相似。Bridge 设备实例可以和 Linux 上其他网络设备实例连接，既 attach 一个从设备，类似于在现实世界中的交换机和一个用户终端之间连接一根网线。当有数据到达时，Bridge 会根据报文中的 MAC \n\n##TAP 设备与 VETH 设备\n当一个 TAP 设备被创建时，在 Linux 设备文件目录下将会生成一个对应 char 设备，用户程序可以像打开普通文件一样打开这个文件进行读写。当执行 write()操作时，数据进入 TAP 设备，此时对于 Linux 网络层来说，相当于 TAP 设备收到了一包数据，请求内核接受它，如同普通的物理网卡从外界收到一包数据一样，不同的是其实数据来自 Linux 上的一个用户程序。Linux 收到此数据后将根据网络配置进行后续处理，从而完成了用户程序向 Linux 内核网络层注入数据的功能。当用户程序执行 read()请求时，相当于向内核查询 TAP 设备上是否有需要被发送出去的数据，有的话取出到用户程序里，完成 TAP 设备的发送数据功能。针对 TAP 设备的一个形象的比喻是：使用 TAP 设备的应用程序相当于另外一台计算机，TAP 设备是本机的一个网卡，他们之间相互连接。应用程序通过 read()/write()操作，和本机网络核心进行通讯。\n\nVETH 设备总是成对出现，送到一端请求发送的数据总是从另一端以请求接受的形式出现。该设备不能被用户程序直接操作，但使用起来比较简单。创建并配置正确后，向其一端输入数据，VETH 会改变数据的方向并将其送入内核网络核心，完成数据的注入。在另一端能读到此数据。\n\n##netns\nnetns是在linux中提供网络虚拟化的一个项目，使用netns网络空间虚拟化可以在本地虚拟化出多个网络环境，目前netns在lxc容器中被用来为容器提供网络。\n\n使用netns创建的网络空间独立于当前系统的网络空间，其中的网络设备以及iptables规则等都是独立的，就好像进入了另外一个网络一样。\n\n##让两个netns下的网络通信\n先介绍几个命令：\n```\n\tip netns add net0  #创建netns net0\n\tip netns list\t\t#列出所有netns\n\tip netns exec net0 bash #进入net0\n```\n现在开始:\n\n![network](/img/virtual_network.png)\n\n创建虚拟网络并连接网线\n```\n\tip netns add net0\n\tip netns add net1\n\tip netns add bridge\n\tip link add type veth\n\tip link set dev veth0 name net0-bridge netns net0\n\tip link set dev veth1 name bridge-net0 netns bridge\n\tip link add type veth\n\tip link set dev veth0 name net1-bridge netns net1\n\tip link set dev veth1 name bridge-net1 netns bridge\n```\n\n在bridge中创建并且设置br设备\n```\n\tip netns exec bridge brctl addbr br\n\tip netns exec bridge ip link set dev br up\n\tip netns exec bridge ip link set dev bridge-net0 up\n\tip netns exec bridge ip link set dev bridge-net1 up\n\tip netns exec bridge brctl addif br bridge-net0\n\tip netns exec bridge brctl addif br bridge-net1\n```\n然后配置两个虚拟环境的网卡\n```\n\tip netns exec net0 ip link set dev net0-bridge up\n\tip netns exec net0 ip address add 10.0.1.1/24 dev net0-bridge\n\tip netns exec net1 ip link set dev net1-bridge up\n\tip netns exec net1 ip address add 10.0.1.2/24 dev net1-bridge\n```\n\n参考:\n\n<a href=\"http://www.ibm.com/developerworks/cn/linux/1310_xiawc_networkdevice/\">Linux 上的基础网络设备详解</a>\n\n<a href=\"http://www.2cto.com/os/201312/266765.html\">Linux 上虚拟网络与真实网络的映射</a>\n\n<a href=\"http://www.360doc.com/content/13/1010/14/8504707_320319174.shtml\">网络虚拟化技术（一）: Linux网络虚拟化\n</a>\n\n\n","source":"_posts/2014-11-07-linux-virtual-network.md","raw":"---\nlayout: post\ntitle:  \"Linux网络虚拟化的一些概念\"\ncategories:   linux\ndate:   2014-11-07\n---\n\n##bridge\nBridge（桥）是 Linux 上用来做 TCP/IP 二层协议交换的设备，与现实世界中的交换机功能相似。Bridge 设备实例可以和 Linux 上其他网络设备实例连接，既 attach 一个从设备，类似于在现实世界中的交换机和一个用户终端之间连接一根网线。当有数据到达时，Bridge 会根据报文中的 MAC \n\n##TAP 设备与 VETH 设备\n当一个 TAP 设备被创建时，在 Linux 设备文件目录下将会生成一个对应 char 设备，用户程序可以像打开普通文件一样打开这个文件进行读写。当执行 write()操作时，数据进入 TAP 设备，此时对于 Linux 网络层来说，相当于 TAP 设备收到了一包数据，请求内核接受它，如同普通的物理网卡从外界收到一包数据一样，不同的是其实数据来自 Linux 上的一个用户程序。Linux 收到此数据后将根据网络配置进行后续处理，从而完成了用户程序向 Linux 内核网络层注入数据的功能。当用户程序执行 read()请求时，相当于向内核查询 TAP 设备上是否有需要被发送出去的数据，有的话取出到用户程序里，完成 TAP 设备的发送数据功能。针对 TAP 设备的一个形象的比喻是：使用 TAP 设备的应用程序相当于另外一台计算机，TAP 设备是本机的一个网卡，他们之间相互连接。应用程序通过 read()/write()操作，和本机网络核心进行通讯。\n\nVETH 设备总是成对出现，送到一端请求发送的数据总是从另一端以请求接受的形式出现。该设备不能被用户程序直接操作，但使用起来比较简单。创建并配置正确后，向其一端输入数据，VETH 会改变数据的方向并将其送入内核网络核心，完成数据的注入。在另一端能读到此数据。\n\n##netns\nnetns是在linux中提供网络虚拟化的一个项目，使用netns网络空间虚拟化可以在本地虚拟化出多个网络环境，目前netns在lxc容器中被用来为容器提供网络。\n\n使用netns创建的网络空间独立于当前系统的网络空间，其中的网络设备以及iptables规则等都是独立的，就好像进入了另外一个网络一样。\n\n##让两个netns下的网络通信\n先介绍几个命令：\n```\n\tip netns add net0  #创建netns net0\n\tip netns list\t\t#列出所有netns\n\tip netns exec net0 bash #进入net0\n```\n现在开始:\n\n![network](/img/virtual_network.png)\n\n创建虚拟网络并连接网线\n```\n\tip netns add net0\n\tip netns add net1\n\tip netns add bridge\n\tip link add type veth\n\tip link set dev veth0 name net0-bridge netns net0\n\tip link set dev veth1 name bridge-net0 netns bridge\n\tip link add type veth\n\tip link set dev veth0 name net1-bridge netns net1\n\tip link set dev veth1 name bridge-net1 netns bridge\n```\n\n在bridge中创建并且设置br设备\n```\n\tip netns exec bridge brctl addbr br\n\tip netns exec bridge ip link set dev br up\n\tip netns exec bridge ip link set dev bridge-net0 up\n\tip netns exec bridge ip link set dev bridge-net1 up\n\tip netns exec bridge brctl addif br bridge-net0\n\tip netns exec bridge brctl addif br bridge-net1\n```\n然后配置两个虚拟环境的网卡\n```\n\tip netns exec net0 ip link set dev net0-bridge up\n\tip netns exec net0 ip address add 10.0.1.1/24 dev net0-bridge\n\tip netns exec net1 ip link set dev net1-bridge up\n\tip netns exec net1 ip address add 10.0.1.2/24 dev net1-bridge\n```\n\n参考:\n\n<a href=\"http://www.ibm.com/developerworks/cn/linux/1310_xiawc_networkdevice/\">Linux 上的基础网络设备详解</a>\n\n<a href=\"http://www.2cto.com/os/201312/266765.html\">Linux 上虚拟网络与真实网络的映射</a>\n\n<a href=\"http://www.360doc.com/content/13/1010/14/8504707_320319174.shtml\">网络虚拟化技术（一）: Linux网络虚拟化\n</a>\n\n\n","slug":"2014-11-07-linux-virtual-network","published":1,"updated":"2015-05-04T12:47:16.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck2w0027rwmwmdincvlh"},{"layout":"post","title":"扔盘子问题","date":"2014-10-30T07:10:20.000Z","_content":"\n题目链接：<a href=\"http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1279\">扔盘子</a>\n\n\nThe story is about throwing concrete disks into an old dry well. The well is made of concrete rings that can have different (internal) diameters. The disks fall until they hit the bottom, the previously dropped disk or the concrete ring (whose internal diameter is smaller then the disk's diameter). You are given two arrays, A containing the diameters of the rings in the top-down order, and B containing the the diameters of the disks. The task is to compute how many disks will fit into the well?\n\n![throw_disks](/img/throw_disks_1.png)\n\nA simple solution is to simulate the falling disks.\n``` python\n\tdef falling_disks(A, B):\n\t    N = len(A)\n\t    M = len(B)    \n\t    i = 0 \n\t    while i < M and N > 0:\n\t        k = -1\n\t        while k + 1 < N and B[i] <= A[k + 1]: \n\t            k = k + 1\n\t        if k >= 0:\n\t            i = i + 1\n\t        N = k\n\t    return i\n```\n\nHowever, it is inefficient. Simulation of one disk can take O(N) time, and the whole algorithm can require O(N⋅M) time. To find a faster solution, we will simplify the problem first.\nImagine that you are looking into the well from above. It seems that the rings that are deeper are smaller. Even if one of them in fact has a larger diameter, it is hidden behind a narrower ring above. We can apply such a transformation to the input data without changing the result. Note that a disk can reach some ring if it is not wider then the diameter of this ring and all the rings above. For the example shown on the figure above we obtain the following well:\n\n![throw_disks](/img/throw_disks_2.png)\n\nSuch a transformation can be computed in O(N). Then, we can find the final position of each disk by checking the rings in the bottom-up order. Since it is not possible to fit more disks than there are rings, the overall time complexity is O(N).\n``` python\ndef falling_disks(A, B):\n    N = len(A)\n    M = len(B)\n\n    for i in range(1, N):\n        A[i] = min(A[i], A[i-1])\n\n    i = 0      \n    while i < M and N > 0:\n        while N > 0 and A[N-1] < B[i]: \n            N = N - 1\n        if N > 0:\n            N = N - 1\n            i = i + 1\n    \n    return i\n```","source":"_posts/2014-10-30-throw-disks.md","raw":"---\nlayout: post\ntitle:  \"扔盘子问题\"\ndate:   2014-10-30 15:10:20\ncategories: problems\n---\n\n题目链接：<a href=\"http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1279\">扔盘子</a>\n\n\nThe story is about throwing concrete disks into an old dry well. The well is made of concrete rings that can have different (internal) diameters. The disks fall until they hit the bottom, the previously dropped disk or the concrete ring (whose internal diameter is smaller then the disk's diameter). You are given two arrays, A containing the diameters of the rings in the top-down order, and B containing the the diameters of the disks. The task is to compute how many disks will fit into the well?\n\n![throw_disks](/img/throw_disks_1.png)\n\nA simple solution is to simulate the falling disks.\n``` python\n\tdef falling_disks(A, B):\n\t    N = len(A)\n\t    M = len(B)    \n\t    i = 0 \n\t    while i < M and N > 0:\n\t        k = -1\n\t        while k + 1 < N and B[i] <= A[k + 1]: \n\t            k = k + 1\n\t        if k >= 0:\n\t            i = i + 1\n\t        N = k\n\t    return i\n```\n\nHowever, it is inefficient. Simulation of one disk can take O(N) time, and the whole algorithm can require O(N⋅M) time. To find a faster solution, we will simplify the problem first.\nImagine that you are looking into the well from above. It seems that the rings that are deeper are smaller. Even if one of them in fact has a larger diameter, it is hidden behind a narrower ring above. We can apply such a transformation to the input data without changing the result. Note that a disk can reach some ring if it is not wider then the diameter of this ring and all the rings above. For the example shown on the figure above we obtain the following well:\n\n![throw_disks](/img/throw_disks_2.png)\n\nSuch a transformation can be computed in O(N). Then, we can find the final position of each disk by checking the rings in the bottom-up order. Since it is not possible to fit more disks than there are rings, the overall time complexity is O(N).\n``` python\ndef falling_disks(A, B):\n    N = len(A)\n    M = len(B)\n\n    for i in range(1, N):\n        A[i] = min(A[i], A[i-1])\n\n    i = 0      \n    while i < M and N > 0:\n        while N > 0 and A[N-1] < B[i]: \n            N = N - 1\n        if N > 0:\n            N = N - 1\n            i = i + 1\n    \n    return i\n```","slug":"2014-10-30-throw-disks","published":1,"updated":"2015-04-30T12:17:45.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck2y0029rwmwdtu8b27v"},{"layout":"post","title":"图: DAG中使用拓扑排序来求单源点最短路径","date":"2014-10-30T08:55:00.000Z","_content":"\n求单源点最短路径时，使用Bellman-Ford算法的需要对所有边松弛V-1遍。但是如果我们知道一个图是一个有向无环图时，我们先对所有顶点进行一次拓扑排序，然后依次对每个顶点连接的边松弛一遍就可以了。时间复杂度为O(V+E)。\n\n```\n\tDAG-SHORTEST-PATHS(G, w, s)\n\t\ttopologically sort the vetices of G\n\t\tINITIALIZE-SINGLE-SOURCE(G,s)\n\t\tfor each vertex u, taken in topolocially sorted order\n\t\t\tdo for each vertex v in Adj[u]\n\t\t\t\tdor Relax(u, v, w)\n```\n代码算了吧。。。","source":"_posts/2014-10-30-dag-shortest-path.md","raw":"---\nlayout: post\ntitle:  \"图: DAG中使用拓扑排序来求单源点最短路径\"\ndate:   2014-10-30 16:55:00\ncategories:   algorithms\n---\n\n求单源点最短路径时，使用Bellman-Ford算法的需要对所有边松弛V-1遍。但是如果我们知道一个图是一个有向无环图时，我们先对所有顶点进行一次拓扑排序，然后依次对每个顶点连接的边松弛一遍就可以了。时间复杂度为O(V+E)。\n\n```\n\tDAG-SHORTEST-PATHS(G, w, s)\n\t\ttopologically sort the vetices of G\n\t\tINITIALIZE-SINGLE-SOURCE(G,s)\n\t\tfor each vertex u, taken in topolocially sorted order\n\t\t\tdo for each vertex v in Adj[u]\n\t\t\t\tdor Relax(u, v, w)\n```\n代码算了吧。。。","slug":"2014-10-30-dag-shortest-path","published":1,"updated":"2015-04-30T12:18:02.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck30002brwmwbbo2qeqe"},{"layout":"post","title":"图:单源点最短路径之Bellman-Ford算法","date":"2014-10-28T09:48:20.000Z","_content":"\nBellman-Ford算法能够在一般的情况下(存在负权边的情况)， 解决单源点最短路径问题，而且能够判断图中是否存在负值回路。\n\n算法用到了两个辅助数组D,P。使用D来记录源点到各个点得最短距离。使用P来记录最短路的路径。\n\n算法的思路如下:\n\n1. 对两个数组进行初始化，将D[0]赋值为0，表示是以0号顶点为源点。\n2. 对图中的每一条边进行V-1次松弛操作，得到源点到每个顶点的最短路径。\n3. 如果还能够对最短路径进行优化，表示图中存在负值回路。\n\n代码如下：\n``` cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n//节点\nstruct Node {\n    int val;\n    int to;\n    Node(int to, int val):to(to), val(val) {}\n};\n\nconst int INF = 1000000000;\n\nint V;                      //顶点数\nvector<vector<Node> > G;    //图\nvector<int> D;              //距离\nvector<int> P;              //路径\n\n//松弛操作\n//对一条边u-->v,权值为val，如果\n//d[v] > d[u] + val，那么可以对这条边进行松弛操作，即更新源点到v的最短路径\nvoid relax(int u, int v, int val) {\n    if (D.size() > u && P.size() > v && D[v] > D[u] + val) {\n        D[v] = D[u] + val;\n        P[v] = u;\n    }\n}\n\nbool bellman_ford() {\n    //对每条边进行松弛，松弛V-1次\n    //为什么要松弛V-1次呢，因为V个点中路径最长为V-1，所以每次松弛都能够得到最短路径中的一条边，\n    //松弛V-1次以后，就得到了源点到所有点得最短的路径\n    for (int i = 0; i < V; i++) {\n        for (int m = 0; m < G.size(); m++) {\n            for (int n = 0; n < G[m].size(); n++) {\n                relax(m, G[m][n].to, G[m][n].val);\n            }\n        }\n    }\n    \n    //如果存在负值回路，那么还可以松弛，返回false\n    for (int m = 0; m < G.size(); m++) {\n        for (int n = 0; n < G[m].size(); n++) {\n            if (D[G[m][n].to] > D[m] + G[m][n].val)\n                return false;\n        }\n    }\n    //如果没有负值回路，返回true\n    return true;\n}\n\nint main() {\n    /* example input\n     4\n     0 1 x x\n     x 0 2 x\n     x x 0 3\n     x x x 0\n     \n     5\n     0 1  x x x\n     x 0 -5 x x\n     x x  0 2 3\n     x x  x 0 x\n     x 1  x x 0\n     */\n    cin>>V;\n    G.resize(V);\n    D.resize(V);\n    P.resize(V);\n    \n    fill(D.begin(), D.end(), INF);\n    D[0] = 0;\n    fill(P.begin(), D.end(), V);\n    \n    for (int i = 0; i < V; i++) {\n        for (int j = 0; j < V; j++) {\n            char w;\n            cin>>w;\n            if (i != j && w != 'x') {\n                G[i].push_back(Node(j, w - '0'));\n            }\n        }\n    }\n    cout<<bellman_ford()<<endl;\n    \n    for (int i = 0; i < D.size(); i++) {\n        cout<<D[i]<<endl;\n    }\n}\n```","source":"_posts/2014-10-28-bellman-ford.md","raw":"---\nlayout: post\ntitle:  \"图:单源点最短路径之Bellman-Ford算法\"\ndate:   2014-10-28 17:48:20\ncategories:   algorithms\n---\n\nBellman-Ford算法能够在一般的情况下(存在负权边的情况)， 解决单源点最短路径问题，而且能够判断图中是否存在负值回路。\n\n算法用到了两个辅助数组D,P。使用D来记录源点到各个点得最短距离。使用P来记录最短路的路径。\n\n算法的思路如下:\n\n1. 对两个数组进行初始化，将D[0]赋值为0，表示是以0号顶点为源点。\n2. 对图中的每一条边进行V-1次松弛操作，得到源点到每个顶点的最短路径。\n3. 如果还能够对最短路径进行优化，表示图中存在负值回路。\n\n代码如下：\n``` cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n//节点\nstruct Node {\n    int val;\n    int to;\n    Node(int to, int val):to(to), val(val) {}\n};\n\nconst int INF = 1000000000;\n\nint V;                      //顶点数\nvector<vector<Node> > G;    //图\nvector<int> D;              //距离\nvector<int> P;              //路径\n\n//松弛操作\n//对一条边u-->v,权值为val，如果\n//d[v] > d[u] + val，那么可以对这条边进行松弛操作，即更新源点到v的最短路径\nvoid relax(int u, int v, int val) {\n    if (D.size() > u && P.size() > v && D[v] > D[u] + val) {\n        D[v] = D[u] + val;\n        P[v] = u;\n    }\n}\n\nbool bellman_ford() {\n    //对每条边进行松弛，松弛V-1次\n    //为什么要松弛V-1次呢，因为V个点中路径最长为V-1，所以每次松弛都能够得到最短路径中的一条边，\n    //松弛V-1次以后，就得到了源点到所有点得最短的路径\n    for (int i = 0; i < V; i++) {\n        for (int m = 0; m < G.size(); m++) {\n            for (int n = 0; n < G[m].size(); n++) {\n                relax(m, G[m][n].to, G[m][n].val);\n            }\n        }\n    }\n    \n    //如果存在负值回路，那么还可以松弛，返回false\n    for (int m = 0; m < G.size(); m++) {\n        for (int n = 0; n < G[m].size(); n++) {\n            if (D[G[m][n].to] > D[m] + G[m][n].val)\n                return false;\n        }\n    }\n    //如果没有负值回路，返回true\n    return true;\n}\n\nint main() {\n    /* example input\n     4\n     0 1 x x\n     x 0 2 x\n     x x 0 3\n     x x x 0\n     \n     5\n     0 1  x x x\n     x 0 -5 x x\n     x x  0 2 3\n     x x  x 0 x\n     x 1  x x 0\n     */\n    cin>>V;\n    G.resize(V);\n    D.resize(V);\n    P.resize(V);\n    \n    fill(D.begin(), D.end(), INF);\n    D[0] = 0;\n    fill(P.begin(), D.end(), V);\n    \n    for (int i = 0; i < V; i++) {\n        for (int j = 0; j < V; j++) {\n            char w;\n            cin>>w;\n            if (i != j && w != 'x') {\n                G[i].push_back(Node(j, w - '0'));\n            }\n        }\n    }\n    cout<<bellman_ford()<<endl;\n    \n    for (int i = 0; i < D.size(); i++) {\n        cout<<D[i]<<endl;\n    }\n}\n```","slug":"2014-10-28-bellman-ford","published":1,"updated":"2015-04-30T12:18:15.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck32002drwmw0sg4ygfq"},{"layout":"post","title":"图:并查集","date":"2014-10-26T06:40:20.000Z","_content":"\n并查集是一种树型的数据结构，其保持着用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。\n\n并查集一般支持两种操作：\n\n1. 查找\t查询两个元素a和b是否在同一个集合\n2. 合并\t合并a和b所在的两个集合\n\n并查集一般使用树形结构，但不是二叉树。下面具体说说并查集的几个操作：\n\n1. 初始化\n\n首先准备的n个元素都是没有边的。\n\n![ufind1](/img/union_find_1.png)\n\n2. 合并\n\n合并的时候就是将一个集合的根指向另一个集合的根。如下图：\n\n![ufind1](/img/union_find_2.png)\n\n但是在合并的时候一般会对合并的操作进行优化，我们会将树低的集合的根指向树高的集合的根，所以我们会顶一个rank的量来记录树高。\n\n3. 查询\n\n查询就是往上查找，看两个元素的根节点是否相同。\n\n![ufind1](/img/union_find_3.png)\n\n在查找的时候，同样可以对并查集进行优化，对并查集的路径进行压缩。我们在查找的过程中把每个节点都指向它的根节点。\n\n![ufind1](/img/union_find_4.png)\n\n代码如下:\n\n``` cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAX_N = 50000;    //最大个数\nint par[MAX_N];             //节点的父节点\nint height[MAX_N];          //树的高度\nint N;                      //个数\n\n//初始化并查集\nvoid init(int n) {\n    for (int i = 0; i < n; i++) {\n        par[i] = i;\n        height[i] = 0;\n    }\n}\n\n//找出x所在树的根节点\nint find(int x) {\n    if (par[x] == x) {\n        return x;\n    } else {\n        return par[x] = find(par[x]); //把父节点直接指向根节点\n    }\n}\n\n//合并x,y所属的集合\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    \n    if (x == y)\n        return;\n    \n    //如果x所在集合树的高度小于y所在集合树的高度，那么将\n    //x的父节点指向y，反之亦然\n    //如果x，y所在集合的树的高度相等，那么随便怎么样都行，\n    //但是将最后指向的树的高度加一\n    if (height[x] < height[y]) {\n        par[x] = y;\n    } else {\n        par[y] = x;\n        if (height[x] == height[y])\n            height[x]++;\n    }\n}\n\nint main() {\n\n}\n```","source":"_posts/2014-10-26-union-find.md","raw":"---\nlayout: post\ntitle:  \"图:并查集\"\ndate:   2014-10-26 14:40:20\ncategories:   algorithms\n---\n\n并查集是一种树型的数据结构，其保持着用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。\n\n并查集一般支持两种操作：\n\n1. 查找\t查询两个元素a和b是否在同一个集合\n2. 合并\t合并a和b所在的两个集合\n\n并查集一般使用树形结构，但不是二叉树。下面具体说说并查集的几个操作：\n\n1. 初始化\n\n首先准备的n个元素都是没有边的。\n\n![ufind1](/img/union_find_1.png)\n\n2. 合并\n\n合并的时候就是将一个集合的根指向另一个集合的根。如下图：\n\n![ufind1](/img/union_find_2.png)\n\n但是在合并的时候一般会对合并的操作进行优化，我们会将树低的集合的根指向树高的集合的根，所以我们会顶一个rank的量来记录树高。\n\n3. 查询\n\n查询就是往上查找，看两个元素的根节点是否相同。\n\n![ufind1](/img/union_find_3.png)\n\n在查找的时候，同样可以对并查集进行优化，对并查集的路径进行压缩。我们在查找的过程中把每个节点都指向它的根节点。\n\n![ufind1](/img/union_find_4.png)\n\n代码如下:\n\n``` cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAX_N = 50000;    //最大个数\nint par[MAX_N];             //节点的父节点\nint height[MAX_N];          //树的高度\nint N;                      //个数\n\n//初始化并查集\nvoid init(int n) {\n    for (int i = 0; i < n; i++) {\n        par[i] = i;\n        height[i] = 0;\n    }\n}\n\n//找出x所在树的根节点\nint find(int x) {\n    if (par[x] == x) {\n        return x;\n    } else {\n        return par[x] = find(par[x]); //把父节点直接指向根节点\n    }\n}\n\n//合并x,y所属的集合\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    \n    if (x == y)\n        return;\n    \n    //如果x所在集合树的高度小于y所在集合树的高度，那么将\n    //x的父节点指向y，反之亦然\n    //如果x，y所在集合的树的高度相等，那么随便怎么样都行，\n    //但是将最后指向的树的高度加一\n    if (height[x] < height[y]) {\n        par[x] = y;\n    } else {\n        par[y] = x;\n        if (height[x] == height[y])\n            height[x]++;\n    }\n}\n\nint main() {\n\n}\n```","slug":"2014-10-26-union-find","published":1,"updated":"2015-04-30T12:25:55.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck34002frwmwfee1lnsb"},{"layout":"post","title":"图:最小生成树之kruskal算法","date":"2014-10-26T11:56:20.000Z","_content":"\nkruskal法是一种贪心算法，与prim算法相似。\n\n在kruskal算法中，我们用到了并查集。\n\n算法的思想是这样的:\n\n1. 对所有的顶点建立一个并查集，对所有的边先进行排序\n2. 遍历每一条边，（因为我们之前对边进行排过序，所以我们每次都是选择最短的边），如果边的两个端点不在通一个集合里，那么该边属于最小生成树，将该边记录下来，然后将两个端点所在的集合合并\n3. 最后我们就得到了最小生成树的所有的边，因为我们每次都是选取可以选取的最小的边，所以kruskal算法也是贪心算法的一种。\n\n代码如下:\n\n``` cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nstruct edge {\n    int from, to;\n    int val;\n    edge(int from, int to, int val):from(from), to(to), val(val){}\n};\n\nconst int MAX_V = 5000; //最大边数\n\nint V;                  //边数\nvector<edge> edges;     //边\n\n//并查集\nint par[MAX_V];             //节点的父节点\nint height[MAX_V];          //树的高度\n\n//初始化并查集\nvoid init(int n) {\n    for (int i = 0; i < n; i++) {\n        par[i] = i;\n        height[i] = 0;\n    }\n}\n\n//找出x所在树的根节点\nint find(int x) {\n    if (par[x] == x) {\n        return x;\n    } else {\n        return par[x] = find(par[x]); //把父节点直接指向根节点\n    }\n}\n\n//合并x,y所属的集合\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    \n    if (x == y)\n        return;\n    \n    //如果x所在集合树的高度小于y所在集合树的高度，那么将\n    //x的父节点指向y，反之亦然\n    //如果x，y所在集合的树的高度相等，那么随便怎么样都行，\n    //但是将最后指向的树的高度加一\n    if (height[x] < height[y]) {\n        par[x] = y;\n    } else {\n        par[y] = x;\n        if (height[x] == height[y])\n            height[x]++;\n    }\n}\n\nbool mycompare(edge e1, edge e2) {\n    return e1.val < e2.val;\n}\n\nvoid kruskal() {\n    sort(edges.begin(), edges.end(), mycompare);    //排序\n    \n    for (int i = 0; i < edges.size(); i++) {\n        cout<<edges[i].val<<endl;\n    }\n    init(V);        //初始化并查集\n    vector<edge> result;\n    \n    for (int i = 0; i < edges.size(); i++) {\n        if (find(edges[i].from) != find(edges[i].to)) {\n            result.push_back(edges[i]);\n            unite(edges[i].from, edges[i].to);\n        }\n    }\n    \n    for (int i = 0; i < result.size(); i++) {\n        cout<<result[i].from << '\\t' << result[i].to<<endl;\n    }\n}\n\nint main() {\n    /* example input\n4\n0 9 6 4\n9 0 7 x\n6 7 0 4\n4 x 4 0\n     */\n    cin>>V;\n    for (int i = 0; i < V; i++) {\n        for (int j = 0; j < V; j++) {\n            char w;\n            cin>>w;\n            if (i < j && w != 'x') { //支取上三角\n                edge e(i, j, w - '0');\n                edges.push_back(e);\n            }\n        }\n    }\n    kruskal();\n}\n```","source":"_posts/2014-10-26-kruskal.md","raw":"---\nlayout: post\ntitle:  \"图:最小生成树之kruskal算法\"\ndate:   2014-10-26 19:56:20\ncategories:   algorithms\ntags: [图]\n---\n\nkruskal法是一种贪心算法，与prim算法相似。\n\n在kruskal算法中，我们用到了并查集。\n\n算法的思想是这样的:\n\n1. 对所有的顶点建立一个并查集，对所有的边先进行排序\n2. 遍历每一条边，（因为我们之前对边进行排过序，所以我们每次都是选择最短的边），如果边的两个端点不在通一个集合里，那么该边属于最小生成树，将该边记录下来，然后将两个端点所在的集合合并\n3. 最后我们就得到了最小生成树的所有的边，因为我们每次都是选取可以选取的最小的边，所以kruskal算法也是贪心算法的一种。\n\n代码如下:\n\n``` cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nstruct edge {\n    int from, to;\n    int val;\n    edge(int from, int to, int val):from(from), to(to), val(val){}\n};\n\nconst int MAX_V = 5000; //最大边数\n\nint V;                  //边数\nvector<edge> edges;     //边\n\n//并查集\nint par[MAX_V];             //节点的父节点\nint height[MAX_V];          //树的高度\n\n//初始化并查集\nvoid init(int n) {\n    for (int i = 0; i < n; i++) {\n        par[i] = i;\n        height[i] = 0;\n    }\n}\n\n//找出x所在树的根节点\nint find(int x) {\n    if (par[x] == x) {\n        return x;\n    } else {\n        return par[x] = find(par[x]); //把父节点直接指向根节点\n    }\n}\n\n//合并x,y所属的集合\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    \n    if (x == y)\n        return;\n    \n    //如果x所在集合树的高度小于y所在集合树的高度，那么将\n    //x的父节点指向y，反之亦然\n    //如果x，y所在集合的树的高度相等，那么随便怎么样都行，\n    //但是将最后指向的树的高度加一\n    if (height[x] < height[y]) {\n        par[x] = y;\n    } else {\n        par[y] = x;\n        if (height[x] == height[y])\n            height[x]++;\n    }\n}\n\nbool mycompare(edge e1, edge e2) {\n    return e1.val < e2.val;\n}\n\nvoid kruskal() {\n    sort(edges.begin(), edges.end(), mycompare);    //排序\n    \n    for (int i = 0; i < edges.size(); i++) {\n        cout<<edges[i].val<<endl;\n    }\n    init(V);        //初始化并查集\n    vector<edge> result;\n    \n    for (int i = 0; i < edges.size(); i++) {\n        if (find(edges[i].from) != find(edges[i].to)) {\n            result.push_back(edges[i]);\n            unite(edges[i].from, edges[i].to);\n        }\n    }\n    \n    for (int i = 0; i < result.size(); i++) {\n        cout<<result[i].from << '\\t' << result[i].to<<endl;\n    }\n}\n\nint main() {\n    /* example input\n4\n0 9 6 4\n9 0 7 x\n6 7 0 4\n4 x 4 0\n     */\n    cin>>V;\n    for (int i = 0; i < V; i++) {\n        for (int j = 0; j < V; j++) {\n            char w;\n            cin>>w;\n            if (i < j && w != 'x') { //支取上三角\n                edge e(i, j, w - '0');\n                edges.push_back(e);\n            }\n        }\n    }\n    kruskal();\n}\n```","slug":"2014-10-26-kruskal","published":1,"updated":"2015-05-05T04:57:02.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck36002hrwmw2zyt50dz"},{"layout":"post","title":"线段树、平方分割:POJ 3264 Balanced Lineup","date":"2014-10-26T07:56:20.000Z","_content":"\n``` cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAX_HEIGHT = 2000000;\nconst int MIN_HEIGHT = 0;\nconst int MAX_N = 50000;\nint N, Q;\nint H[MAX_N + 1];\nvector<pair<int, int> > bucket; //first存储最大值，second存储最小值\n\nint main() {\n    cin>>N>>Q;\n    int bucket_size = sqrt((float)N);\n    bucket.resize(bucket_size + 1);\n    for (int i = 0; i <= bucket_size; i++) {\n        bucket[i].first = MIN_HEIGHT;\n        bucket[i].second = MAX_HEIGHT;\n    }\n    \n    for (int i = 1; i <= N; i++) {\n        cin>>H[i];\n        bucket[i / bucket_size].first = max(bucket[i / bucket_size].first, H[i]);\n        bucket[i / bucket_size].second = min(bucket[i / bucket_size].second, H[i]);\n    }\n    \n    for (int i = 0; i < Q; i++) {\n        int A, B;\n        cin>>A>>B;\n        if (A == B) {\n            cout<<0<<endl;\n            continue;\n        }\n\n        int daming = MIN_HEIGHT, xiaoming = MAX_HEIGHT;\n        \n        //如果A、B在一个桶\n        while (A <= B && A % bucket_size != 0) {\n            daming = max(H[A], daming);\n            xiaoming = min(H[A], xiaoming);\n            A++;\n        }\n        \n        while (A <= B && (B + 1) % bucket_size != 0) {\n            daming = max(H[B], daming);\n            xiaoming = min(H[B], xiaoming);\n            B--;\n        }\n        \n        while (A <= B) {\n            daming = max(bucket[A/bucket_size].first, daming);\n            xiaoming = min(bucket[A/bucket_size].second, xiaoming);\n            A += bucket_size;\n        }\n        \n        cout<<(daming - xiaoming)<<endl;\n    }\n}\n```","source":"_posts/2014-10-26-Balanced-Lineup.md","raw":"---\nlayout: post\ntitle:  \"线段树、平方分割:POJ 3264 Balanced Lineup\"\ndate:   2014-10-26 15:56:20\ncategories: algorithms\n---\n\n``` cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAX_HEIGHT = 2000000;\nconst int MIN_HEIGHT = 0;\nconst int MAX_N = 50000;\nint N, Q;\nint H[MAX_N + 1];\nvector<pair<int, int> > bucket; //first存储最大值，second存储最小值\n\nint main() {\n    cin>>N>>Q;\n    int bucket_size = sqrt((float)N);\n    bucket.resize(bucket_size + 1);\n    for (int i = 0; i <= bucket_size; i++) {\n        bucket[i].first = MIN_HEIGHT;\n        bucket[i].second = MAX_HEIGHT;\n    }\n    \n    for (int i = 1; i <= N; i++) {\n        cin>>H[i];\n        bucket[i / bucket_size].first = max(bucket[i / bucket_size].first, H[i]);\n        bucket[i / bucket_size].second = min(bucket[i / bucket_size].second, H[i]);\n    }\n    \n    for (int i = 0; i < Q; i++) {\n        int A, B;\n        cin>>A>>B;\n        if (A == B) {\n            cout<<0<<endl;\n            continue;\n        }\n\n        int daming = MIN_HEIGHT, xiaoming = MAX_HEIGHT;\n        \n        //如果A、B在一个桶\n        while (A <= B && A % bucket_size != 0) {\n            daming = max(H[A], daming);\n            xiaoming = min(H[A], xiaoming);\n            A++;\n        }\n        \n        while (A <= B && (B + 1) % bucket_size != 0) {\n            daming = max(H[B], daming);\n            xiaoming = min(H[B], xiaoming);\n            B--;\n        }\n        \n        while (A <= B) {\n            daming = max(bucket[A/bucket_size].first, daming);\n            xiaoming = min(bucket[A/bucket_size].second, xiaoming);\n            A += bucket_size;\n        }\n        \n        cout<<(daming - xiaoming)<<endl;\n    }\n}\n```","slug":"2014-10-26-Balanced-Lineup","published":1,"updated":"2015-04-30T12:10:39.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck38002lrwmw1k18101h"},{"layout":"post","title":"图:最小生成树之Prim算法","date":"2014-10-25T03:11:20.000Z","_content":"\n```\n    贪心算法之最小生成树\n\n    伪代码：\n    MST-PRIM（G, w, r）\n    for each u in V[G]\n        do key[u] <- INF\n        pi[u] <- NIL\n    key[r] <- 0\n    Q <- V[G]\n    while Q != EMPTY\n        do u <- EXTRACT-MIN(Q)\n        for each v in Adj[u]\n            do if v in Q and w(u, v) < key[v]\n                then pi[v] <- u\n                key[v] = w(u,v)\n```\n\n下面的代码是完全依据算导上的伪代码写的，优先级队列也是自己写代码实现的，由于要更新队列中的节点，所以不能够使用STL中得优先级队列。\n\n``` cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define INF 10000\n#define NIL -1\n#define MAX_V 1000      //最大顶点数\nint G[MAX_V][MAX_V];    //图\nint N;                  //顶点个数\n\n//节点\nstruct Node {\n    Node(int vertex = 0, int key = INF) : vertex(vertex), key(key) {}\n    \n    int vertex;\n    int key;\n};\n\nvoid swap(Node &a, Node &b) {\n    Node tmp = a;\n    a = b;\n    b = tmp;\n}\n\n//对优先队列进行MIN_HEAPIFY操作，使队列保持最小堆的性质\nvoid minHeapify(vector<Node> &Q, int i) {\n    int left = 2 * i;\n    int right = 2 * i + 1;\n    int min = i;\n    \n    if (left <= Q.size() && Q[left-1].key < Q[i-1].key) {\n        min = left;\n    }\n    if (right <= Q.size() && Q[right-1].key < Q[min-1].key) {\n        min = right;\n    }\n    if (min != i) {\n        swap(Q[min - 1], Q[i - 1]);\n        minHeapify(Q, min);\n    }\n}\n\n//取出优先队列中最小的\nNode extractMin(vector<Node> &Q) {\n    Node min = NULL;\n    \n    if (Q.size() < 1) {\n        return min;\n    }\n    min = Q[0];\n    Q[0] = Q[Q.size() - 1];\n    Q.pop_back();\n    minHeapify(Q, 1);\n    \n    return min;\n}\n\n//DECERSE-KEY\nvoid decreaseKey(vector<Node> &Q, int i, int key) {\n    if (Q[i].key < key) {\n        return;\n    }\n    \n    Q[i].key = key;\n    while (i > 0 && Q[(i + 1)/2 - 1].key > key) {\n        swap(Q[i], Q[(i + 1)/2 - 1]);\n        i = (i + 1)/2 - 1;\n    }\n}\n\nvoid prim() {\n    vector<Node> Q;\t//queue\n    vector<int> P;  //parents\n    \n    for (int i=0; i != N; i++) {\n        Q.push_back(Node(i));\n        P.push_back(NIL);\n    }\n    Q[0].key = 0;\n    \n    while (Q.size() > 0) {\n        Node u = extractMin(Q);\n        for (int j = 0; j != Q.size(); j++) {\n            if (Q[j].key > G[u.vertex][Q[j].vertex]) {\n                P[Q[j].vertex] = u.vertex;\n                decreaseKey(Q, j, G[u.vertex][Q[j].vertex]);\n            }\n        }\n    }\n    \n    for (vector<int>::size_type j = 0; j != P.size(); j++) {\n        cout<<P[j]<<endl;\n    }\n}\n\nint main() {\n    /* example input\n     4\n     0 9 6 4\n     9 0 7 x\n     6 7 0 4\n     4 x 4 0\n     */\n    cin>>N;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            char w;\n            cin>>w;\n            if (w == 'x') {\n                G[i][j] = INF;\n            } else {\n                G[i][j] = (w - '0');\n            }\n        }\n    }\n    prim();\n}\n```\n\n在下面的方法中，使用了STL中得优先级队列，因为我们只对队列进行push和pop操作，而没有对队列中的节点进行更新。但是只对队列进行push操作的话可能会对同一个元素进行多次push，所以在进行pop操作的时候对元素进行判断，如果这个元素已经pop过了，对重复的元素不进行任何操作。\n\n为了实现这个想法，我们使用keys数组来存储到节点的最短的边，初始值赋为INF，如果pop一个顶点更新与其相邻的节点时，若该顶点到相邻顶点的距离要小于keys数组中记录的相邻顶点的最短边的距离，那么更新keys数组，并且将该节点赋为相邻顶点的父节点，push该节点。\n\n在pop的过程中，如果节点的key值大于keys中的值，那么说明该节点已经被pop过了，不进行任何操作。因为优先级队列中key小的先被pop，而节点key的值大于keys中的值，只可能是这个节点被push过多次。但是pop到该节点时，该节点的key值较小的已经被pop过了。\n\n``` cpp\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define INF 10000\n#define NIL -1\n#define MAX_V 1000      //最大顶点数\nint G[MAX_V][MAX_V];    //图\nint N;                  //顶点个数\n\n//节点\nstruct Node {\n    Node(int vertex = 0, int key = INF) : vertex(vertex), key(key) {}\n    \n    int vertex;\n    int key;\n};\n\nclass MinHeap\n{\npublic:\n    bool operator() (const Node *a, const Node *b) const\n    {\n        return (a->key > b->key);\n    }\n};\n\nvoid prim() {\n    priority_queue<Node *, vector<Node *>, MinHeap> Q;      //queue\n    Q.push(new Node(0, 1));\n    Q.push(new Node(0, 2));\n    vector<int> P(N, -1);                                   //parents\n    vector<int> keys(N, INF);                               //每个点最短的边\n    Node *node = new Node(0, 0);                            //以node 0为起点\n    Q.push(node);\n    keys[0] = 0;\n    \n    while (Q.size() > 0) {\n        Node *top = Q.top();\n        Q.pop();\n        \n        if (top->key > keys[top->vertex]) continue;\n        \n        //对每一个相邻的节点，如果该节点到相邻节点的距离要小于keys中存储\n        //的距离，那么更新keys中的值，并且push该节点\n        for (int i = 0; i < N; i++) {\n            if (G[top->vertex][i] != 0) {\n                if (G[top->vertex][i] < keys[i]) {\n                    P[i] = top->vertex;\n                    keys[i] = G[top->vertex][i];\n                    Q.push(new Node(i, G[top->vertex][i]));\n                }\n            }\n        }\n    }\n    \n    for (vector<int>::size_type j = 0; j != P.size(); j++) {\n        cout<<P[j]<<endl;\n    }\n}\n\nint main() {\n    /* example input\n     4\n     0 9 6 4\n     9 0 7 x\n     6 7 0 4\n     4 x 4 0\n     */\n    cin>>N;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            char w;\n            cin>>w;\n            if (w == 'x') {\n                G[i][j] = INF;\n            } else {\n                G[i][j] = (w - '0');\n            }\n        }\n    }\n    prim();\n}\n```","source":"_posts/2014-10-25-prim-mst.md","raw":"---\nlayout: post\ntitle:  \"图:最小生成树之Prim算法\"\ndate:   2014-10-25 11:11:20\ncategories:   algorithms\ntags: [图]\n---\n\n```\n    贪心算法之最小生成树\n\n    伪代码：\n    MST-PRIM（G, w, r）\n    for each u in V[G]\n        do key[u] <- INF\n        pi[u] <- NIL\n    key[r] <- 0\n    Q <- V[G]\n    while Q != EMPTY\n        do u <- EXTRACT-MIN(Q)\n        for each v in Adj[u]\n            do if v in Q and w(u, v) < key[v]\n                then pi[v] <- u\n                key[v] = w(u,v)\n```\n\n下面的代码是完全依据算导上的伪代码写的，优先级队列也是自己写代码实现的，由于要更新队列中的节点，所以不能够使用STL中得优先级队列。\n\n``` cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define INF 10000\n#define NIL -1\n#define MAX_V 1000      //最大顶点数\nint G[MAX_V][MAX_V];    //图\nint N;                  //顶点个数\n\n//节点\nstruct Node {\n    Node(int vertex = 0, int key = INF) : vertex(vertex), key(key) {}\n    \n    int vertex;\n    int key;\n};\n\nvoid swap(Node &a, Node &b) {\n    Node tmp = a;\n    a = b;\n    b = tmp;\n}\n\n//对优先队列进行MIN_HEAPIFY操作，使队列保持最小堆的性质\nvoid minHeapify(vector<Node> &Q, int i) {\n    int left = 2 * i;\n    int right = 2 * i + 1;\n    int min = i;\n    \n    if (left <= Q.size() && Q[left-1].key < Q[i-1].key) {\n        min = left;\n    }\n    if (right <= Q.size() && Q[right-1].key < Q[min-1].key) {\n        min = right;\n    }\n    if (min != i) {\n        swap(Q[min - 1], Q[i - 1]);\n        minHeapify(Q, min);\n    }\n}\n\n//取出优先队列中最小的\nNode extractMin(vector<Node> &Q) {\n    Node min = NULL;\n    \n    if (Q.size() < 1) {\n        return min;\n    }\n    min = Q[0];\n    Q[0] = Q[Q.size() - 1];\n    Q.pop_back();\n    minHeapify(Q, 1);\n    \n    return min;\n}\n\n//DECERSE-KEY\nvoid decreaseKey(vector<Node> &Q, int i, int key) {\n    if (Q[i].key < key) {\n        return;\n    }\n    \n    Q[i].key = key;\n    while (i > 0 && Q[(i + 1)/2 - 1].key > key) {\n        swap(Q[i], Q[(i + 1)/2 - 1]);\n        i = (i + 1)/2 - 1;\n    }\n}\n\nvoid prim() {\n    vector<Node> Q;\t//queue\n    vector<int> P;  //parents\n    \n    for (int i=0; i != N; i++) {\n        Q.push_back(Node(i));\n        P.push_back(NIL);\n    }\n    Q[0].key = 0;\n    \n    while (Q.size() > 0) {\n        Node u = extractMin(Q);\n        for (int j = 0; j != Q.size(); j++) {\n            if (Q[j].key > G[u.vertex][Q[j].vertex]) {\n                P[Q[j].vertex] = u.vertex;\n                decreaseKey(Q, j, G[u.vertex][Q[j].vertex]);\n            }\n        }\n    }\n    \n    for (vector<int>::size_type j = 0; j != P.size(); j++) {\n        cout<<P[j]<<endl;\n    }\n}\n\nint main() {\n    /* example input\n     4\n     0 9 6 4\n     9 0 7 x\n     6 7 0 4\n     4 x 4 0\n     */\n    cin>>N;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            char w;\n            cin>>w;\n            if (w == 'x') {\n                G[i][j] = INF;\n            } else {\n                G[i][j] = (w - '0');\n            }\n        }\n    }\n    prim();\n}\n```\n\n在下面的方法中，使用了STL中得优先级队列，因为我们只对队列进行push和pop操作，而没有对队列中的节点进行更新。但是只对队列进行push操作的话可能会对同一个元素进行多次push，所以在进行pop操作的时候对元素进行判断，如果这个元素已经pop过了，对重复的元素不进行任何操作。\n\n为了实现这个想法，我们使用keys数组来存储到节点的最短的边，初始值赋为INF，如果pop一个顶点更新与其相邻的节点时，若该顶点到相邻顶点的距离要小于keys数组中记录的相邻顶点的最短边的距离，那么更新keys数组，并且将该节点赋为相邻顶点的父节点，push该节点。\n\n在pop的过程中，如果节点的key值大于keys中的值，那么说明该节点已经被pop过了，不进行任何操作。因为优先级队列中key小的先被pop，而节点key的值大于keys中的值，只可能是这个节点被push过多次。但是pop到该节点时，该节点的key值较小的已经被pop过了。\n\n``` cpp\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define INF 10000\n#define NIL -1\n#define MAX_V 1000      //最大顶点数\nint G[MAX_V][MAX_V];    //图\nint N;                  //顶点个数\n\n//节点\nstruct Node {\n    Node(int vertex = 0, int key = INF) : vertex(vertex), key(key) {}\n    \n    int vertex;\n    int key;\n};\n\nclass MinHeap\n{\npublic:\n    bool operator() (const Node *a, const Node *b) const\n    {\n        return (a->key > b->key);\n    }\n};\n\nvoid prim() {\n    priority_queue<Node *, vector<Node *>, MinHeap> Q;      //queue\n    Q.push(new Node(0, 1));\n    Q.push(new Node(0, 2));\n    vector<int> P(N, -1);                                   //parents\n    vector<int> keys(N, INF);                               //每个点最短的边\n    Node *node = new Node(0, 0);                            //以node 0为起点\n    Q.push(node);\n    keys[0] = 0;\n    \n    while (Q.size() > 0) {\n        Node *top = Q.top();\n        Q.pop();\n        \n        if (top->key > keys[top->vertex]) continue;\n        \n        //对每一个相邻的节点，如果该节点到相邻节点的距离要小于keys中存储\n        //的距离，那么更新keys中的值，并且push该节点\n        for (int i = 0; i < N; i++) {\n            if (G[top->vertex][i] != 0) {\n                if (G[top->vertex][i] < keys[i]) {\n                    P[i] = top->vertex;\n                    keys[i] = G[top->vertex][i];\n                    Q.push(new Node(i, G[top->vertex][i]));\n                }\n            }\n        }\n    }\n    \n    for (vector<int>::size_type j = 0; j != P.size(); j++) {\n        cout<<P[j]<<endl;\n    }\n}\n\nint main() {\n    /* example input\n     4\n     0 9 6 4\n     9 0 7 x\n     6 7 0 4\n     4 x 4 0\n     */\n    cin>>N;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            char w;\n            cin>>w;\n            if (w == 'x') {\n                G[i][j] = INF;\n            } else {\n                G[i][j] = (w - '0');\n            }\n        }\n    }\n    prim();\n}\n```","slug":"2014-10-25-prim-mst","published":1,"updated":"2015-05-05T04:57:21.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck3a002nrwmwxbwrx0k4"},{"layout":"post","title":"二叉树的普通非递归遍历","date":"2014-10-23T13:16:20.000Z","_content":"\n这里给出二叉树的普通非递归遍历：\n\n``` cpp\n#include <iostream>\n#include <queue>\n#include <stack>\nusing namespace std;\n\n//二叉树的节点\nstruct Node {\n    int val;\n    Node *lch, *rch;\n    Node(int x):val(x), lch(NULL), rch(NULL) {}\n};\n\n//前序遍历\n/*\n 前序遍历就是先访问当前节点，然后依次访问左子结点，右子节点\n 所以很简单，我们就直接用一个栈先压入右子节点，然后压入左子结点就可以了\n */\nvoid preorderTraversal(Node *root) {\n    stack<Node *> s;\n    Node *cur;          //当前访问节点\n    \n    if (root != NULL)   //如果根节点不为空，压栈\n        s.push(root);\n    \n    while (!s.empty()) {    //如果栈不为空\n        cur = s.top();      //输出当前访问节点\n        s.pop();\n        cout<<cur->val;\n        \n        //依次将右子节点，左子结点压栈\n        if (cur->rch != NULL)\n            s.push(cur->rch);\n        if (cur->lch != NULL)\n            s.push(cur->lch);\n    }\n}\n\n\n//后序遍历的非递归实现\n/*\n 后序遍历就是先访问节点的左子结点和右子节点，再访问当前节点\n 如果不用递归，我们就可以用栈，我们可以依次将当前节点、右子节点和左子结点入栈，\n 然后再弹栈\n 但是这里又有另一个问题，如果我们访问到了一个节点，可是我们不知道到底是应该将它的两个子节点\n 压栈还是该将它弹出。因此就需要一个辅助的节点来记录上一个弹出的节点，如果被弹出的上一个节点\n 是它的一个子节点，那么说明前面已经将该节点的子节点压栈了，现在该将它弹出。问题就解决了。\n */\nvoid postorderTraversal(Node *root) {\n    stack<Node *> s;\n    Node *pre = NULL;   //已经输出过的前一个节点\n    Node *cur = NULL;   //当前访问的节点\n    \n    if (root != NULL)\n        s.push(root);       //首先将根节点压栈\n    \n    while (!s.empty()) {\n        cur = s.top();  //获取栈顶的节点\n        \n        if ((cur->lch == NULL && cur->rch == NULL) ||\n            (pre != NULL && (cur->lch == pre || cur->rch == pre))) {\n            //如果当前的节点既没有左子结点又没有右子节点\n            //或者当前节点的子节点已经被输出过，即已经是第二次经过该节点了\n            //输出当前节点，并且将当前节点赋给pre\n            cout<<cur->val;\n            s.pop();\n            pre = cur;\n        } else {\n            //依次将右子节点和左子结点入栈\n            if (cur->rch != NULL)\n                s.push(cur->rch);\n\n            if (cur->lch != NULL)\n                s.push(cur->lch);\n        }\n    }\n}\n\n//中序遍历\n/*\n 中序遍历不能像后序遍历一样记录前一个访问的节点，因为前一个访问的节点并不是要访问的节点的\n 直接子节点，所以又得换种方法：\n 我们用一个节点记录当前访问的节点，然后用一个栈记录上一个访问过的节点。如果当前的节点不为空，\n 那么向下访问左子结点。\n 如果当前访问的节点为空，说明上一个访问的节点已经没有左子结点了，那么输出上一个节点，\n 然后访问上一个节点的右子节点。\n */\nvoid inorderTraversal(Node *root) {\n    stack<Node *> s;\n    Node *cur = root;       //当前访问节点\n    \n    while (!s.empty() || cur != NULL) { //如果当前访问节点与栈都不为空\n        if (cur != NULL) {\n            //如果当前节点不为空，那么继续往下访问左子结点，并将当前节点压栈\n            s.push(cur);\n            cur = cur->lch;\n        } else {\n            //如果当前节点为空，那么从栈顶弹出节点，并输出该节点，然后继续往下访问\n            //右子节点\n            cur = s.top();\n            s.pop();\n            \n            cout<<cur->val;\n            cur = cur->rch;\n        }\n    }\n}\n\n//层序遍历\n//层序遍历跟前序遍历差不多，就是把栈换成了队列，然后左右子节点入队的顺序交换了一下\nvoid levelorderTraversal(Node *root) {\n    queue<Node *> que;\n    Node *cur;\n    \n    if (root != NULL)\n        que.push(root);\n    \n    while (!que.empty()) {\n        cur = que.front();\n        cout<<cur->val;\n        que.pop();\n        \n        if (cur->lch != NULL)\n            que.push(cur->lch);\n        if (cur->rch != NULL)\n            que.push(cur->rch);\n    }\n}\n\nint main() {\n    Node root(1);\n    Node c1(2);\n    Node c2(3);\n    Node c3(4);\n    Node c4(5);\n    Node c5(6);\n    root.lch = &c1;\n    root.rch = &c2;\n    c1.lch = &c3;\n    c1.rch = &c4;\n    c2.lch = &c5;\n\n    preorderTraversal(&root);\n    postorderTraversal(&root);\n    inorderTraversal(&root);\n    levelorderTraversal(&root);\n}\n```","source":"_posts/2014-10-24-binary-tree-traversal.md","raw":"---\nlayout: post\ntitle:  \"二叉树的普通非递归遍历\"\ndate:   2014-10-23 21:16:20\ncategories:   algorithms\ntags: [二叉树]\n---\n\n这里给出二叉树的普通非递归遍历：\n\n``` cpp\n#include <iostream>\n#include <queue>\n#include <stack>\nusing namespace std;\n\n//二叉树的节点\nstruct Node {\n    int val;\n    Node *lch, *rch;\n    Node(int x):val(x), lch(NULL), rch(NULL) {}\n};\n\n//前序遍历\n/*\n 前序遍历就是先访问当前节点，然后依次访问左子结点，右子节点\n 所以很简单，我们就直接用一个栈先压入右子节点，然后压入左子结点就可以了\n */\nvoid preorderTraversal(Node *root) {\n    stack<Node *> s;\n    Node *cur;          //当前访问节点\n    \n    if (root != NULL)   //如果根节点不为空，压栈\n        s.push(root);\n    \n    while (!s.empty()) {    //如果栈不为空\n        cur = s.top();      //输出当前访问节点\n        s.pop();\n        cout<<cur->val;\n        \n        //依次将右子节点，左子结点压栈\n        if (cur->rch != NULL)\n            s.push(cur->rch);\n        if (cur->lch != NULL)\n            s.push(cur->lch);\n    }\n}\n\n\n//后序遍历的非递归实现\n/*\n 后序遍历就是先访问节点的左子结点和右子节点，再访问当前节点\n 如果不用递归，我们就可以用栈，我们可以依次将当前节点、右子节点和左子结点入栈，\n 然后再弹栈\n 但是这里又有另一个问题，如果我们访问到了一个节点，可是我们不知道到底是应该将它的两个子节点\n 压栈还是该将它弹出。因此就需要一个辅助的节点来记录上一个弹出的节点，如果被弹出的上一个节点\n 是它的一个子节点，那么说明前面已经将该节点的子节点压栈了，现在该将它弹出。问题就解决了。\n */\nvoid postorderTraversal(Node *root) {\n    stack<Node *> s;\n    Node *pre = NULL;   //已经输出过的前一个节点\n    Node *cur = NULL;   //当前访问的节点\n    \n    if (root != NULL)\n        s.push(root);       //首先将根节点压栈\n    \n    while (!s.empty()) {\n        cur = s.top();  //获取栈顶的节点\n        \n        if ((cur->lch == NULL && cur->rch == NULL) ||\n            (pre != NULL && (cur->lch == pre || cur->rch == pre))) {\n            //如果当前的节点既没有左子结点又没有右子节点\n            //或者当前节点的子节点已经被输出过，即已经是第二次经过该节点了\n            //输出当前节点，并且将当前节点赋给pre\n            cout<<cur->val;\n            s.pop();\n            pre = cur;\n        } else {\n            //依次将右子节点和左子结点入栈\n            if (cur->rch != NULL)\n                s.push(cur->rch);\n\n            if (cur->lch != NULL)\n                s.push(cur->lch);\n        }\n    }\n}\n\n//中序遍历\n/*\n 中序遍历不能像后序遍历一样记录前一个访问的节点，因为前一个访问的节点并不是要访问的节点的\n 直接子节点，所以又得换种方法：\n 我们用一个节点记录当前访问的节点，然后用一个栈记录上一个访问过的节点。如果当前的节点不为空，\n 那么向下访问左子结点。\n 如果当前访问的节点为空，说明上一个访问的节点已经没有左子结点了，那么输出上一个节点，\n 然后访问上一个节点的右子节点。\n */\nvoid inorderTraversal(Node *root) {\n    stack<Node *> s;\n    Node *cur = root;       //当前访问节点\n    \n    while (!s.empty() || cur != NULL) { //如果当前访问节点与栈都不为空\n        if (cur != NULL) {\n            //如果当前节点不为空，那么继续往下访问左子结点，并将当前节点压栈\n            s.push(cur);\n            cur = cur->lch;\n        } else {\n            //如果当前节点为空，那么从栈顶弹出节点，并输出该节点，然后继续往下访问\n            //右子节点\n            cur = s.top();\n            s.pop();\n            \n            cout<<cur->val;\n            cur = cur->rch;\n        }\n    }\n}\n\n//层序遍历\n//层序遍历跟前序遍历差不多，就是把栈换成了队列，然后左右子节点入队的顺序交换了一下\nvoid levelorderTraversal(Node *root) {\n    queue<Node *> que;\n    Node *cur;\n    \n    if (root != NULL)\n        que.push(root);\n    \n    while (!que.empty()) {\n        cur = que.front();\n        cout<<cur->val;\n        que.pop();\n        \n        if (cur->lch != NULL)\n            que.push(cur->lch);\n        if (cur->rch != NULL)\n            que.push(cur->rch);\n    }\n}\n\nint main() {\n    Node root(1);\n    Node c1(2);\n    Node c2(3);\n    Node c3(4);\n    Node c4(5);\n    Node c5(6);\n    root.lch = &c1;\n    root.rch = &c2;\n    c1.lch = &c3;\n    c1.rch = &c4;\n    c2.lch = &c5;\n\n    preorderTraversal(&root);\n    postorderTraversal(&root);\n    inorderTraversal(&root);\n    levelorderTraversal(&root);\n}\n```","slug":"2014-10-24-binary-tree-traversal","published":1,"updated":"2015-05-04T13:45:10.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck3c002qrwmwqopvrpdj"},{"layout":"post","title":"堆排序: Merge k Sorted Lists","date":"2014-10-23T09:10:20.000Z","_content":"\nMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\n\n这个题如果按照常规思路来做得话，就是将k个链表两两合并，但是这样做的时间复杂度高.\n\n所以我们可以找时间复杂度更小一点的思路：\n\n我们如果把k个链表一起合并，那么我们第一个加入链表的就是这k个链表首节点中最小的。并且每次都是这样。这种思路和\n优先级队列是一样的，每次取出最小值。因此我们可以使用优先级队列来做。\n\n``` cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\n \nclass MinHeap\n{\npublic:\n    bool operator() (const ListNode *lhs, const ListNode *rhs) const\n    {\n        return (lhs->val > rhs->val);\n    }\n};\n\nclass Solution {\npublic:\n    ListNode *mergeKLists(vector<ListNode *> &lists) {\n        if (lists.size() == 0) return NULL;\n        \n        //使用每一个链表的头结点构建一个最小堆\n        priority_queue<ListNode *, vector<ListNode *>, MinHeap> que;\n        for (int i = 0; i < lists.size(); i++) {\n            if (lists[i] != NULL) \n                que.push(lists[i]);\n        }\n        ListNode dummy(-1);\n        ListNode *tail = &dummy;\n        \n        //如果队列不为空\n        while(!que.empty()) {\n            ListNode *top = que.top();\n            que.pop();\n            \n            //链接最小节点\n            tail->next = top;\n            tail = top;\n            \n            //如果出列的节点还有下一个节点，那么再将下一个节点入列，构建堆\n            if (top->next != NULL) {\n                que.push(top->next);\n            }\n        }\n        \n        return dummy.next;\n    }\n};\n```\n","source":"_posts/2014-10-23-leetcode-Merge-k-Sorted-Lists.md","raw":"---\nlayout: post\ntitle:  \"堆排序: Merge k Sorted Lists\"\ndate:   2014-10-23 17:10:20\ncategories: problems\n---\n\nMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\n\n这个题如果按照常规思路来做得话，就是将k个链表两两合并，但是这样做的时间复杂度高.\n\n所以我们可以找时间复杂度更小一点的思路：\n\n我们如果把k个链表一起合并，那么我们第一个加入链表的就是这k个链表首节点中最小的。并且每次都是这样。这种思路和\n优先级队列是一样的，每次取出最小值。因此我们可以使用优先级队列来做。\n\n``` cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\n \nclass MinHeap\n{\npublic:\n    bool operator() (const ListNode *lhs, const ListNode *rhs) const\n    {\n        return (lhs->val > rhs->val);\n    }\n};\n\nclass Solution {\npublic:\n    ListNode *mergeKLists(vector<ListNode *> &lists) {\n        if (lists.size() == 0) return NULL;\n        \n        //使用每一个链表的头结点构建一个最小堆\n        priority_queue<ListNode *, vector<ListNode *>, MinHeap> que;\n        for (int i = 0; i < lists.size(); i++) {\n            if (lists[i] != NULL) \n                que.push(lists[i]);\n        }\n        ListNode dummy(-1);\n        ListNode *tail = &dummy;\n        \n        //如果队列不为空\n        while(!que.empty()) {\n            ListNode *top = que.top();\n            que.pop();\n            \n            //链接最小节点\n            tail->next = top;\n            tail = top;\n            \n            //如果出列的节点还有下一个节点，那么再将下一个节点入列，构建堆\n            if (top->next != NULL) {\n                que.push(top->next);\n            }\n        }\n        \n        return dummy.next;\n    }\n};\n```\n","slug":"2014-10-23-leetcode-Merge-k-Sorted-Lists","published":1,"updated":"2015-04-30T12:11:22.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck3f002trwmwb7z12uxm"},{"layout":"post","title":"c语言的一些需要注意的小问题","date":"2014-10-23T01:35:20.000Z","_content":"\n### \\#define square(x) x * x\n\n如果执行的是square(z + 1),那么替换后的结果为z + 1*z + 1，结果是不对的，所以使用宏的时候还是得非常小心。 \n\n### c++中auto的使用\n\n根据初始化表达式自动推断被声明的变量的类型，如：\n\n``` cpp\n auto f=3.14;      //double\n auto s(\"hello\");  //const char*\n auto z = new auto(9); // int*\n auto x1 = 5, x2 = 5.0, x3='r';//错误，必须是初始化为同一类型\n```\nauto关键字更适用于类型冗长复杂、变量使用范围专一时，使程序更清晰易读：\n``` cpp\n std::vector<int> vect; \n for(auto it = vect.begin(); it != vect.end(); ++it)\n {  //it的类型是std::vector<int>::iterator\n    std::cin >> *it;\n }\n```","source":"_posts/2014-10-23-c-traps.md","raw":"---\nlayout: post\ntitle:  \"c语言的一些需要注意的小问题\"\ndate:   2014-10-23 09:35:20\ncategories:   cpp\n---\n\n### \\#define square(x) x * x\n\n如果执行的是square(z + 1),那么替换后的结果为z + 1*z + 1，结果是不对的，所以使用宏的时候还是得非常小心。 \n\n### c++中auto的使用\n\n根据初始化表达式自动推断被声明的变量的类型，如：\n\n``` cpp\n auto f=3.14;      //double\n auto s(\"hello\");  //const char*\n auto z = new auto(9); // int*\n auto x1 = 5, x2 = 5.0, x3='r';//错误，必须是初始化为同一类型\n```\nauto关键字更适用于类型冗长复杂、变量使用范围专一时，使程序更清晰易读：\n``` cpp\n std::vector<int> vect; \n for(auto it = vect.begin(); it != vect.end(); ++it)\n {  //it的类型是std::vector<int>::iterator\n    std::cin >> *it;\n }\n```","slug":"2014-10-23-c-traps","published":1,"updated":"2015-04-30T11:35:09.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck3h002vrwmwqg1hdtqg"},{"layout":"post","title":"图：拓扑排序(Topological sort)","date":"2014-10-23T13:16:20.000Z","_content":"\n由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序。\n\n+ 每个顶点出现且只出现一次；\n+ 若A在序列中排在B的前面，则在图中不存在从B到A的路径。\n\n也可以定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点A到顶点B的路径，那么在排序中B出现在A的后面。\n\n拓扑排序一般用在工作流中，即跟顺序有关的事情中。比如我要穿衣服，那么我得先穿袜子，再穿裤子，最后穿鞋子。拓扑排序就是用来解决这类问题的。\n\n拓扑排序一般使用DFS来实现。思路如下：\n\n\nTOPOLOGICAL-SORT(G)\n\n1. call DFS(G) to visit the G\n2. as each vetex is finished, pushi it into the stack\n3. return \n\n由上可以看出，每次当遍历完一个节点的所有子节点时，将该节点压栈，到最后就会得到一个拓扑序。\n\n为什么呢，我们假设有一个最简单的图：\n\n```\n\t1->2->3->4\n```\n\n那么遍历完每一个节点的所有子节点的顺序应该是4，3，2，1.即我们先遍历完4的所有子节点，最后才遍历完1的所有子节点。这也是我们为什么要用栈而不用队列的原因。\n\n代码如下：\n\n``` cpp\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nconst int MAX_V = 1000;      //最大的顶点数\n\nvector<int> G[MAX_V];   //图的邻接表形式\nint V;                  //顶点数\nint E;                  //边数\nint status[MAX_V];      //顶点的状态数组\nstack<int> topology;\n\nvoid dfs(int s) {\n    status[s] = 1;      //顶点s已经访问过\n    for (int v = 0; v < G[s].size(); v ++) {\n        int to = G[s][v];\n        if (status[to] == 0)\n            dfs(to);\n    }\n    topology.push(s);   //当访问完所有子节点时，将节点入栈\n}\n\nint main() {\n    cin>>V;\n    cin>>E;\n    for (int i = 0; i < E; i++) {\n        int a, b;\n        cin>>a>>b;\n        G[a - 1].push_back(b - 1);\n    }\n    \n    fill(status, status + V, 0);\n    for (int i = 0; i < V; i++) {\n        if (status[i] == 0)\n            dfs(i);\n    }\n    \n    while (!topology.empty()) {\n        cout<<topology.top() + 1<<endl;\n        topology.pop();\n    }\n}\n```","source":"_posts/2014-10-23-Topological-sorting.md","raw":"---\nlayout: post\ntitle:  \"图：拓扑排序(Topological sort)\"\ndate:   2014-10-23 21:16:20\ncategories:   algorithms\ntags: [图]\n---\n\n由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序。\n\n+ 每个顶点出现且只出现一次；\n+ 若A在序列中排在B的前面，则在图中不存在从B到A的路径。\n\n也可以定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点A到顶点B的路径，那么在排序中B出现在A的后面。\n\n拓扑排序一般用在工作流中，即跟顺序有关的事情中。比如我要穿衣服，那么我得先穿袜子，再穿裤子，最后穿鞋子。拓扑排序就是用来解决这类问题的。\n\n拓扑排序一般使用DFS来实现。思路如下：\n\n\nTOPOLOGICAL-SORT(G)\n\n1. call DFS(G) to visit the G\n2. as each vetex is finished, pushi it into the stack\n3. return \n\n由上可以看出，每次当遍历完一个节点的所有子节点时，将该节点压栈，到最后就会得到一个拓扑序。\n\n为什么呢，我们假设有一个最简单的图：\n\n```\n\t1->2->3->4\n```\n\n那么遍历完每一个节点的所有子节点的顺序应该是4，3，2，1.即我们先遍历完4的所有子节点，最后才遍历完1的所有子节点。这也是我们为什么要用栈而不用队列的原因。\n\n代码如下：\n\n``` cpp\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nconst int MAX_V = 1000;      //最大的顶点数\n\nvector<int> G[MAX_V];   //图的邻接表形式\nint V;                  //顶点数\nint E;                  //边数\nint status[MAX_V];      //顶点的状态数组\nstack<int> topology;\n\nvoid dfs(int s) {\n    status[s] = 1;      //顶点s已经访问过\n    for (int v = 0; v < G[s].size(); v ++) {\n        int to = G[s][v];\n        if (status[to] == 0)\n            dfs(to);\n    }\n    topology.push(s);   //当访问完所有子节点时，将节点入栈\n}\n\nint main() {\n    cin>>V;\n    cin>>E;\n    for (int i = 0; i < E; i++) {\n        int a, b;\n        cin>>a>>b;\n        G[a - 1].push_back(b - 1);\n    }\n    \n    fill(status, status + V, 0);\n    for (int i = 0; i < V; i++) {\n        if (status[i] == 0)\n            dfs(i);\n    }\n    \n    while (!topology.empty()) {\n        cout<<topology.top() + 1<<endl;\n        topology.pop();\n    }\n}\n```","slug":"2014-10-23-Topological-sorting","published":1,"updated":"2015-05-05T04:57:30.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck3l002xrwmw137s17hg"},{"layout":"post","title":"四则运算计算器实现","date":"2014-10-20T07:52:20.000Z","_content":"\n##波兰表示法与逆波兰表示法\n\n*波兰表示法*（Polish notation，或波兰记法），是一种逻辑、算术和代数表示方法，其特点是操作符置于操作数的前面，因此也称做前缀表示法。与逆波兰表示法不同，前缀表达式基本没有在商业计算器中使用过，但是其体系经常在编译器构造的概念教学中首先使用。\n\n*逆波兰表示法*（Reverse Polish notation，RPN，或逆波兰记法）中所有操作符置于操作数的后面，因此也被称为后缀表示法。逆波兰记法不需要括号来标识操作符的优先级。\n\n逆波兰记法中，操作符置于操作数的后面。例如表达“三加四”时，写作“3 4 +”，而不是“3 + 4”。如果有多个操作符，操作符置于第二个操作数的后面，所以常规中缀记法的“3 - 4 + 5”在逆波兰记法中写作“3 4 - 5 +”：先3减去4，再加上5。使用逆波兰记法的一个好处是不需要使用括号。例如中缀记法中“3 - 4 * 5”与“（3 - 4）*5”不相同，但后缀记法中前者写做“3 4 5 * -”，无歧义地表示“3 (4 5 *) −”；后者写做“3 4 - 5 *”。\n\n逆波兰表达式的解释器一般是基于堆栈的。解释过程一般是：操作数入栈；遇到操作符时，操作数出栈，求值，将结果入栈；当一遍后，栈顶就是表达式的值。因此逆波兰表达式的求值使用堆栈结构很容易实现，和能很快求值。\n\n*中缀表示法*（或中缀记法）是一个通用的算术或逻辑公式表示方法， 操作符是以中缀形式处于操作数的中间（例：3 + 4）。\n\n##调度场算法\n\n调度场算法（Shunting Yard Algorithm）是一个用于将中缀表达式转换为后缀表达式的经典算法，因其操作类似于火车编组场而得名。\n```\n\t当还有记号可以读取时：\n\t\t读取一个记号。\n\t\t如果这个记号表示一个数字，那么将其添加到输出队列中。\n\t\t如果这个记号表示一个操作符，记做o1，那么：\n\t\t\t只要存在另一个记为o2的操作符位于栈的顶端，并且\n\t\t\t\t如果o1是左结合性的并且它的运算符优先级要小于或者等于o2的优先级，或者\n\t\t\t\t如果o1是右结合性的并且它的运算符优先级比o2的要低，那么\n\t\t\t\t将o2从栈的顶端弹出并且放入输出队列中(循环直至以上条件不满足为止)；\n\t\t\t然后，将o1压入栈的顶端。\n\t\t如果这个记号是一个左括号，那么就将其压入栈当中。\n\t\t如果这个记号是一个右括号，那么：\n\t\t\t从栈当中不断地弹出操作符并且放入输出队列中，直到栈顶部的元素为左括号为止。\n\t\t\t将左括号从栈的顶端弹出，但并不放入输出队列中去。\n\t\t\t如果在找到一个左括号之前栈就已经弹出了所有元素，那么就表示在表达式中存在不匹配的括号。\n\t当再没有记号可以读取时：\n\t\t如果此时在栈当中还有操作符：\n\t\t\t如果此时位于栈顶端的操作符是一个括号，那么就表示在表达式中存在不匹配的括号。\n\t\t将操作符逐个弹出并放入输出队列中。\n\t退出算法。\n```\n![](/img/Shunting-Yard.png)\n\n\n##逆波兰表示法的求值\n```\n\tWHILE 有输入符号\n\t\t读入下一个符号\n\t\tIF 是一个操作数\n\t\t\t入栈\n\t\tELSE IF 是一个操作符\n\t\t\t有一个先验的表格给出该操作符需要n个参数\n\t\t\tIF 堆栈中少于n个操作数\n\t\t\t\t（错误） 用户没有输入足够的操作数\n\t\t\tElse，n个操作数出栈\n\t\t\t计算操作符。\n\t\t\t将计算所得的值入栈\n\tIF 栈内只有一个值\n\t\t这个值就是整个计算式的结果\n\tELSE 多于一个值\n\t\t（错误） 用户输入了多余的操作数\n```\n对于一般的算术表达式，一个操作符只需要两个参数。\n\n<hr>\n下面给出四则运算器的代码实现\n``` cpp\n#include <iostream>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\n//操作符的优先级\n// 操作符 只考虑最简单的加减乘除\n// 优先级\t\t符号\t\t运算顺序\n// 1\t\t* /     从左至右\n// 2\t\t+ -\t\t从左至右\nint op_pri(const char c) {\n    switch(c) {\n            case '*':\n            case '/':\n                return 2;\n            case '-':\n            case '+':\n                return 1;\n    }\n    return -1;\n}\n\n//判断字符是否为数字\nbool is_ident(const char c) {\n    return c >= '0' && c <= '9';\n}\n\n//判断字符是否为合法的操作符\nbool is_op(const char c) {\n    return c == '/' || c == '*' || c == '^' || c == '-' || c == '+';\n}\n\n//调度场函数\nbool shunting_yard(const vector<char> &input, vector<char> &output) {\n    //清空输出队列\n    while(!output.empty())\n        output.clear();\n    \n    //如果输入为空，直接返回\n    if (input.empty())\n        return true;\n    \n    stack<char> op; //操作符栈\n    for (int i = 0; i < input.size(); i++) {\n        char c = input[i];\n        if (c == ' ')\n            continue;\n        \n        if (is_ident(c)) {\n            //如果是数字，直接将字符加入到输出队列中\n            output.push_back(c);\n        } else if (is_op(c)) {\n            //如果是操作符\n            //如果操作符栈为空，直接将操作符压栈\n            if (op.empty()) {\n                op.push(c);\n                continue;\n            }\n            \n            char op_top = op.top(); //栈顶操作符\n            if (!is_op(op_top) || op_pri(c) > op_pri(op_top)) {\n                //如果操作符的优先级要大于栈顶的操作符或者栈顶操作符为括号，直接压栈\n                op.push(c);\n            } else {\n                //如果操作符的优先级要小于等于栈顶操作符，那么就一直将栈顶弹出\n                //放入输出队列\n                while(op_pri(c) <= op_pri(op_top)) {\n                    output.push_back(op_top);\n                    op.pop();\n                    if (op.empty())\n                        break;\n                    op_top = op.top();\n                }\n                op.push(c);\n            }\n        } else if (c == '(') {\n            //如果是左括号，直接压栈\n            op.push(c);\n        } else if (c == ')') {\n            //如果是右括号，弹出操作符，直到弹出左括号\n            while (!op.empty()) {\n                char op_top = op.top();\n                if (op_top != '(') {\n                    output.push_back(op_top);\n                    op.pop();\n                } else {\n                    break;\n                }\n            }\n            \n            if (!op.empty()) {\n                //如果找到了左括号，把左括号弹出\n                op.pop();\n            } else {\n                //如果栈弹空了还没找到，那么表达式错误\n                output.clear();\n                cout<<\"表达式错误\"<<endl;\n            }\n        } else {\n            //如果有其他字符，那么错误\n            cout<<\"表达式错误\"<<endl;\n            output.clear();\n            return false;\n        }\n    }\n    \n    while (!op.empty()) {\n        char op_top = op.top();\n        if (is_op(op_top)) {\n            output.push_back(op_top);\n            op.pop();\n        } else {\n            cout<<\"表达式错误\"<<endl;\n            output.clear();\n            return false;\n        }\n    }\n    \n    return true;\n}\n\n//计算你波兰表达式的值\nbool calculate(const vector<char> &output, double &result) {\n    if (output.empty())\n        return false;\n    \n    stack<double> values;\n    for (int i = 0; i < output.size(); i++) {\n        char c = output[i];\n        if (is_ident(c)) {\n            values.push(c - '0');\n        } else if (is_op(c)) {\n            if (values.empty()) {\n                cout<<\"表达式错误\"<<endl;\n                return false;\n            }\n            int left = values.top();\n            values.pop();\n            \n            if (values.empty()) {\n                cout<<\"表达式错误\"<<endl;\n                return false;\n            }\n            int right = values.top();\n            values.pop();\n            \n            switch(c) {\n                case '+':\n                    values.push(right + left);\n                    break;\n                case '-':\n                    values.push(right - left);\n                    break;\n                case '*':\n                    values.push(right * left);\n                    break;\n                case '/':\n                    values.push(right / left);\n                    break;\n            }\n        } else {\n            cout<<\"表达式错误\"<<endl;\n        }\n    }\n    \n    result = values.top();\n    values.pop();\n    if (!values.empty()) {\n        cout<<\"表达式有误\"<<endl;\n        return false;\n    }\n    return true;\n}\n\nint main () {\n    vector<char> input;\n    input.push_back('3');\n    input.push_back('+');\n    input.push_back('4');\n    input.push_back('*');\n    input.push_back('2');\n    input.push_back('/');\n    input.push_back('(');\n    input.push_back('1');\n    input.push_back('-');\n    input.push_back('5');\n    input.push_back(')');\n\n    vector<char> output;\n    shunting_yard(input, output);\n    for (int i = 0; i < output.size(); i++) {\n        cout<<output[i];\n    }\n    double result;\n    if (calculate(output, result)) {\n        cout<<result<<endl;\n    } else {\n        cout<<\"计算错误\"<<endl;\n    }\n}\n```","source":"_posts/2014-10-20-Polish-notation.md","raw":"---\nlayout: post\ntitle: \"四则运算计算器实现\"\ndate:   2014-10-20 15:52:20\ncategories: algorithms\n---\n\n##波兰表示法与逆波兰表示法\n\n*波兰表示法*（Polish notation，或波兰记法），是一种逻辑、算术和代数表示方法，其特点是操作符置于操作数的前面，因此也称做前缀表示法。与逆波兰表示法不同，前缀表达式基本没有在商业计算器中使用过，但是其体系经常在编译器构造的概念教学中首先使用。\n\n*逆波兰表示法*（Reverse Polish notation，RPN，或逆波兰记法）中所有操作符置于操作数的后面，因此也被称为后缀表示法。逆波兰记法不需要括号来标识操作符的优先级。\n\n逆波兰记法中，操作符置于操作数的后面。例如表达“三加四”时，写作“3 4 +”，而不是“3 + 4”。如果有多个操作符，操作符置于第二个操作数的后面，所以常规中缀记法的“3 - 4 + 5”在逆波兰记法中写作“3 4 - 5 +”：先3减去4，再加上5。使用逆波兰记法的一个好处是不需要使用括号。例如中缀记法中“3 - 4 * 5”与“（3 - 4）*5”不相同，但后缀记法中前者写做“3 4 5 * -”，无歧义地表示“3 (4 5 *) −”；后者写做“3 4 - 5 *”。\n\n逆波兰表达式的解释器一般是基于堆栈的。解释过程一般是：操作数入栈；遇到操作符时，操作数出栈，求值，将结果入栈；当一遍后，栈顶就是表达式的值。因此逆波兰表达式的求值使用堆栈结构很容易实现，和能很快求值。\n\n*中缀表示法*（或中缀记法）是一个通用的算术或逻辑公式表示方法， 操作符是以中缀形式处于操作数的中间（例：3 + 4）。\n\n##调度场算法\n\n调度场算法（Shunting Yard Algorithm）是一个用于将中缀表达式转换为后缀表达式的经典算法，因其操作类似于火车编组场而得名。\n```\n\t当还有记号可以读取时：\n\t\t读取一个记号。\n\t\t如果这个记号表示一个数字，那么将其添加到输出队列中。\n\t\t如果这个记号表示一个操作符，记做o1，那么：\n\t\t\t只要存在另一个记为o2的操作符位于栈的顶端，并且\n\t\t\t\t如果o1是左结合性的并且它的运算符优先级要小于或者等于o2的优先级，或者\n\t\t\t\t如果o1是右结合性的并且它的运算符优先级比o2的要低，那么\n\t\t\t\t将o2从栈的顶端弹出并且放入输出队列中(循环直至以上条件不满足为止)；\n\t\t\t然后，将o1压入栈的顶端。\n\t\t如果这个记号是一个左括号，那么就将其压入栈当中。\n\t\t如果这个记号是一个右括号，那么：\n\t\t\t从栈当中不断地弹出操作符并且放入输出队列中，直到栈顶部的元素为左括号为止。\n\t\t\t将左括号从栈的顶端弹出，但并不放入输出队列中去。\n\t\t\t如果在找到一个左括号之前栈就已经弹出了所有元素，那么就表示在表达式中存在不匹配的括号。\n\t当再没有记号可以读取时：\n\t\t如果此时在栈当中还有操作符：\n\t\t\t如果此时位于栈顶端的操作符是一个括号，那么就表示在表达式中存在不匹配的括号。\n\t\t将操作符逐个弹出并放入输出队列中。\n\t退出算法。\n```\n![](/img/Shunting-Yard.png)\n\n\n##逆波兰表示法的求值\n```\n\tWHILE 有输入符号\n\t\t读入下一个符号\n\t\tIF 是一个操作数\n\t\t\t入栈\n\t\tELSE IF 是一个操作符\n\t\t\t有一个先验的表格给出该操作符需要n个参数\n\t\t\tIF 堆栈中少于n个操作数\n\t\t\t\t（错误） 用户没有输入足够的操作数\n\t\t\tElse，n个操作数出栈\n\t\t\t计算操作符。\n\t\t\t将计算所得的值入栈\n\tIF 栈内只有一个值\n\t\t这个值就是整个计算式的结果\n\tELSE 多于一个值\n\t\t（错误） 用户输入了多余的操作数\n```\n对于一般的算术表达式，一个操作符只需要两个参数。\n\n<hr>\n下面给出四则运算器的代码实现\n``` cpp\n#include <iostream>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\n//操作符的优先级\n// 操作符 只考虑最简单的加减乘除\n// 优先级\t\t符号\t\t运算顺序\n// 1\t\t* /     从左至右\n// 2\t\t+ -\t\t从左至右\nint op_pri(const char c) {\n    switch(c) {\n            case '*':\n            case '/':\n                return 2;\n            case '-':\n            case '+':\n                return 1;\n    }\n    return -1;\n}\n\n//判断字符是否为数字\nbool is_ident(const char c) {\n    return c >= '0' && c <= '9';\n}\n\n//判断字符是否为合法的操作符\nbool is_op(const char c) {\n    return c == '/' || c == '*' || c == '^' || c == '-' || c == '+';\n}\n\n//调度场函数\nbool shunting_yard(const vector<char> &input, vector<char> &output) {\n    //清空输出队列\n    while(!output.empty())\n        output.clear();\n    \n    //如果输入为空，直接返回\n    if (input.empty())\n        return true;\n    \n    stack<char> op; //操作符栈\n    for (int i = 0; i < input.size(); i++) {\n        char c = input[i];\n        if (c == ' ')\n            continue;\n        \n        if (is_ident(c)) {\n            //如果是数字，直接将字符加入到输出队列中\n            output.push_back(c);\n        } else if (is_op(c)) {\n            //如果是操作符\n            //如果操作符栈为空，直接将操作符压栈\n            if (op.empty()) {\n                op.push(c);\n                continue;\n            }\n            \n            char op_top = op.top(); //栈顶操作符\n            if (!is_op(op_top) || op_pri(c) > op_pri(op_top)) {\n                //如果操作符的优先级要大于栈顶的操作符或者栈顶操作符为括号，直接压栈\n                op.push(c);\n            } else {\n                //如果操作符的优先级要小于等于栈顶操作符，那么就一直将栈顶弹出\n                //放入输出队列\n                while(op_pri(c) <= op_pri(op_top)) {\n                    output.push_back(op_top);\n                    op.pop();\n                    if (op.empty())\n                        break;\n                    op_top = op.top();\n                }\n                op.push(c);\n            }\n        } else if (c == '(') {\n            //如果是左括号，直接压栈\n            op.push(c);\n        } else if (c == ')') {\n            //如果是右括号，弹出操作符，直到弹出左括号\n            while (!op.empty()) {\n                char op_top = op.top();\n                if (op_top != '(') {\n                    output.push_back(op_top);\n                    op.pop();\n                } else {\n                    break;\n                }\n            }\n            \n            if (!op.empty()) {\n                //如果找到了左括号，把左括号弹出\n                op.pop();\n            } else {\n                //如果栈弹空了还没找到，那么表达式错误\n                output.clear();\n                cout<<\"表达式错误\"<<endl;\n            }\n        } else {\n            //如果有其他字符，那么错误\n            cout<<\"表达式错误\"<<endl;\n            output.clear();\n            return false;\n        }\n    }\n    \n    while (!op.empty()) {\n        char op_top = op.top();\n        if (is_op(op_top)) {\n            output.push_back(op_top);\n            op.pop();\n        } else {\n            cout<<\"表达式错误\"<<endl;\n            output.clear();\n            return false;\n        }\n    }\n    \n    return true;\n}\n\n//计算你波兰表达式的值\nbool calculate(const vector<char> &output, double &result) {\n    if (output.empty())\n        return false;\n    \n    stack<double> values;\n    for (int i = 0; i < output.size(); i++) {\n        char c = output[i];\n        if (is_ident(c)) {\n            values.push(c - '0');\n        } else if (is_op(c)) {\n            if (values.empty()) {\n                cout<<\"表达式错误\"<<endl;\n                return false;\n            }\n            int left = values.top();\n            values.pop();\n            \n            if (values.empty()) {\n                cout<<\"表达式错误\"<<endl;\n                return false;\n            }\n            int right = values.top();\n            values.pop();\n            \n            switch(c) {\n                case '+':\n                    values.push(right + left);\n                    break;\n                case '-':\n                    values.push(right - left);\n                    break;\n                case '*':\n                    values.push(right * left);\n                    break;\n                case '/':\n                    values.push(right / left);\n                    break;\n            }\n        } else {\n            cout<<\"表达式错误\"<<endl;\n        }\n    }\n    \n    result = values.top();\n    values.pop();\n    if (!values.empty()) {\n        cout<<\"表达式有误\"<<endl;\n        return false;\n    }\n    return true;\n}\n\nint main () {\n    vector<char> input;\n    input.push_back('3');\n    input.push_back('+');\n    input.push_back('4');\n    input.push_back('*');\n    input.push_back('2');\n    input.push_back('/');\n    input.push_back('(');\n    input.push_back('1');\n    input.push_back('-');\n    input.push_back('5');\n    input.push_back(')');\n\n    vector<char> output;\n    shunting_yard(input, output);\n    for (int i = 0; i < output.size(); i++) {\n        cout<<output[i];\n    }\n    double result;\n    if (calculate(output, result)) {\n        cout<<result<<endl;\n    } else {\n        cout<<\"计算错误\"<<endl;\n    }\n}\n```","slug":"2014-10-20-Polish-notation","published":1,"updated":"2015-06-09T14:02:29.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck3n0030rwmwd3q28g7n"},{"layout":"post","title":"iterator和指针","date":"2014-10-16T00:34:20.000Z","_content":"\n##Iterator\n\niterator一般用在容器中，下面是所有容器都支持的一些运算：\n```\n\t*iter 返回迭代器 iter 所指向的元素的引用\n\n\titer->mem 对 iter 进行解引用，获取指定元素中名为 mem 的成员。等效于 (*iter).mem\n\n\t++iter iter++ 给 iter 加 1，使其指向容器里的下一个元素\n\n\t--iter iter-- 给 iter 减 1，使其指向容器里的前一个元素\n\n\titer1 == iter2 \n\titer1 != iter2  比较两个迭代器是否相等（或不等）。当两个迭代器指向同一个容器中的同一个元素，或者当它们都指向同一个容器的超出末端的下一位置时，两个迭代器相等\n```\n\n在支持随机访问的两个容器vector和deque中，还支持另外一些更加灵活地运算：\n```\n\titer + n \n\titer - n  n，将产生指向容器中前面（后面）第 n 个元素的迭代器。新计算出来的迭代器必须指向容器中的元素或超出容器末端的下一位置\n\n\titer1 += iter2 \n\titer1 -= iter2 这里迭代器加减法的复合赋值运算：将 iter1 加上或减去 iter2 的运算结果赋给 iter1\n\n\titer1 - iter2 两个迭代器的减法，其运算结果加上右边的迭代器即得左边的迭代器。这两个迭代器必须指向同一个容器中的元素或超出容器末端的下一位置\n\n\t>, >=, <, <= 迭代器的关系操作符。当一个迭代器指向的元素在容器中位于另一个迭代器指向的元素之前，则前一个迭代器小于后一个迭代器。关系操作符的两个迭代器必须指向同一个容器中的元素或超出容器末端的下一位置\n```\n\nC++ 语言使用一对迭代器标记迭代器范围（iterator range），这两个迭代器分别指向同一个容器中的两个元素或超出末端的下一位置，通常将它们命名为 first 和 last，或 beg 和 end，用于标记容器中的一段元素范围。\n\n尽管 last 和 end 这两个名字很常见，但是它们却容易引起误解。其实第二个迭代器从来都不是指向元素范围的最后一个元素，而是指向最后一个元素的下一位置。该范围内的元素包括迭代器 first 指向的元素，以及从 first 开始一直到迭代器 last 指向的位置之前的所有元素。如果两个迭代器相等，则迭代器范围为空。\n\n此类元素范围称为左闭合区间（left-inclusive interval），其标准表示方式为：\n\n```\n\t[ first, last )\n```\n\n表示范围从 first 开始，到 last 结束，但不包括 last。迭代器 last 可以等于 first，或者指向 first 标记的元素后面的某个元素，但绝对不能指向 first 标记的元素前面的元素。\n\n使用左闭右开空间有几个好处：\n\n+ 当 first 与 last 相等时，迭代器范围为空；\n+ 当 first 与不相等时，迭代器范围内至少有一个元素，而且 first 指向该区间中的第一元素。此外，通过若干次自增运算可以使 first 的值不断增大，直到 first == last 为止。\n\n这样的话，就可以安全地写循环了：\n```\n\twhile (first != last) { //安全地写!=，而不用怕越界\n         // safe to use *first because we know there is at least one element\n         ++first;\n     }\n```\n\n 这样的话，iterator看起来跟指针也没什么大的区别。。。。。\n\n 下面看看algorithm中fill函数\n```\n\ttemplate <class ForwardIterator, class T> \n\tfill (ForwardIterator first, ForwardIterator last, const T& val);\n```\n它及支持容器中的迭代器，但同时也支持普通数组中的指针：\n\n``` cpp\n// fill algorithm example\n#include <iostream>     // cout\n#include <algorithm>    // fill\n#include <vector>       // vector\nusing namespace std;\n\nint main () {\n    vector<int> myvector (8);                       // myvector: 0 0 0 0 0 0 0 0\n    \n    //iterator\n    fill (myvector.begin(),myvector.begin()+4,5);   // myvector: 5 5 5 5 0 0 0 0\n    fill (myvector.begin()+3,myvector.end()-2,8);   // myvector: 5 5 5 8 8 8 0 0\n    \n    cout << \"myvector contains:\";\n    for (vector<int>::iterator it=myvector.begin(); it!=myvector.end(); ++it)\n        cout << ' ' << *it;\n    cout << '\\n';\n    \n    int a[10];\n    //指针\n    fill(a, a + 10, 10);\n    for (int i = 0; i < 10; i++) {\n        cout<<a[i]<<\"\\t\";\n    }\n    \n    return 0;\n}\n```","source":"_posts/2014-10-16-stl-iterator-pointer.md","raw":"---\nlayout: post\ntitle:  \"iterator和指针\"\ndate:   2014-10-16 08:34:20\ncategories:   cpp\n---\n\n##Iterator\n\niterator一般用在容器中，下面是所有容器都支持的一些运算：\n```\n\t*iter 返回迭代器 iter 所指向的元素的引用\n\n\titer->mem 对 iter 进行解引用，获取指定元素中名为 mem 的成员。等效于 (*iter).mem\n\n\t++iter iter++ 给 iter 加 1，使其指向容器里的下一个元素\n\n\t--iter iter-- 给 iter 减 1，使其指向容器里的前一个元素\n\n\titer1 == iter2 \n\titer1 != iter2  比较两个迭代器是否相等（或不等）。当两个迭代器指向同一个容器中的同一个元素，或者当它们都指向同一个容器的超出末端的下一位置时，两个迭代器相等\n```\n\n在支持随机访问的两个容器vector和deque中，还支持另外一些更加灵活地运算：\n```\n\titer + n \n\titer - n  n，将产生指向容器中前面（后面）第 n 个元素的迭代器。新计算出来的迭代器必须指向容器中的元素或超出容器末端的下一位置\n\n\titer1 += iter2 \n\titer1 -= iter2 这里迭代器加减法的复合赋值运算：将 iter1 加上或减去 iter2 的运算结果赋给 iter1\n\n\titer1 - iter2 两个迭代器的减法，其运算结果加上右边的迭代器即得左边的迭代器。这两个迭代器必须指向同一个容器中的元素或超出容器末端的下一位置\n\n\t>, >=, <, <= 迭代器的关系操作符。当一个迭代器指向的元素在容器中位于另一个迭代器指向的元素之前，则前一个迭代器小于后一个迭代器。关系操作符的两个迭代器必须指向同一个容器中的元素或超出容器末端的下一位置\n```\n\nC++ 语言使用一对迭代器标记迭代器范围（iterator range），这两个迭代器分别指向同一个容器中的两个元素或超出末端的下一位置，通常将它们命名为 first 和 last，或 beg 和 end，用于标记容器中的一段元素范围。\n\n尽管 last 和 end 这两个名字很常见，但是它们却容易引起误解。其实第二个迭代器从来都不是指向元素范围的最后一个元素，而是指向最后一个元素的下一位置。该范围内的元素包括迭代器 first 指向的元素，以及从 first 开始一直到迭代器 last 指向的位置之前的所有元素。如果两个迭代器相等，则迭代器范围为空。\n\n此类元素范围称为左闭合区间（left-inclusive interval），其标准表示方式为：\n\n```\n\t[ first, last )\n```\n\n表示范围从 first 开始，到 last 结束，但不包括 last。迭代器 last 可以等于 first，或者指向 first 标记的元素后面的某个元素，但绝对不能指向 first 标记的元素前面的元素。\n\n使用左闭右开空间有几个好处：\n\n+ 当 first 与 last 相等时，迭代器范围为空；\n+ 当 first 与不相等时，迭代器范围内至少有一个元素，而且 first 指向该区间中的第一元素。此外，通过若干次自增运算可以使 first 的值不断增大，直到 first == last 为止。\n\n这样的话，就可以安全地写循环了：\n```\n\twhile (first != last) { //安全地写!=，而不用怕越界\n         // safe to use *first because we know there is at least one element\n         ++first;\n     }\n```\n\n 这样的话，iterator看起来跟指针也没什么大的区别。。。。。\n\n 下面看看algorithm中fill函数\n```\n\ttemplate <class ForwardIterator, class T> \n\tfill (ForwardIterator first, ForwardIterator last, const T& val);\n```\n它及支持容器中的迭代器，但同时也支持普通数组中的指针：\n\n``` cpp\n// fill algorithm example\n#include <iostream>     // cout\n#include <algorithm>    // fill\n#include <vector>       // vector\nusing namespace std;\n\nint main () {\n    vector<int> myvector (8);                       // myvector: 0 0 0 0 0 0 0 0\n    \n    //iterator\n    fill (myvector.begin(),myvector.begin()+4,5);   // myvector: 5 5 5 5 0 0 0 0\n    fill (myvector.begin()+3,myvector.end()-2,8);   // myvector: 5 5 5 8 8 8 0 0\n    \n    cout << \"myvector contains:\";\n    for (vector<int>::iterator it=myvector.begin(); it!=myvector.end(); ++it)\n        cout << ' ' << *it;\n    cout << '\\n';\n    \n    int a[10];\n    //指针\n    fill(a, a + 10, 10);\n    for (int i = 0; i < 10; i++) {\n        cout<<a[i]<<\"\\t\";\n    }\n    \n    return 0;\n}\n```","slug":"2014-10-16-stl-iterator-pointer","published":1,"updated":"2015-04-30T12:03:42.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck3p0032rwmw8b3rda48"},{"layout":"post","title":"二叉搜索树(binary search tree)","date":"2014-10-16T02:33:20.000Z","_content":"\n##二叉搜索树\n\n二叉搜索树又叫二叉查找树，是指一棵空树或者具有下列性质的二叉树：\n\n+ 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；\n+ 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；\n+ 任意节点的左、右子树也分别为二叉查找树。\n+ 没有键值相等的节点（no duplicate nodes）。\n\n二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为O(log n)。但是二叉查找树\n（以后简写为BST）也存在最坏的情况，那么操作的时间复杂度为O(n)。所以有很多对二叉树的改进版本，\n比如AVL，红黑树。\n\n二叉树一般使用数组来实现。下面我们约定二叉树的结构体。\n```\n    struct node {\n        int key;\n        node *lch, *rch;\n    };\n```\n\n##BST的搜索\n在二叉查找树p中查找x的过程为：\n\n+ 若p是空树，则搜索失败，否则：\n+ 若x等于p的根节点的数据域之值，则查找成功；否则：\n+ 若x小于b的根节点的数据域之值，则搜索左子树；否则：\n+ 查找右子树。\n\n``` cpp\nbool find(node *p, int x) {\n    if (p == NULL)\n        return false;\n    else if (x == p->key)\n        return true;\n    else if (x < p->key)\n        return find(p->lch, x);\n    else\n        return find(p->rch, x);\n}\n```\n\n##在BST中插入节点\n向一个二叉查找树p中插入一个值为x的节点的算法，过程为：\n\n+ 若p是空树，新建一个空节点，将节点的键值赋值为x，返回该节点，否则：\n+ 若x等于p的的键值，则返回，否则：\n+ 若x小于p的键值，则把x插入到左子树中，否则：\n+ 把x插入到右子树中。（新插入节点总是叶子节点）\n\n``` cpp\nnode *insert(node *p, int x) {\n    if (p == NULL) {\n        node *q = new node;\n        q->key = x;\n        q->lch = q->rch = NULL;\n        return q;\n    }\n    \n    if (x < p->key)\n        p->lch = insert(p->lch, x);\n    else if (x > p->key)\n        p->rch = insert(p->rch, x);\n    return p;\n}\n```\n\n##在BST中删除一个节点\n在BST中删除一个节点时一般可以分为以下几种情况：\n\n+ 如果需要删除的节点没有左子节点，那么把右子节点提上去\n+ 如果需要删除的节点没有右子节点，那么把左子结点提上去\n+ 如果不满足以上两种情况，那么把左子树中最大的节点提上去，也就是找出需要删除的节点的后继\n\n\n``` cpp\nnode *remove(node *p, int x) {\n    if (p == NULL)\n        return NULL;\n    else if (x < p->key) {\n        p->lch = remove(p->lch, x);\n        return p;\n    }\n    else if (x > p->key) {\n        p->rch = remove(p->rch, x);\n        return p;\n    }\n    \n    //找到了，下面判断是属于哪种情况\n    if (p->lch == NULL) {\n        node *q = p->rch;\n        delete p;\n        return q;\n    } else if (p->rch == NULL) {\n        node *q = p->lch;\n        delete p;\n        return q;\n    } else if (p->lch->rch == NULL) {\n        node *q = p->lch;\n        q->rch = p->rch;\n        delete p;\n        return q;\n    } else {\n        node *q;\n        for (q = p->lch; q->rch->rch != NULL; q = q->rch);\n        node *r = q->rch;\n        q->rch = r->lch;\n        p->key = r->key;\n        delete r;\n        return p;\n    }\n}\n```\n\n##完整的测试代码\n\n下面是完整的测试代码，在中间加了一个中序遍历函数，来顺序输出各个节点的值：\n\n``` cpp\n#include <iostream>\nusing namespace std;\n\nstruct node {\n    int key;\n    node *lch, *rch;\n};\n\nnode *insert(node *p, int x) {\n    if (p == NULL) {\n        node *q = new node;\n        q->key = x;\n        q->lch = q->rch = NULL;\n        return q;\n    }\n    \n    if (x < p->key)\n        p->lch = insert(p->lch, x);\n    else if (x > p->key)\n        p->rch = insert(p->rch, x);\n    return p;\n}\n\nbool find(node *p, int x) {\n    if (p == NULL)\n        return false;\n    else if (x == p->key)\n        return true;\n    else if (x < p->key)\n        return find(p->lch, x);\n    else\n        return find(p->rch, x);\n}\n\nnode *remove(node *p, int x) {\n    if (p == NULL)\n        return NULL;\n    else if (x < p->key) {\n        p->lch = remove(p->lch, x);\n        return p;\n    }\n    else if (x > p->key) {\n        p->rch = remove(p->rch, x);\n        return p;\n    }\n    \n    //找到了，下面判断是属于哪种情况\n    if (p->lch == NULL) {\n        node *q = p->rch;\n        delete p;\n        return q;\n    } else if (p->rch == NULL) {\n        node *q = p->lch;\n        delete p;\n        return q;\n    } else if (p->lch->rch == NULL) {\n        node *q = p->lch;\n        q->rch = p->rch;\n        delete p;\n        return q;\n    } else {\n        node *q;\n        for (q = p->lch; q->rch->rch != NULL; q = q->rch);\n        node *r = q->rch;\n        q->rch = r->lch;\n        p->key = r->key;\n        delete r;\n        return p;\n    }\n}\n\nvoid inorderTraversal(node *p) {\n    if (p == NULL)\n        return;\n    \n    inorderTraversal(p->lch);\n    cout<<p->key<<endl;\n    inorderTraversal(p->rch);\n}\n\nint main () {\n    node *p = NULL; //为节点指针赋空值很重要！！！！\n    for (int i = 0; i < 5; i++) {\n        int key;\n        cin>>key;\n        p = insert(p, key);\n    }\n    inorderTraversal(p);\n    p = remove(p, 1);\n    inorderTraversal(p);\n    p = remove(p, 5);\n    inorderTraversal(p);\n    cout<<find(p, 1)<<endl;\n    cout<<find(p, 2)<<endl;\n}\n```","source":"_posts/2014-10-16-binary-search-tree.md","raw":"---\nlayout: post\ntitle:  \"二叉搜索树(binary search tree)\"\ndate:   2014-10-16 10:33:20\ncategories:   algorithms\ntags: [二叉树]\n---\n\n##二叉搜索树\n\n二叉搜索树又叫二叉查找树，是指一棵空树或者具有下列性质的二叉树：\n\n+ 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；\n+ 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；\n+ 任意节点的左、右子树也分别为二叉查找树。\n+ 没有键值相等的节点（no duplicate nodes）。\n\n二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为O(log n)。但是二叉查找树\n（以后简写为BST）也存在最坏的情况，那么操作的时间复杂度为O(n)。所以有很多对二叉树的改进版本，\n比如AVL，红黑树。\n\n二叉树一般使用数组来实现。下面我们约定二叉树的结构体。\n```\n    struct node {\n        int key;\n        node *lch, *rch;\n    };\n```\n\n##BST的搜索\n在二叉查找树p中查找x的过程为：\n\n+ 若p是空树，则搜索失败，否则：\n+ 若x等于p的根节点的数据域之值，则查找成功；否则：\n+ 若x小于b的根节点的数据域之值，则搜索左子树；否则：\n+ 查找右子树。\n\n``` cpp\nbool find(node *p, int x) {\n    if (p == NULL)\n        return false;\n    else if (x == p->key)\n        return true;\n    else if (x < p->key)\n        return find(p->lch, x);\n    else\n        return find(p->rch, x);\n}\n```\n\n##在BST中插入节点\n向一个二叉查找树p中插入一个值为x的节点的算法，过程为：\n\n+ 若p是空树，新建一个空节点，将节点的键值赋值为x，返回该节点，否则：\n+ 若x等于p的的键值，则返回，否则：\n+ 若x小于p的键值，则把x插入到左子树中，否则：\n+ 把x插入到右子树中。（新插入节点总是叶子节点）\n\n``` cpp\nnode *insert(node *p, int x) {\n    if (p == NULL) {\n        node *q = new node;\n        q->key = x;\n        q->lch = q->rch = NULL;\n        return q;\n    }\n    \n    if (x < p->key)\n        p->lch = insert(p->lch, x);\n    else if (x > p->key)\n        p->rch = insert(p->rch, x);\n    return p;\n}\n```\n\n##在BST中删除一个节点\n在BST中删除一个节点时一般可以分为以下几种情况：\n\n+ 如果需要删除的节点没有左子节点，那么把右子节点提上去\n+ 如果需要删除的节点没有右子节点，那么把左子结点提上去\n+ 如果不满足以上两种情况，那么把左子树中最大的节点提上去，也就是找出需要删除的节点的后继\n\n\n``` cpp\nnode *remove(node *p, int x) {\n    if (p == NULL)\n        return NULL;\n    else if (x < p->key) {\n        p->lch = remove(p->lch, x);\n        return p;\n    }\n    else if (x > p->key) {\n        p->rch = remove(p->rch, x);\n        return p;\n    }\n    \n    //找到了，下面判断是属于哪种情况\n    if (p->lch == NULL) {\n        node *q = p->rch;\n        delete p;\n        return q;\n    } else if (p->rch == NULL) {\n        node *q = p->lch;\n        delete p;\n        return q;\n    } else if (p->lch->rch == NULL) {\n        node *q = p->lch;\n        q->rch = p->rch;\n        delete p;\n        return q;\n    } else {\n        node *q;\n        for (q = p->lch; q->rch->rch != NULL; q = q->rch);\n        node *r = q->rch;\n        q->rch = r->lch;\n        p->key = r->key;\n        delete r;\n        return p;\n    }\n}\n```\n\n##完整的测试代码\n\n下面是完整的测试代码，在中间加了一个中序遍历函数，来顺序输出各个节点的值：\n\n``` cpp\n#include <iostream>\nusing namespace std;\n\nstruct node {\n    int key;\n    node *lch, *rch;\n};\n\nnode *insert(node *p, int x) {\n    if (p == NULL) {\n        node *q = new node;\n        q->key = x;\n        q->lch = q->rch = NULL;\n        return q;\n    }\n    \n    if (x < p->key)\n        p->lch = insert(p->lch, x);\n    else if (x > p->key)\n        p->rch = insert(p->rch, x);\n    return p;\n}\n\nbool find(node *p, int x) {\n    if (p == NULL)\n        return false;\n    else if (x == p->key)\n        return true;\n    else if (x < p->key)\n        return find(p->lch, x);\n    else\n        return find(p->rch, x);\n}\n\nnode *remove(node *p, int x) {\n    if (p == NULL)\n        return NULL;\n    else if (x < p->key) {\n        p->lch = remove(p->lch, x);\n        return p;\n    }\n    else if (x > p->key) {\n        p->rch = remove(p->rch, x);\n        return p;\n    }\n    \n    //找到了，下面判断是属于哪种情况\n    if (p->lch == NULL) {\n        node *q = p->rch;\n        delete p;\n        return q;\n    } else if (p->rch == NULL) {\n        node *q = p->lch;\n        delete p;\n        return q;\n    } else if (p->lch->rch == NULL) {\n        node *q = p->lch;\n        q->rch = p->rch;\n        delete p;\n        return q;\n    } else {\n        node *q;\n        for (q = p->lch; q->rch->rch != NULL; q = q->rch);\n        node *r = q->rch;\n        q->rch = r->lch;\n        p->key = r->key;\n        delete r;\n        return p;\n    }\n}\n\nvoid inorderTraversal(node *p) {\n    if (p == NULL)\n        return;\n    \n    inorderTraversal(p->lch);\n    cout<<p->key<<endl;\n    inorderTraversal(p->rch);\n}\n\nint main () {\n    node *p = NULL; //为节点指针赋空值很重要！！！！\n    for (int i = 0; i < 5; i++) {\n        int key;\n        cin>>key;\n        p = insert(p, key);\n    }\n    inorderTraversal(p);\n    p = remove(p, 1);\n    inorderTraversal(p);\n    p = remove(p, 5);\n    inorderTraversal(p);\n    cout<<find(p, 1)<<endl;\n    cout<<find(p, 2)<<endl;\n}\n```","slug":"2014-10-16-binary-search-tree","published":1,"updated":"2015-05-04T13:48:57.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck4a0034rwmwynp139mn"},{"layout":"post","title":"图: 二分图(用邻接表实现)","date":"2014-10-14T12:26:20.000Z","_content":"\n给定一个具有n个顶点的图。要给图上每个顶点染色，并且要使相邻的顶点颜色不同。问是否能最多使用2种颜色进行染色？题目保证没有重边和自环。\n\n这个题可以使用dfs来实现，思路还是挺简单的。\n\n假设有一个简单图，随意从一个顶点开始染色，然后给相邻的顶点染上相反的色，如果相邻顶点和自己的色相同，那么说明不是二分图。\n\n但是如果是一个森林的话，那么我们还要对每个顶点进行判断，判断是否已经染色了，毕竟就算前一个图是二分图，也只能把自己所有的顶点染色。\n\n这是第一个用c++来实现的题，在这里主要是学习用邻接表来实现图，数组的话占用空间太多了。\n\n``` cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_V = 10000;\n\nvector<int> G[MAX_V]; //图\nint N;  //边数\nint V;  //顶点数\nint color[MAX_V];\n\nbool dfs(int v, int c) {\n    color[v] = c;\n    for (int i = 0; i < G[v].size(); i++) {\n        if (color[G[v][i]] == c)\n            return false;\n        \n        if (color[G[v][i]] == 0 && !dfs(G[v][i], -c))\n            return false;\n    }\n    return true;\n}\n\nvoid solve() {\n    for (int i = 0; i < V; i++) {\n        if (color[i] == 0) {\n            if (!dfs(i, 1)) {\n                cout<<\"No\"<<endl;\n                return;\n            }\n        }\n    }\n    cout<<\"Yes\"<<endl;\n}\n\nint main()\n{\n    cin>>V;\n    cin>>N;\n    for (int i = 0; i < N; i++) {\n        int a, b;\n        cin>>a>>b;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    fill(color, color + V, 0);\n    solve();\n    return 0;\n}\n```","source":"_posts/2014-10-14-bipartite-graph.md","raw":"---\nlayout: post\ntitle:  \"图: 二分图(用邻接表实现)\"\ndate:   2014-10-14 20:26:20\ncategories: problems\n---\n\n给定一个具有n个顶点的图。要给图上每个顶点染色，并且要使相邻的顶点颜色不同。问是否能最多使用2种颜色进行染色？题目保证没有重边和自环。\n\n这个题可以使用dfs来实现，思路还是挺简单的。\n\n假设有一个简单图，随意从一个顶点开始染色，然后给相邻的顶点染上相反的色，如果相邻顶点和自己的色相同，那么说明不是二分图。\n\n但是如果是一个森林的话，那么我们还要对每个顶点进行判断，判断是否已经染色了，毕竟就算前一个图是二分图，也只能把自己所有的顶点染色。\n\n这是第一个用c++来实现的题，在这里主要是学习用邻接表来实现图，数组的话占用空间太多了。\n\n``` cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_V = 10000;\n\nvector<int> G[MAX_V]; //图\nint N;  //边数\nint V;  //顶点数\nint color[MAX_V];\n\nbool dfs(int v, int c) {\n    color[v] = c;\n    for (int i = 0; i < G[v].size(); i++) {\n        if (color[G[v][i]] == c)\n            return false;\n        \n        if (color[G[v][i]] == 0 && !dfs(G[v][i], -c))\n            return false;\n    }\n    return true;\n}\n\nvoid solve() {\n    for (int i = 0; i < V; i++) {\n        if (color[i] == 0) {\n            if (!dfs(i, 1)) {\n                cout<<\"No\"<<endl;\n                return;\n            }\n        }\n    }\n    cout<<\"Yes\"<<endl;\n}\n\nint main()\n{\n    cin>>V;\n    cin>>N;\n    for (int i = 0; i < N; i++) {\n        int a, b;\n        cin>>a>>b;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    fill(color, color + V, 0);\n    solve();\n    return 0;\n}\n```","slug":"2014-10-14-bipartite-graph","published":1,"updated":"2015-04-30T12:01:56.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck4c0037rwmwabghdw19"},{"layout":"post","title":"函数指针","date":"2014-10-13T15:28:20.000Z","_content":"\n函数指针是指向函数的指针变量。 因而“函数指针”本身首先应是指针变量，只不过该指针变量指向函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。如前所述，C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是一致的。函数指针有两个用途：调用函数和做函数的参数。\n\n使用函数指针有时候可以优化代码结构，减少不必要的代码开支。比如我要打印一个面积，但是有两个形状：三角形和矩形。但是计算面积的函数又不同，所以如果不用函数指针，我们必须使用if else结构来实现。但是如果使用函数指针的画，我们就可以直接传递一个函数指针就搞定了。\n\n函数指针的声明方法：\n```\n\ttype (*func)(type a,type b)\n```\n为了方便，可以定义一个别名：\n```\n\ttypedef type(*func)(type a, type b)\n```\n\n``` cpp\n#include <iostream>\nusing namespace std;\n\n//定义一个计算面积的函数指针\ntypedef double(*cal)(const double &x, const double &y);\n\ndouble triangle_area(const double &x, const double &y);//三角形面积\ndouble rectangle_area(const double &x,const double &y);//矩形面积\n\ndouble print_area(double(*p)(const double&,const double&), const double &x, const double &y);\n\n//函数定义\ndouble triangle_area(const double &x, const double &y)\n{\n    return x*y*0.5;\n}\n\ndouble rectangle_area(const double &x,const double &y)\n{\n    return x*y;\n}\n\ndouble print_area(cal p, const double &x, const double &y)\n{\t\n\t//使用函数指针来调用计算面积的函数\n    cout<<\"面积为\"<<p(x,y)<<endl;\n    return 0.0;\n}\n\nint main()\n{\n    double a=2,b=3;//初始化两个参数a和b\n    cal p;\n    p = triangle_area;\n    //直接传递函数名\n    print_area(p, a, b);\n    \n    p = rectangle_area;\n    print_area(p, a, b);\n    return 0;\n}\n```","source":"_posts/2014-10-13-c-function-pointer.md","raw":"---\nlayout: post\ntitle:  \"函数指针\"\ndate:   2014-10-13 23:28:20\ncategories:   cpp\n---\n\n函数指针是指向函数的指针变量。 因而“函数指针”本身首先应是指针变量，只不过该指针变量指向函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。如前所述，C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是一致的。函数指针有两个用途：调用函数和做函数的参数。\n\n使用函数指针有时候可以优化代码结构，减少不必要的代码开支。比如我要打印一个面积，但是有两个形状：三角形和矩形。但是计算面积的函数又不同，所以如果不用函数指针，我们必须使用if else结构来实现。但是如果使用函数指针的画，我们就可以直接传递一个函数指针就搞定了。\n\n函数指针的声明方法：\n```\n\ttype (*func)(type a,type b)\n```\n为了方便，可以定义一个别名：\n```\n\ttypedef type(*func)(type a, type b)\n```\n\n``` cpp\n#include <iostream>\nusing namespace std;\n\n//定义一个计算面积的函数指针\ntypedef double(*cal)(const double &x, const double &y);\n\ndouble triangle_area(const double &x, const double &y);//三角形面积\ndouble rectangle_area(const double &x,const double &y);//矩形面积\n\ndouble print_area(double(*p)(const double&,const double&), const double &x, const double &y);\n\n//函数定义\ndouble triangle_area(const double &x, const double &y)\n{\n    return x*y*0.5;\n}\n\ndouble rectangle_area(const double &x,const double &y)\n{\n    return x*y;\n}\n\ndouble print_area(cal p, const double &x, const double &y)\n{\t\n\t//使用函数指针来调用计算面积的函数\n    cout<<\"面积为\"<<p(x,y)<<endl;\n    return 0.0;\n}\n\nint main()\n{\n    double a=2,b=3;//初始化两个参数a和b\n    cal p;\n    p = triangle_area;\n    //直接传递函数名\n    print_area(p, a, b);\n    \n    p = rectangle_area;\n    print_area(p, a, b);\n    return 0;\n}\n```","slug":"2014-10-13-c-function-pointer","published":1,"updated":"2015-04-30T12:08:14.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck4f0039rwmwjjggllwo"},{"layout":"post","title":"STL中的priority_queue","date":"2014-10-11T14:18:20.000Z","_content":"\n如果碰到需要使用优先级序列的时候，可以不用自己去实现，使用STL中的便是，\nSTL其它还提供了许多有用的工具，要善加利用。\n\n下面是C++ Reference中priority_queue的使用的例子，知道这些应该就够了:\n\n```\n\ttemplate <class T, class Container = vector<T>,\n  class Compare = less<typename Container::value_type> > class priority_queue;\n```\n\n``` cpp\n// constructing priority queues\n#include <iostream>       // std::cout\n#include <queue>          // std::priority_queue\n#include <vector>         // std::vector\n#include <functional>     // std::greater\n\nclass mycomparison\n{\n  bool reverse;\npublic:\n  mycomparison(const bool& revparam=false)\n    {reverse=revparam;}\n  bool operator() (const int& lhs, const int&rhs) const\n  {\n    if (reverse) return (lhs>rhs);\n    else return (lhs<rhs);\n  }\n};\n\nint main ()\n{\n  int myints[]= {10,60,50,20};\n\n  std::priority_queue<int> first;\n  std::priority_queue<int> second (myints,myints+4);\n  //需要注意的是下面这个，priority_queue默认的是使用less<int>,\n  //所以生成的都是大头堆，如果需要生成小头堆得话，比较函数得使用greater<int>\n  std::priority_queue<int, std::vector<int>, std::greater<int> >\n                            third (myints,myints+4);\n  //如果碰到了需要比较自定义的类型，可以参照下面这个方法来实现\n  typedef std::priority_queue<int,std::vector<int>,mycomparison> mypq_type;\n\n  mypq_type fourth;                       // less-than comparison\n  mypq_type fifth (mycomparison(true));   // greater-than comparison\n\n  return 0;\n}\n```","source":"_posts/2014-10-11-stl-priority-queue.md","raw":"---\nlayout: post\ntitle:  \"STL中的priority_queue\"\ndate:   2014-10-11 22:18:20\ncategories:   cpp\n---\n\n如果碰到需要使用优先级序列的时候，可以不用自己去实现，使用STL中的便是，\nSTL其它还提供了许多有用的工具，要善加利用。\n\n下面是C++ Reference中priority_queue的使用的例子，知道这些应该就够了:\n\n```\n\ttemplate <class T, class Container = vector<T>,\n  class Compare = less<typename Container::value_type> > class priority_queue;\n```\n\n``` cpp\n// constructing priority queues\n#include <iostream>       // std::cout\n#include <queue>          // std::priority_queue\n#include <vector>         // std::vector\n#include <functional>     // std::greater\n\nclass mycomparison\n{\n  bool reverse;\npublic:\n  mycomparison(const bool& revparam=false)\n    {reverse=revparam;}\n  bool operator() (const int& lhs, const int&rhs) const\n  {\n    if (reverse) return (lhs>rhs);\n    else return (lhs<rhs);\n  }\n};\n\nint main ()\n{\n  int myints[]= {10,60,50,20};\n\n  std::priority_queue<int> first;\n  std::priority_queue<int> second (myints,myints+4);\n  //需要注意的是下面这个，priority_queue默认的是使用less<int>,\n  //所以生成的都是大头堆，如果需要生成小头堆得话，比较函数得使用greater<int>\n  std::priority_queue<int, std::vector<int>, std::greater<int> >\n                            third (myints,myints+4);\n  //如果碰到了需要比较自定义的类型，可以参照下面这个方法来实现\n  typedef std::priority_queue<int,std::vector<int>,mycomparison> mypq_type;\n\n  mypq_type fourth;                       // less-than comparison\n  mypq_type fifth (mycomparison(true));   // greater-than comparison\n\n  return 0;\n}\n```","slug":"2014-10-11-stl-priority-queue","published":1,"updated":"2015-04-30T12:04:31.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck4h003brwmwnjc4325z"},{"layout":"post","title":"标准类库中的sort()函数","date":"2014-10-11T07:34:20.000Z","_content":"\n由于有时候需要对数组啊之类的进行排序，那么是不是要自己动手写个快排呢，当然不是！\n\n标准类库中自带一个很强大的sort()函数，在`Expedition`一题中，就用到了sort()。\n\n下面是c++ Reference中sort()的一些用法，应该足够用了吧。\n\n``` cpp\n// sort algorithm example\n#include <iostream>     // std::cout\n#include <algorithm>    // std::sort\n#include <vector>       // std::vector\n\nbool myfunction (int i,int j) { return (i<j); }\n\nstruct myclass {\n  bool operator() (int i,int j) { return (i<j);}\n} myobject;\n\nint main () {\n  int myints[] = {32,71,12,45,26,80,53,33};\n  std::vector<int> myvector (myints, myints+8);               // 32 71 12 45 26 80 53 33\n\n  // using default comparison (operator <):\n  std::sort (myvector.begin(), myvector.begin()+4);           //(12 32 45 71)26 80 53 33\n\n  // using function as comp\n  std::sort (myvector.begin()+4, myvector.end(), myfunction); // 12 32 45 71(26 33 53 80)\n\n  // using object as comp\n  std::sort (myvector.begin(), myvector.end(), myobject);     //(12 26 32 33 45 53 71 80)\n\n  // print out content:\n  std::cout << \"myvector contains:\";\n  for (std::vector<int>::iterator it=myvector.begin(); it!=myvector.end(); ++it)\n    std::cout << ' ' << *it;\n  std::cout << '\\n';\n\n  return 0;\n}\n```","source":"_posts/2014-10-11-std-sort-function.md","raw":"---\nlayout: post\ntitle:  \"标准类库中的sort()函数\"\ndate:   2014-10-11 15:34:20\ncategories:   cpp\n---\n\n由于有时候需要对数组啊之类的进行排序，那么是不是要自己动手写个快排呢，当然不是！\n\n标准类库中自带一个很强大的sort()函数，在`Expedition`一题中，就用到了sort()。\n\n下面是c++ Reference中sort()的一些用法，应该足够用了吧。\n\n``` cpp\n// sort algorithm example\n#include <iostream>     // std::cout\n#include <algorithm>    // std::sort\n#include <vector>       // std::vector\n\nbool myfunction (int i,int j) { return (i<j); }\n\nstruct myclass {\n  bool operator() (int i,int j) { return (i<j);}\n} myobject;\n\nint main () {\n  int myints[] = {32,71,12,45,26,80,53,33};\n  std::vector<int> myvector (myints, myints+8);               // 32 71 12 45 26 80 53 33\n\n  // using default comparison (operator <):\n  std::sort (myvector.begin(), myvector.begin()+4);           //(12 32 45 71)26 80 53 33\n\n  // using function as comp\n  std::sort (myvector.begin()+4, myvector.end(), myfunction); // 12 32 45 71(26 33 53 80)\n\n  // using object as comp\n  std::sort (myvector.begin(), myvector.end(), myobject);     //(12 26 32 33 45 53 71 80)\n\n  // print out content:\n  std::cout << \"myvector contains:\";\n  for (std::vector<int>::iterator it=myvector.begin(); it!=myvector.end(); ++it)\n    std::cout << ' ' << *it;\n  std::cout << '\\n';\n\n  return 0;\n}\n```","slug":"2014-10-11-std-sort-function","published":1,"updated":"2015-04-30T11:58:41.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck4m003drwmw89zxurxw"},{"layout":"post","title":"set & map","date":"2014-10-11T07:34:20.000Z","_content":"\n###1.set\n\n如果需要使用二叉搜索树时，可以不用自己来实现，用STL中的set就可以。\n\n使用set的话必须包含set的头文件。\n\nset的操作如下代码：\n\n``` cpp\n#include <iostream>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    vector<int> ivec;\n    for (vector<int>::size_type i = 0; i != 10; ++i) {\n        ivec.push_back((int)i);\n        ivec.push_back((int)i); // duplicate copies of each number\n    }\n    \n    // iset holds unique elements from ivec\n    set<int> iset(ivec.begin(), ivec.end()); //初始化操作，也可以直接申明，而不初始化\n    cout << ivec.size() << endl;      // prints 20\n    cout << iset.size() << endl;      // prints 10，set中都是唯一的键值\n    \n    iset.insert(11); //insert操作\n    \n    set<int>::iterator set_it;\n    \n    set_it = iset.find(1);     // returns iterator that refers to the element with key == 1\n    \n    if (set_it != iset.end()) cout<<\"found\"<<endl;\n    else cout<<\"not found\"<<endl;\n    \n    set_it = iset.find(12);   // returns iterator == iset.end()\n    \n    if (set_it != iset.end()) cout<<\"found\"<<endl;\n    else cout<<\"not found\"<<endl;\n    \n    cout<<iset.count(1)<<endl;   // returns 1\n    cout<<iset.count(12)<<endl;  // returns 0\n    \n    iset.erase(11);     //erase 删除操作\n    \n    for (set_it = iset.begin(); set_it != iset.end(); set_it++) {\n        cout<<*set_it<<endl;\n    }\n}\n```\n\n###2.map\n\nmap 是键－值对的集合。map类型通常可理解为关联数组（associative array）\n可使用键作为下标来获取一个值，正如内置数组类型一样。\n\n要使用 map 对象，则必须包含 map 头文件。在定义 map 对象时，必须分别指明键和值的类型（value type）。\n\n\tmap<string, int> word_count; // empty map from string to int\n\n\nmap 类定义的类型:\n\n\tmap<K, V>::key_type //在 map 容器中，用做索引的键的类型\n\tmap<K, V>::mapped_type //在 map 容器中，键所关联的值的类型\n\tmap<K, V>::value_type //一个 pair 类型，它的 first 元素具有 const map<K, V>::key_type 类型，而 second 元素则为 map<K, V>::mapped_type 类型\n\n\t\n``` cpp\n#include <iostream>\n#include <queue>\n#include <set>\n#include <vector>\n#include <map>\n\n\nusing namespace std;\n\nconst int MAX_N = 10000;\n\nint n, L, P;\nint A[MAX_N], B[MAX_N];\n\nint main() {\n    map<string, int> word_count; // empty map from string to int\n    \n    // if Anna not already in word_count, inserts new element with value 1\n    word_count.insert(map<string, int>::value_type(\"Anna\", 1)); //插入操作\n    \n    word_count.insert(make_pair(\"Anna\", 4)); //也可以这样\n    \n    cout<<word_count[\"Anna\"]<<endl; //访问map元素\n    \n    //对于 map 对象，count 成员的返回值只能是 0 或 1。\n    cout<<word_count.count(\"Anna\")<<endl; //return 1\n\n    map<string,int>::iterator it = word_count.find(\"Anna\");//find 成员函数\n    if (it != word_count.end())\n        cout << it->second <<endl;\n    \n    word_count.erase(\"Anna\"); //删除元素\n    \n    cout<<word_count.count(\"Anna\")<<endl; //return 0\n    \n    \n}\n```","source":"_posts/2014-10-11-set-and-map.md","raw":"---\nlayout: post\ntitle:  \"set & map\"\ndate:   2014-10-11 15:34:20\ncategories:   cpp\n---\n\n###1.set\n\n如果需要使用二叉搜索树时，可以不用自己来实现，用STL中的set就可以。\n\n使用set的话必须包含set的头文件。\n\nset的操作如下代码：\n\n``` cpp\n#include <iostream>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    vector<int> ivec;\n    for (vector<int>::size_type i = 0; i != 10; ++i) {\n        ivec.push_back((int)i);\n        ivec.push_back((int)i); // duplicate copies of each number\n    }\n    \n    // iset holds unique elements from ivec\n    set<int> iset(ivec.begin(), ivec.end()); //初始化操作，也可以直接申明，而不初始化\n    cout << ivec.size() << endl;      // prints 20\n    cout << iset.size() << endl;      // prints 10，set中都是唯一的键值\n    \n    iset.insert(11); //insert操作\n    \n    set<int>::iterator set_it;\n    \n    set_it = iset.find(1);     // returns iterator that refers to the element with key == 1\n    \n    if (set_it != iset.end()) cout<<\"found\"<<endl;\n    else cout<<\"not found\"<<endl;\n    \n    set_it = iset.find(12);   // returns iterator == iset.end()\n    \n    if (set_it != iset.end()) cout<<\"found\"<<endl;\n    else cout<<\"not found\"<<endl;\n    \n    cout<<iset.count(1)<<endl;   // returns 1\n    cout<<iset.count(12)<<endl;  // returns 0\n    \n    iset.erase(11);     //erase 删除操作\n    \n    for (set_it = iset.begin(); set_it != iset.end(); set_it++) {\n        cout<<*set_it<<endl;\n    }\n}\n```\n\n###2.map\n\nmap 是键－值对的集合。map类型通常可理解为关联数组（associative array）\n可使用键作为下标来获取一个值，正如内置数组类型一样。\n\n要使用 map 对象，则必须包含 map 头文件。在定义 map 对象时，必须分别指明键和值的类型（value type）。\n\n\tmap<string, int> word_count; // empty map from string to int\n\n\nmap 类定义的类型:\n\n\tmap<K, V>::key_type //在 map 容器中，用做索引的键的类型\n\tmap<K, V>::mapped_type //在 map 容器中，键所关联的值的类型\n\tmap<K, V>::value_type //一个 pair 类型，它的 first 元素具有 const map<K, V>::key_type 类型，而 second 元素则为 map<K, V>::mapped_type 类型\n\n\t\n``` cpp\n#include <iostream>\n#include <queue>\n#include <set>\n#include <vector>\n#include <map>\n\n\nusing namespace std;\n\nconst int MAX_N = 10000;\n\nint n, L, P;\nint A[MAX_N], B[MAX_N];\n\nint main() {\n    map<string, int> word_count; // empty map from string to int\n    \n    // if Anna not already in word_count, inserts new element with value 1\n    word_count.insert(map<string, int>::value_type(\"Anna\", 1)); //插入操作\n    \n    word_count.insert(make_pair(\"Anna\", 4)); //也可以这样\n    \n    cout<<word_count[\"Anna\"]<<endl; //访问map元素\n    \n    //对于 map 对象，count 成员的返回值只能是 0 或 1。\n    cout<<word_count.count(\"Anna\")<<endl; //return 1\n\n    map<string,int>::iterator it = word_count.find(\"Anna\");//find 成员函数\n    if (it != word_count.end())\n        cout << it->second <<endl;\n    \n    word_count.erase(\"Anna\"); //删除元素\n    \n    cout<<word_count.count(\"Anna\")<<endl; //return 0\n    \n    \n}\n```","slug":"2014-10-11-set-and-map","published":1,"updated":"2015-04-30T11:58:25.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck4o003frwmw6cy54hmi"},{"layout":"post","title":"poj: 3253-Fence Repair","date":"2014-10-11T14:46:00.000Z","_content":"\n##Description\n\nFarmer John wants to repair a small length of the fence around the pasture. He measures the fence and finds that he needs N (1 ≤ N ≤ 20,000) planks of wood, each having some integer length Li (1 ≤ Li ≤ 50,000) units. He then purchases a single long board just long enough to saw into the N planks (i.e., whose length is the sum of the lengths Li). FJ is ignoring the \"kerf\", the extra length lost to sawdust when a sawcut is made; you should ignore it, too.\n\nFJ sadly realizes that he doesn't own a saw with which to cut the wood, so he mosies over to Farmer Don's Farm with this long board and politely asks if he may borrow a saw.\n\nFarmer Don, a closet capitalist, doesn't lend FJ a saw but instead offers to charge Farmer John for each of the N-1 cuts in the plank. The charge to cut a piece of wood is exactly equal to its length. Cutting a plank of length 21 costs 21 cents.\n\nFarmer Don then lets Farmer John decide the order and locations to cut the plank. Help Farmer John determine the minimum amount of money he can spend to create the N planks. FJ knows that he can cut the board in various different orders which will result in different charges since the resulting intermediate planks are of different lengths.\n\n\n##代码实现\n``` cpp\n\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n    int n;\n    //这个题可以看看挑战程序设计竞赛一书47页的分析，这个题和霍夫曼编码很像\n    //主要是stl中优先级队列的使用，事半功倍\n    priority_queue<int, vector<int>, greater<int>> que; \n    ll ans = 0;\n    cin>>n;\n    for (int i = 0; i < n; i++) {\n        int tmp = 0;\n        cin>>tmp;\n        que.push(tmp);\n    }\n    \n    while (que.size() > 1) {\n        int l1, l2;\n        l1 = que.top();\n        que.pop();\n        l2 = que.top();\n        que.pop();\n        \n        ans += l1 + l2;\n        que.push(l1 + l2);\n    }\n    \n    cout<<ans<<endl;\n    return 0;\n}\n```","source":"_posts/2014-10-11-poj-3253-Fence-Repair.md","raw":"---\nlayout: post\ntitle:  \"poj: 3253-Fence Repair\"\ndate:   2014-10-11 22:46\ncategories: problems\n---\n\n##Description\n\nFarmer John wants to repair a small length of the fence around the pasture. He measures the fence and finds that he needs N (1 ≤ N ≤ 20,000) planks of wood, each having some integer length Li (1 ≤ Li ≤ 50,000) units. He then purchases a single long board just long enough to saw into the N planks (i.e., whose length is the sum of the lengths Li). FJ is ignoring the \"kerf\", the extra length lost to sawdust when a sawcut is made; you should ignore it, too.\n\nFJ sadly realizes that he doesn't own a saw with which to cut the wood, so he mosies over to Farmer Don's Farm with this long board and politely asks if he may borrow a saw.\n\nFarmer Don, a closet capitalist, doesn't lend FJ a saw but instead offers to charge Farmer John for each of the N-1 cuts in the plank. The charge to cut a piece of wood is exactly equal to its length. Cutting a plank of length 21 costs 21 cents.\n\nFarmer Don then lets Farmer John decide the order and locations to cut the plank. Help Farmer John determine the minimum amount of money he can spend to create the N planks. FJ knows that he can cut the board in various different orders which will result in different charges since the resulting intermediate planks are of different lengths.\n\n\n##代码实现\n``` cpp\n\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n    int n;\n    //这个题可以看看挑战程序设计竞赛一书47页的分析，这个题和霍夫曼编码很像\n    //主要是stl中优先级队列的使用，事半功倍\n    priority_queue<int, vector<int>, greater<int>> que; \n    ll ans = 0;\n    cin>>n;\n    for (int i = 0; i < n; i++) {\n        int tmp = 0;\n        cin>>tmp;\n        que.push(tmp);\n    }\n    \n    while (que.size() > 1) {\n        int l1, l2;\n        l1 = que.top();\n        que.pop();\n        l2 = que.top();\n        que.pop();\n        \n        ans += l1 + l2;\n        que.push(l1 + l2);\n    }\n    \n    cout<<ans<<endl;\n    return 0;\n}\n```","slug":"2014-10-11-poj-3253-Fence-Repair","published":1,"updated":"2015-04-30T11:51:56.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck4t003hrwmwuhysmpu3"},{"layout":"post","title":"poj: 2431-Expedition","date":"2014-10-11T13:09:20.000Z","_content":"\n\n##Description\n\nA group of cows grabbed a truck and ventured on an expedition deep into the jungle. Being rather poor drivers, the cows unfortunately managed to run over a rock and puncture the truck's fuel tank. The truck now leaks one unit of fuel every unit of distance it travels. \n\nTo repair the truck, the cows need to drive to the nearest town (no more than 1,000,000 units distant) down a long, winding road. On this road, between the town and the current location of the truck, there are N (1 <= N <= 10,000) fuel stops where the cows can stop to acquire additional fuel (1..100 units at each stop). \n\nThe jungle is a dangerous place for humans and is especially dangerous for cows. Therefore, the cows want to make the minimum possible number of stops for fuel on the way to the town. Fortunately, the capacity of the fuel tank on their truck is so large that there is effectively no limit to the amount of fuel it can hold. The truck is currently L units away from the town and has P units of fuel (1 <= P <= 1,000,000). \n\nDetermine the minimum number of stops needed to reach the town, or if the cows cannot reach the town at all. \n\n##分析\n这个题其实可以这样理解，车开过一个加油站我们可以把油记下，如果在路上油不够了随时可以加。\n\n所以加油的策略就是我们只加油量最多的站。而这个策略我们可以使用优先级队列来实现。\n\n在这个题中，有两个很好的地方需要注意：\n\n1.c++中优先级队列的使用\n\n2.c++中sort()函数的使用\n\n如果c++的STL和标准类库中的工具用的好的话可以事半功倍。\n\n\n``` cpp\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nconst int MAX_N = 10000;\n\nint n, L, P;\nint A[MAX_N + 1], B[MAX_N + 1];\n\n//定义加油站的结构体\nstruct node {\n    int pos, fuel;\n};\n\nnode positions[MAX_N + 1];\n\n//自定义一个降序排序的比较函数\nbool cmp(const node &a, const node &b) {\n    return a.pos > b.pos;\n}\n\nvoid solve() {\n    positions[n].pos = L; //终点位置\n    positions[n].fuel = 0;\n    n++;\n    \n    priority_queue<int> que;\n    \n    int ans = 0, pos = 0, tank = P;\n    \n    for (int i = 0; i < n; i++) {\n        //要前进的距离\n        int d = positions[i].pos - pos;\n        \n        //不断加油直到能够到下一个加油站\n        while (tank < d) {\n            if (que.empty()) {\n                cout<<\"-1\"<<endl;\n                return;\n            }\n            \n            tank += que.top();\n            que.pop();\n            ans++;\n        }\n        \n        tank -= d;\n        pos = positions[i].pos;\n        que.push(positions[i].fuel);\n    }\n    cout<<ans<<endl;\n}\n\nint main() {\n    cin>>n;\n    \n    for (int i = n - 1; i >= 0; i--) {\n        cin>>positions[i].pos>>positions[i].fuel;\n    }\n    \n    sort(positions, positions + n, cmp); //对输入进行降序排序\n    \n    cin>>L>>P;\n    \n    for (int i = 0; i < n; i++) {\n        positions[i].pos = L - positions[i].pos; //计算每一个加油站到起点的距离\n    }\n    \n    solve();\n}\n```","source":"_posts/2014-10-11-poj-2431-Expedition.md","raw":"---\nlayout: post\ntitle:  \"poj: 2431-Expedition\"\ndate:   2014-10-11 21:09:20\ncategories: problems\n---\n\n\n##Description\n\nA group of cows grabbed a truck and ventured on an expedition deep into the jungle. Being rather poor drivers, the cows unfortunately managed to run over a rock and puncture the truck's fuel tank. The truck now leaks one unit of fuel every unit of distance it travels. \n\nTo repair the truck, the cows need to drive to the nearest town (no more than 1,000,000 units distant) down a long, winding road. On this road, between the town and the current location of the truck, there are N (1 <= N <= 10,000) fuel stops where the cows can stop to acquire additional fuel (1..100 units at each stop). \n\nThe jungle is a dangerous place for humans and is especially dangerous for cows. Therefore, the cows want to make the minimum possible number of stops for fuel on the way to the town. Fortunately, the capacity of the fuel tank on their truck is so large that there is effectively no limit to the amount of fuel it can hold. The truck is currently L units away from the town and has P units of fuel (1 <= P <= 1,000,000). \n\nDetermine the minimum number of stops needed to reach the town, or if the cows cannot reach the town at all. \n\n##分析\n这个题其实可以这样理解，车开过一个加油站我们可以把油记下，如果在路上油不够了随时可以加。\n\n所以加油的策略就是我们只加油量最多的站。而这个策略我们可以使用优先级队列来实现。\n\n在这个题中，有两个很好的地方需要注意：\n\n1.c++中优先级队列的使用\n\n2.c++中sort()函数的使用\n\n如果c++的STL和标准类库中的工具用的好的话可以事半功倍。\n\n\n``` cpp\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nconst int MAX_N = 10000;\n\nint n, L, P;\nint A[MAX_N + 1], B[MAX_N + 1];\n\n//定义加油站的结构体\nstruct node {\n    int pos, fuel;\n};\n\nnode positions[MAX_N + 1];\n\n//自定义一个降序排序的比较函数\nbool cmp(const node &a, const node &b) {\n    return a.pos > b.pos;\n}\n\nvoid solve() {\n    positions[n].pos = L; //终点位置\n    positions[n].fuel = 0;\n    n++;\n    \n    priority_queue<int> que;\n    \n    int ans = 0, pos = 0, tank = P;\n    \n    for (int i = 0; i < n; i++) {\n        //要前进的距离\n        int d = positions[i].pos - pos;\n        \n        //不断加油直到能够到下一个加油站\n        while (tank < d) {\n            if (que.empty()) {\n                cout<<\"-1\"<<endl;\n                return;\n            }\n            \n            tank += que.top();\n            que.pop();\n            ans++;\n        }\n        \n        tank -= d;\n        pos = positions[i].pos;\n        que.push(positions[i].fuel);\n    }\n    cout<<ans<<endl;\n}\n\nint main() {\n    cin>>n;\n    \n    for (int i = n - 1; i >= 0; i--) {\n        cin>>positions[i].pos>>positions[i].fuel;\n    }\n    \n    sort(positions, positions + n, cmp); //对输入进行降序排序\n    \n    cin>>L>>P;\n    \n    for (int i = 0; i < n; i++) {\n        positions[i].pos = L - positions[i].pos; //计算每一个加油站到起点的距离\n    }\n    \n    solve();\n}\n```","slug":"2014-10-11-poj-2431-Expedition","published":1,"updated":"2015-04-30T11:56:56.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck4w003jrwmw4yy0xso0"},{"layout":"post","title":"动态规划: Edit Distance","date":"2014-09-26T08:07:20.000Z","_content":"\n>Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)\n>\n>You have the following 3 operations permitted on a word:\n>\n>a) Insert a character<br>\n>b) Delete a character<br>\n>c) Replace a character<br>\n\n\n编辑距离，又称Levenshtein距离，是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。\n\n例如将kitten一字转成sitting：\n\n1. sitten （k→s）\n2. sittin （e→i）\n3. sitting （→g）\n\n思路如下：\n设dp[i][j]表示word1[0, i]与word2[0, j]的编辑距离\n那么根据编辑操作的三种方式，我们有：\n\n```\n1.如果word1[i] == word2[j]\n    dp[i][j] = dp[i - 1][j - 1]\n2.如果word1[i] != word2[j]\n    dp[i][j] = min (\n        dp[i - 1][j],           //在word1中删除一个字符word1[i]\n        dp[i][j - 1],           //在word1中插入一个字符word2[j]\n        dp[i - 1][j - 1]  + 1   //替换word1[i] == word2[j]\n    )\n```\n\n``` cpp\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        const size_t len1 = word1.size();\n        const size_t len2 = word2.size();\n\n        int dp[len1 + 1][len2 + 1];\n        for (int i = 0; i <= len1; i++) {\n            dp[i][0] = i;\n        }\n        for (int j = 0; j <= len2; j++) {\n            dp[0][j] = j;\n        }\n\n        for (int i = 1; i <= len1; i++) {\n            for (int j = 1; j <= len2; j++) {\n                if (word1[i - 1] == word2[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    int mn = min(dp[i - 1][j], dp[i][j - 1]); //删除\n                    dp[i][j] = 1 + min(dp[i - 1][j - 1], mn);  //替换\n                }\n            }\n        }\n        return dp[len1][len2];\n}\n};\n```","source":"_posts/2014-09-26-leetcode-edit-distance.md","raw":"---\nlayout: post\ntitle:  \"动态规划: Edit Distance\"\ndate:   2014-09-26 16:07:20\ncategories: problems\ntags: [动态规划]\n---\n\n>Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)\n>\n>You have the following 3 operations permitted on a word:\n>\n>a) Insert a character<br>\n>b) Delete a character<br>\n>c) Replace a character<br>\n\n\n编辑距离，又称Levenshtein距离，是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。\n\n例如将kitten一字转成sitting：\n\n1. sitten （k→s）\n2. sittin （e→i）\n3. sitting （→g）\n\n思路如下：\n设dp[i][j]表示word1[0, i]与word2[0, j]的编辑距离\n那么根据编辑操作的三种方式，我们有：\n\n```\n1.如果word1[i] == word2[j]\n    dp[i][j] = dp[i - 1][j - 1]\n2.如果word1[i] != word2[j]\n    dp[i][j] = min (\n        dp[i - 1][j],           //在word1中删除一个字符word1[i]\n        dp[i][j - 1],           //在word1中插入一个字符word2[j]\n        dp[i - 1][j - 1]  + 1   //替换word1[i] == word2[j]\n    )\n```\n\n``` cpp\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        const size_t len1 = word1.size();\n        const size_t len2 = word2.size();\n\n        int dp[len1 + 1][len2 + 1];\n        for (int i = 0; i <= len1; i++) {\n            dp[i][0] = i;\n        }\n        for (int j = 0; j <= len2; j++) {\n            dp[0][j] = j;\n        }\n\n        for (int i = 1; i <= len1; i++) {\n            for (int j = 1; j <= len2; j++) {\n                if (word1[i - 1] == word2[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    int mn = min(dp[i - 1][j], dp[i][j - 1]); //删除\n                    dp[i][j] = 1 + min(dp[i - 1][j - 1], mn);  //替换\n                }\n            }\n        }\n        return dp[len1][len2];\n}\n};\n```","slug":"2014-09-26-leetcode-edit-distance","published":1,"updated":"2015-05-04T13:44:05.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck50003lrwmw72lqlab4"},{"layout":"post","title":"动态规划: Distinct Subsequences ","date":"2014-09-25T13:00:20.000Z","_content":"\n>Given a string S and a string T, count the number of distinct subsequences of T in S.<br>\nA subsequence of a string is a new string which is formed from the original string by\ndeleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, `\"ACE\"` is a subsequence of `\"ABCDE\"` while `\"AEC\"` is not).<br>\nHere is an example:<br>\nS = `\"rabbbit\"`, T = `\"rabbit\"`<br>\nReturn 3.\n\n###1.DFS解法\n这道题如果简单地想的话，可以使用DFS来解。但是使用DFS的话时间复杂度很高，可能会超时，比如这个题。代码如下。\n\n``` cpp\nclass Solution {\npublic:\n    string s;\n    string t;\n    int len_s;\n    int len_t;\n    \n    int numDistinct(string S, string T) {\n        s = S;\n        t = T;\n        len_s = s.size();\n        len_t = t.size();\n        \n        if (len_s == 0 || len_t == 0) {\n            return 0;\n        }\n        \n        return rec(0, 0);\n    }\n    \n    //i for pointer of T, j for pointer of S\n    int rec(int i, int j) {\n        int res = 0;\n        if (i == len_t) {\n            res = 1;\n        } else if (j == len_s) {\n            res = 0;\n        } else if (t[i] == s[j]) {\n            res = rec(i + 1, j + 1) + rec(i, j + 1);\n        } else {\n            res = rec(i, j + 1);\n        }\n        \n        return res;\n    }\n};\n```\n###2.在上一种解法上使用动态规划\n由于DFS的时间限制，我们可以在上一种方法上进行改进，加上一个备忘数组，使用动态规划来解，就可以显著地降低时间复杂度。代码如下：\n\n```\nclass Solution {\npublic:\n    string s;\n    string t;\n    int len_s;\n    int len_t;\n    vector<vector<int>> dp;\n    \n    int numDistinct(string S, string T) {\n        s = S;\n        t = T;\n        len_s = s.size();\n        len_t = t.size();\n        \n        if (len_s == 0 || len_t == 0) {\n            return 0;\n        }\n        \n        vector<int> row(len_s + 1, -1);\n        for (int i = 0; i <= len_t; i++) {\n            dp.push_back(row);\n        }\n        \n        return rec(0, 0);\n    }\n    \n    //i for pointer of T, j for pointer of S\n    int rec(int i, int j) {\n        if (dp[i][j] >= 0) {\n            return dp[i][j];\n        }\n        \n        int res = 0;\n        if (i == len_t) {\n            res = 1;\n        } else if (j == len_s) {\n            res = 0;\n        } else if (t[i] == s[j]) {\n            res = rec(i + 1, j + 1) + rec(i, j + 1);\n        } else {\n            res = rec(i, j + 1);\n        }\n        \n        return dp[i][j] = res;\n    }\n};\n```\n\n####3.继续改进\n虽然上一种方法使用动态规划能够通过，但是空间复杂度很高，所以要我们追求一种空间复杂度比较低的解法。\n\n先给出递推关系：\n\n设dp(i, j)表示T[0, j]在S[0, i]中出现的次数\n\n1.如果T[j] != S[i]，dp(i, j) = dp(i - 1, j)\n\n2.如果T[j] == S[i]，dp(i, j) = dp(i - 1, j - 1) + dp(i - 1, j)\n\n简单地想我们就可以使用一个dp[i][j]的辅助数组来解决问题，但是仔细看看这个题的话，我们可以发现dp(i, j) 只和dp(i - 1, j - 1),dp(i - 1, j)有关，恰好是后一行的结果只和前一行的结果有关，所以我们就可以只声明一个一行的一维数组，即一个滚动数组来完成二维数组的功能。\n\n``` cpp\nclass Solution {\npublic:\n    int numDistinct(string S, string T) {\n\t\tvector<int> dp(T.size() + 1, 0);\n\t\tdp[0] = 1;\n\t\tfor (int i = 0; i < S.size(); i++) {\n\t\t\tfor (int j = T.size() - 1; j >= 0; j--) {\n\t\t\t\tdp[j + 1] += S[i] == T[j] ? dp[j] : 0;\n\t\t\t}\n\t\t}\t\t    \n\t\treturn dp[T.size()];\n\t}\n};\n```\n","source":"_posts/2014-09-25-leetcode-distinct-subsequences.md","raw":"---\nlayout: post\ntitle:  \"动态规划: Distinct Subsequences \"\ndate:   2014-09-25 21:00:20\ncategories: problems\ntags: [动态规划]\n---\n\n>Given a string S and a string T, count the number of distinct subsequences of T in S.<br>\nA subsequence of a string is a new string which is formed from the original string by\ndeleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, `\"ACE\"` is a subsequence of `\"ABCDE\"` while `\"AEC\"` is not).<br>\nHere is an example:<br>\nS = `\"rabbbit\"`, T = `\"rabbit\"`<br>\nReturn 3.\n\n###1.DFS解法\n这道题如果简单地想的话，可以使用DFS来解。但是使用DFS的话时间复杂度很高，可能会超时，比如这个题。代码如下。\n\n``` cpp\nclass Solution {\npublic:\n    string s;\n    string t;\n    int len_s;\n    int len_t;\n    \n    int numDistinct(string S, string T) {\n        s = S;\n        t = T;\n        len_s = s.size();\n        len_t = t.size();\n        \n        if (len_s == 0 || len_t == 0) {\n            return 0;\n        }\n        \n        return rec(0, 0);\n    }\n    \n    //i for pointer of T, j for pointer of S\n    int rec(int i, int j) {\n        int res = 0;\n        if (i == len_t) {\n            res = 1;\n        } else if (j == len_s) {\n            res = 0;\n        } else if (t[i] == s[j]) {\n            res = rec(i + 1, j + 1) + rec(i, j + 1);\n        } else {\n            res = rec(i, j + 1);\n        }\n        \n        return res;\n    }\n};\n```\n###2.在上一种解法上使用动态规划\n由于DFS的时间限制，我们可以在上一种方法上进行改进，加上一个备忘数组，使用动态规划来解，就可以显著地降低时间复杂度。代码如下：\n\n```\nclass Solution {\npublic:\n    string s;\n    string t;\n    int len_s;\n    int len_t;\n    vector<vector<int>> dp;\n    \n    int numDistinct(string S, string T) {\n        s = S;\n        t = T;\n        len_s = s.size();\n        len_t = t.size();\n        \n        if (len_s == 0 || len_t == 0) {\n            return 0;\n        }\n        \n        vector<int> row(len_s + 1, -1);\n        for (int i = 0; i <= len_t; i++) {\n            dp.push_back(row);\n        }\n        \n        return rec(0, 0);\n    }\n    \n    //i for pointer of T, j for pointer of S\n    int rec(int i, int j) {\n        if (dp[i][j] >= 0) {\n            return dp[i][j];\n        }\n        \n        int res = 0;\n        if (i == len_t) {\n            res = 1;\n        } else if (j == len_s) {\n            res = 0;\n        } else if (t[i] == s[j]) {\n            res = rec(i + 1, j + 1) + rec(i, j + 1);\n        } else {\n            res = rec(i, j + 1);\n        }\n        \n        return dp[i][j] = res;\n    }\n};\n```\n\n####3.继续改进\n虽然上一种方法使用动态规划能够通过，但是空间复杂度很高，所以要我们追求一种空间复杂度比较低的解法。\n\n先给出递推关系：\n\n设dp(i, j)表示T[0, j]在S[0, i]中出现的次数\n\n1.如果T[j] != S[i]，dp(i, j) = dp(i - 1, j)\n\n2.如果T[j] == S[i]，dp(i, j) = dp(i - 1, j - 1) + dp(i - 1, j)\n\n简单地想我们就可以使用一个dp[i][j]的辅助数组来解决问题，但是仔细看看这个题的话，我们可以发现dp(i, j) 只和dp(i - 1, j - 1),dp(i - 1, j)有关，恰好是后一行的结果只和前一行的结果有关，所以我们就可以只声明一个一行的一维数组，即一个滚动数组来完成二维数组的功能。\n\n``` cpp\nclass Solution {\npublic:\n    int numDistinct(string S, string T) {\n\t\tvector<int> dp(T.size() + 1, 0);\n\t\tdp[0] = 1;\n\t\tfor (int i = 0; i < S.size(); i++) {\n\t\t\tfor (int j = T.size() - 1; j >= 0; j--) {\n\t\t\t\tdp[j + 1] += S[i] == T[j] ? dp[j] : 0;\n\t\t\t}\n\t\t}\t\t    \n\t\treturn dp[T.size()];\n\t}\n};\n```\n","slug":"2014-09-25-leetcode-distinct-subsequences","published":1,"updated":"2015-05-04T13:43:57.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck57003orwmwj9xc0syg"},{"layout":"post","title":"动态规划: Decode Ways","date":"2014-09-24T11:09:20.000Z","_content":"\n>A message containing letters from A-Z is being encoded to numbers using the >following mapping:<br>\n`'A' -> 1` <br>\n`'B' -> 2` <br>\n`...` <br>\n`'Z' -> 26`<br>\nGiven an encoded message containing digits, determine the total number of ways to decode it.<br>\nFor example,<br>\nGiven encoded message `\"12\"`, it could be decoded as `\"AB\"` (1 2) or `\"L\"` (12).<br>\nThe number of ways decoding `\"12\"` is 2.<br>\n\n``` cpp\n/*\n这个题是Climing Stairs的升级版，在前面的基础上加了几个判断条件：\n1.先判断边界条件，如果字符串为空或者s为“0”的话，结果为0\n2.判断当前字符是否为“0”，前面一个字符和当前字符组合是否大于26\n\n做这种题应当注意边界条件，把所有的情况都考虑进去，有时候不小心就会忘掉\n当前字符为‘0’的情况\n*/\nclass Solution {\npublic:\n    int numDecodings(string s) {\n    \tif (s.empty() || s == \"0\")\n    \t\treturn 0;\n\n        int pre = 0, cur = 1;\n        \n        for (int i = 1; i <= s.size(); i++) {\n        \tif (s[i - 1] == '0')\n        \t\tcur = 0;\n\n        \tif (!(s[i - 2] == '1' || (s[i - 2] == '2' && s[i - 1] <= '6')))\n        \t\tpre = 0;\n\n      \t\tint tmp = cur;\n      \t\tcur = pre + cur;\n      \t\tpre = tmp;\n        }\n        return cur;\n    }\n};\n```","source":"_posts/2014-09-24-leetcode-decode-ways.md","raw":"---\nlayout: post\ntitle:  \"动态规划: Decode Ways\"\ndate:   2014-09-24 19:09:20\ncategories: problems\ntags: [动态规划]\n---\n\n>A message containing letters from A-Z is being encoded to numbers using the >following mapping:<br>\n`'A' -> 1` <br>\n`'B' -> 2` <br>\n`...` <br>\n`'Z' -> 26`<br>\nGiven an encoded message containing digits, determine the total number of ways to decode it.<br>\nFor example,<br>\nGiven encoded message `\"12\"`, it could be decoded as `\"AB\"` (1 2) or `\"L\"` (12).<br>\nThe number of ways decoding `\"12\"` is 2.<br>\n\n``` cpp\n/*\n这个题是Climing Stairs的升级版，在前面的基础上加了几个判断条件：\n1.先判断边界条件，如果字符串为空或者s为“0”的话，结果为0\n2.判断当前字符是否为“0”，前面一个字符和当前字符组合是否大于26\n\n做这种题应当注意边界条件，把所有的情况都考虑进去，有时候不小心就会忘掉\n当前字符为‘0’的情况\n*/\nclass Solution {\npublic:\n    int numDecodings(string s) {\n    \tif (s.empty() || s == \"0\")\n    \t\treturn 0;\n\n        int pre = 0, cur = 1;\n        \n        for (int i = 1; i <= s.size(); i++) {\n        \tif (s[i - 1] == '0')\n        \t\tcur = 0;\n\n        \tif (!(s[i - 2] == '1' || (s[i - 2] == '2' && s[i - 1] <= '6')))\n        \t\tpre = 0;\n\n      \t\tint tmp = cur;\n      \t\tcur = pre + cur;\n      \t\tpre = tmp;\n        }\n        return cur;\n    }\n};\n```","slug":"2014-09-24-leetcode-decode-ways","published":1,"updated":"2015-05-04T13:43:45.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck59003rrwmwdp60dwwl"},{"layout":"post","title":"DFS: 部分和问题与01背包","date":"2014-09-24T15:01:20.000Z","_content":"\n###部分和问题\n\n``` cpp\n/*\n此题见于挑战程序设计竞赛书30页\n\n给定整数 a 1 、a 2 、…、a n ，判断是否可以从中选出若干数，使它们的和恰好为 k。\n\n*/\n\n#include <iostream>\nusing namespace std;\n\nconst int MAX_N = 20;\n\nint a[MAX_N];\nint k;\n\n/*\n\t此题为经典的深度优先搜索，特征就是一个问题共分几步，每步都有几种可能，\n\t我们可以通过递归来实现这样的问题\n\t这种方法的一个缺点就是时间复杂度很高，为O(2^n)，只适合解决规模较小的问题\n*/\nbool rec(int i, int j) {\n\tbool res = false;\n\n\tif (i == n) {\n\t\tif (j == 0) {\n\t\t\tres = true;\n\t\t} \t\n\t} else if (j < a[i]) {\n\t\tres = rec(i + 1, j);\n\t} else {\n\t\tres = rec(i + 1, j) || rec(i + 1, j - a[i]);\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin>>a[i];\n\t}\n\tcin>>k;\n\n\tif (rec(0, k)) {\n\t\tcout<<\"Yes\"<<endl;\n\t} else {\n\t\tcout<<\"No\"<<endl;\n\t}\n}\n```\n\n###01背包问题\n\n####DFS解法\n\n``` cpp\n/*\n此题见于挑战一书51页\n*/\n#include <iostream>\nusing namespace std;\n\nconst int MAX_N = 100;\n\nint n, W;\nint w[MAX_N], v[MAX_N];\n\nint rec(int i, int j) {\n\tint res;\n\tif (i == n) {\n\t\tres = 0;\n\t} else if (j < w[i]) {\n\t\tres = rec(i + 1, j);\n\t} else {\n\t\tres = max(rec(i + 1, j), rec(i + 1, j - w[i]) + v[i]);\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin>>n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin>>w[i]>>v[i];\n\t}\n\tcin>>W;\n\tcout<<rec(0, W);\n}\n```\n\n####动态规划解法\n\n``` cpp\n/*\n此题见于挑战一书51页\n有n个重量和价值分别为wi和vi的物品。从这些物品中挑选出总重量不超过W的物品，求所有\n挑选方案中价值总和的最大值。\n*/\n#include <iostream>\nusing namespace std;\n\nconst int MAX_N = 100;\n\nint n, W;\nint w[MAX_N], v[MAX_N];\nint dp[MAX_N + 1][MAX_N + 1];\n\n/*\n\t这种解法算是动态规划的一个入门\n\t由于使用DFS会重复计算很多次rec(i,j)的结果，所以我们就可以定义一个数组来存储\n\t中间结果，这样就可以降低时间复杂度到O(n*W)，但是这需要O(n^2)的存储空间，以空间换时间，\n\t有利有弊\n*/\nint rec(int i, int j) {\n\tif (dp[i][j] >= 0) {\n\t\treturn dp[i][j];\n\t}\n\n\tint res;\n\tif (i == n) {\n\t\tres = 0;\n\t} else if (j < w[i]) {\n\t\tres = rec(i + 1, j);\n\t} else {\n\t\tres = max(rec(i + 1, j), rec(i + 1, j - w[i]) + v[i]);\n\t}\n\n\treturn dp[i][j] = res;\n}\n\nint main() {\n\tcin>>n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin>>w[i]>>v[i];\n\t}\n\tcin>>W;\n\tmemset(dp, -1, sizeof(dp));\n\tcout<<rec(0, W);\n}\n```","source":"_posts/2014-09-24-2301.md","raw":"---\nlayout: post\ntitle: \"DFS: 部分和问题与01背包\"\ndate:   2014-09-24 23:01:20\ncategories: problems\n---\n\n###部分和问题\n\n``` cpp\n/*\n此题见于挑战程序设计竞赛书30页\n\n给定整数 a 1 、a 2 、…、a n ，判断是否可以从中选出若干数，使它们的和恰好为 k。\n\n*/\n\n#include <iostream>\nusing namespace std;\n\nconst int MAX_N = 20;\n\nint a[MAX_N];\nint k;\n\n/*\n\t此题为经典的深度优先搜索，特征就是一个问题共分几步，每步都有几种可能，\n\t我们可以通过递归来实现这样的问题\n\t这种方法的一个缺点就是时间复杂度很高，为O(2^n)，只适合解决规模较小的问题\n*/\nbool rec(int i, int j) {\n\tbool res = false;\n\n\tif (i == n) {\n\t\tif (j == 0) {\n\t\t\tres = true;\n\t\t} \t\n\t} else if (j < a[i]) {\n\t\tres = rec(i + 1, j);\n\t} else {\n\t\tres = rec(i + 1, j) || rec(i + 1, j - a[i]);\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin>>a[i];\n\t}\n\tcin>>k;\n\n\tif (rec(0, k)) {\n\t\tcout<<\"Yes\"<<endl;\n\t} else {\n\t\tcout<<\"No\"<<endl;\n\t}\n}\n```\n\n###01背包问题\n\n####DFS解法\n\n``` cpp\n/*\n此题见于挑战一书51页\n*/\n#include <iostream>\nusing namespace std;\n\nconst int MAX_N = 100;\n\nint n, W;\nint w[MAX_N], v[MAX_N];\n\nint rec(int i, int j) {\n\tint res;\n\tif (i == n) {\n\t\tres = 0;\n\t} else if (j < w[i]) {\n\t\tres = rec(i + 1, j);\n\t} else {\n\t\tres = max(rec(i + 1, j), rec(i + 1, j - w[i]) + v[i]);\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin>>n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin>>w[i]>>v[i];\n\t}\n\tcin>>W;\n\tcout<<rec(0, W);\n}\n```\n\n####动态规划解法\n\n``` cpp\n/*\n此题见于挑战一书51页\n有n个重量和价值分别为wi和vi的物品。从这些物品中挑选出总重量不超过W的物品，求所有\n挑选方案中价值总和的最大值。\n*/\n#include <iostream>\nusing namespace std;\n\nconst int MAX_N = 100;\n\nint n, W;\nint w[MAX_N], v[MAX_N];\nint dp[MAX_N + 1][MAX_N + 1];\n\n/*\n\t这种解法算是动态规划的一个入门\n\t由于使用DFS会重复计算很多次rec(i,j)的结果，所以我们就可以定义一个数组来存储\n\t中间结果，这样就可以降低时间复杂度到O(n*W)，但是这需要O(n^2)的存储空间，以空间换时间，\n\t有利有弊\n*/\nint rec(int i, int j) {\n\tif (dp[i][j] >= 0) {\n\t\treturn dp[i][j];\n\t}\n\n\tint res;\n\tif (i == n) {\n\t\tres = 0;\n\t} else if (j < w[i]) {\n\t\tres = rec(i + 1, j);\n\t} else {\n\t\tres = max(rec(i + 1, j), rec(i + 1, j - w[i]) + v[i]);\n\t}\n\n\treturn dp[i][j] = res;\n}\n\nint main() {\n\tcin>>n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin>>w[i]>>v[i];\n\t}\n\tcin>>W;\n\tmemset(dp, -1, sizeof(dp));\n\tcout<<rec(0, W);\n}\n```","slug":"2014-09-24-2301","published":1,"updated":"2015-04-30T11:43:14.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck5g003urwmwna8fnyfl"},{"layout":"post","title":"动态规划: Word Break","date":"2014-09-23T07:31:20.000Z","_content":"\n>Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.<br>\nFor example, given<br>\ns = `\"leetcode\"`,<br>\ndict = `[\"leet\", \"code\"]`.<br>\nReturn `true` because `\"leetcode\"` can be segmented as `\"leet code\"`.\n\n``` cpp\nclass Solution {\npublic:\n    //这是题解上给的答案，比较简单\n    //设状态为 f(i),表示s[0, j]是否可以分词，递推关系如下：\n    //f(i) = any_of(f(j) && s[j + 1, i] ∈ dict), 0 ≤ j < i\n    bool wordBreak(string s, unordered_set<string> &dict) {\n        int len = s.size();\n        vector<bool> f(len + 1, false);\n        f[0] = true; //空字符串设置为true\n        for (int i = 1; i <= len; i++) {\n            for (int j = 0; j < i; j++) {\n                if (f[j] && isInSet(s.substr(j, i - j))) {\n                    f[i] = true;\n                    break;\n                }\n            }\n        }   \n        return f[len];\n    }\n\n    //这个解法是我自己写的，思路与算法导论上矩阵链乘法上讲的思路一致\n    //设dp[i][j]表示s[i, j]是否可以分词，那么，我们也可以得到一个递推关系:\n    //dp[i][j] = any_of(dp[i][k] && dp[k + 1][j]) || s[i, j] ∈ dict\n    //这样一个问题就分解为两个子问题\n    //在这个问题上最有特点的应该是求dp[i][j]的方式，它是以j-i的长度从小到大的顺序\n    //求的\n    bool wordBreakMy(string s, unordered_set<string> &dict) {\n        int len = (int) s.size();\n        vector<bool> row(len, false);\n        vector<vector<bool>> dp(len, row);\n        for (int i = 0; i < len; i++) {\n            string tmp = s.substr(i, 1);\n            if (isInSet(tmp, dict)) {\n                dp[i][i] = true;\n            }\n        }\n        \n        for (int l = 2; l <= len; l++) {\n            for (int i = 0; i < len - l + 1; i++) {\n                int j = i + l - 1;\n                bool flag = isInSet(s.substr(i, l), dict);\n                for (int k = i; k < j && !flag; k++) {\n                    flag |= (dp[i][k] && dp[k + 1][j]);\n                }\n                dp[i][j] = flag;\n            }\n        }\n        \n        return dp[0][len - 1];\n    }\n    \n    bool isInSet(const string &str, const unordered_set<string> &dict) {\n        unordered_set<string>::const_iterator got = dict.find(str);\n        if (got == dict.end()) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n};\n```","source":"_posts/2014-09-23-leetcode-word-break.md","raw":"---\nlayout: post\ntitle:  \"动态规划: Word Break\"\ndate:   2014-09-23 15:31:20\ncategories: problems\ntags: [动态规划]\n---\n\n>Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.<br>\nFor example, given<br>\ns = `\"leetcode\"`,<br>\ndict = `[\"leet\", \"code\"]`.<br>\nReturn `true` because `\"leetcode\"` can be segmented as `\"leet code\"`.\n\n``` cpp\nclass Solution {\npublic:\n    //这是题解上给的答案，比较简单\n    //设状态为 f(i),表示s[0, j]是否可以分词，递推关系如下：\n    //f(i) = any_of(f(j) && s[j + 1, i] ∈ dict), 0 ≤ j < i\n    bool wordBreak(string s, unordered_set<string> &dict) {\n        int len = s.size();\n        vector<bool> f(len + 1, false);\n        f[0] = true; //空字符串设置为true\n        for (int i = 1; i <= len; i++) {\n            for (int j = 0; j < i; j++) {\n                if (f[j] && isInSet(s.substr(j, i - j))) {\n                    f[i] = true;\n                    break;\n                }\n            }\n        }   \n        return f[len];\n    }\n\n    //这个解法是我自己写的，思路与算法导论上矩阵链乘法上讲的思路一致\n    //设dp[i][j]表示s[i, j]是否可以分词，那么，我们也可以得到一个递推关系:\n    //dp[i][j] = any_of(dp[i][k] && dp[k + 1][j]) || s[i, j] ∈ dict\n    //这样一个问题就分解为两个子问题\n    //在这个问题上最有特点的应该是求dp[i][j]的方式，它是以j-i的长度从小到大的顺序\n    //求的\n    bool wordBreakMy(string s, unordered_set<string> &dict) {\n        int len = (int) s.size();\n        vector<bool> row(len, false);\n        vector<vector<bool>> dp(len, row);\n        for (int i = 0; i < len; i++) {\n            string tmp = s.substr(i, 1);\n            if (isInSet(tmp, dict)) {\n                dp[i][i] = true;\n            }\n        }\n        \n        for (int l = 2; l <= len; l++) {\n            for (int i = 0; i < len - l + 1; i++) {\n                int j = i + l - 1;\n                bool flag = isInSet(s.substr(i, l), dict);\n                for (int k = i; k < j && !flag; k++) {\n                    flag |= (dp[i][k] && dp[k + 1][j]);\n                }\n                dp[i][j] = flag;\n            }\n        }\n        \n        return dp[0][len - 1];\n    }\n    \n    bool isInSet(const string &str, const unordered_set<string> &dict) {\n        unordered_set<string>::const_iterator got = dict.find(str);\n        if (got == dict.end()) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n};\n```","slug":"2014-09-23-leetcode-word-break","published":1,"updated":"2015-09-30T11:30:35.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck5i003wrwmw5zhoa672"},{"layout":"post","title":"动态规划: Climbing Stairs","date":"2014-09-23T15:01:20.000Z","_content":">You are climbing a stair case. It takes n steps to reach to the top.<br>\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you \nclimb to the top?\n\n``` cpp\n/*\n\t这个题应该是最简单的动态规划题了\n\t设dp[i]为爬i层楼梯的不同走法，则我们可以得到一个递推关系：\n\tdp[i] = dp[i-1] + dp[i-2], dp[0] = 1, dp[1] = 1\n*/\nclass Solution {\npublic:\n\t//第一种方法使用了一个dp数组，算法的空间复杂度为O(N)\n    int climbStairs_1(int n) {\n        vector<int> dp(n + 1, 1);\n\n        for (int i = 2; i <= n; i++) {\n        \tdp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n\n    //第二种方法就使用了两个变量，算法的空间复杂度为O(1)，\n    //在动态规划的问题时，我们经常使用变量和滚动数组来减少空间复杂度，能够将O(n^2)的\n    //空间复杂度降低为O(n)的空间复杂度，将O(n)的空间复杂度降为O(1)\n    int climbStairs_2(int n) {\n    \tint pre = 0, cur = 1;\n    \tfor (int i = 1; i <= n; i++) {\n    \t    int tmp = cur;\n    \t\tcur = cur + pre;\n    \t\tpre = tmp;\n    \t}\n    \treturn cur;\n    }\n};\n```","source":"_posts/2014-09-23-leetcode-climbing-stairs.md","raw":"---\nlayout: post\ntitle:  \"动态规划: Climbing Stairs\"\ndate:   2014-09-23 23:01:20\ncategories: problems\ntags: [动态规划]\n---\n>You are climbing a stair case. It takes n steps to reach to the top.<br>\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you \nclimb to the top?\n\n``` cpp\n/*\n\t这个题应该是最简单的动态规划题了\n\t设dp[i]为爬i层楼梯的不同走法，则我们可以得到一个递推关系：\n\tdp[i] = dp[i-1] + dp[i-2], dp[0] = 1, dp[1] = 1\n*/\nclass Solution {\npublic:\n\t//第一种方法使用了一个dp数组，算法的空间复杂度为O(N)\n    int climbStairs_1(int n) {\n        vector<int> dp(n + 1, 1);\n\n        for (int i = 2; i <= n; i++) {\n        \tdp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n\n    //第二种方法就使用了两个变量，算法的空间复杂度为O(1)，\n    //在动态规划的问题时，我们经常使用变量和滚动数组来减少空间复杂度，能够将O(n^2)的\n    //空间复杂度降低为O(n)的空间复杂度，将O(n)的空间复杂度降为O(1)\n    int climbStairs_2(int n) {\n    \tint pre = 0, cur = 1;\n    \tfor (int i = 1; i <= n; i++) {\n    \t    int tmp = cur;\n    \t\tcur = cur + pre;\n    \t\tpre = tmp;\n    \t}\n    \treturn cur;\n    }\n};\n```","slug":"2014-09-23-leetcode-climbing-stairs","published":1,"updated":"2015-05-04T13:43:33.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck5k003zrwmw6g0q83gy"},{"layout":"post","title":"堆排序(heap sort)","date":"2014-08-29T00:33:20.000Z","_content":"\n###二叉堆\n二叉堆是一个数组，它可以被看成一个近似的完全二叉树。如图一。树上的每个节点都对应数组中的一个元素。除了最底层外，该树是完全充满的，而且是从左向右填充。<br>\n![kmp1](/img/heap-sort-1.png)\n\n二叉堆可以分为两种形式：最大堆和最小堆。在最大堆中，每一个父节点的值都要大于子节点的值；在最小堆中，每一个父节点的值都要小于子节点的值。\n\n堆的主要操作是实现插入元素和删除最大元素（最大堆）。\n\n####由下至上的堆有序化（上浮）\n（最大堆）如果堆的有序状态因为某个节点变得比它的父节点更大而被打破，那么我们就需要通过交换它和它的父节点来修复堆。如果交换后它仍比父节点大，那继续交换直至遇到一个比它大的父节点。<br>\n这种方法主要用在建堆的时候，即插入元素的时候。\n``` java\nprivate void swim(int k) {\n\twhile (k > 1 && less(k/2, k)) {\n\t\texch(k/2, k);\n\t\tk = k/2;\n\t}\n}\n```\n\n####有上至下的堆的有序化(下沉)\n（最大堆）如果堆的有序状态因为某个结点变得比它的两个子结点更小而被打破，那么我们就要不断交换它和它的两个子结点的较大者来修复堆。直至它比它的两个子结点都大。<br>\n这种方法主要用在删除元素后的恢复堆上。\n``` java\nprivate void sink(int k) {\n\twhile (2*k <= N) {\n\t\tint j = 2*k;\n\t\t//找到子结点中较大的结点\n\t\tif (j < N && less(j, j+1)) \n\t\t\tj++;\n\t\t//如果父结点比子结点大，结束\n\t\tif (!less(k, j)) \n\t\t\tbreak;\n\t\texch(k, j);\n\t}\n}\n```\n\n####二叉堆的实现：\n二叉堆有可以做优先级队列，如下是实现：\n``` java\npublic class MaxPQ<Key extends Comparable<Key>> {\n\t//在这里，我们使用长度为N+1的数组来存储N个数，位置从1开始\n\tprivate Key[] pq;\n\tprivate int N = 0;\n\n\tpublic MaxPQ(int maxN) {\n\t\tpq = (Key[]) new Comparable[maxN+1];\n\t}\n\n\tpublic boolean isEmpty() {\n\t\treturn N == 0;\n\t}\n\n\tpublic int size() {\n\t\treturn N;\n\t}\n\n\tpublic void insert(Key v) {\n\t\tpq[++N] = v;\n\t\tswim(N);\n\t}\n\n\tpublic Key delMax() {\n\t\tKey max = pq[1];\n\t\texch(1, N--);\n\t\tpq[N+1] = null;\n\t\tsink(1);\n\t\treturn max;\n\t}\n\n    private boolean less(int i, int j) {\n    \treturn ((Comparable<Key>) pq[i]).compareTo(pq[j]) < 0;\n    }\n\n    private void exch(int i, int j) {\n        Key swap = pq[i];\n        pq[i] = pq[j];\n        pq[j] = swap;\n    }\n\n}\n```\n \n###堆排序\n由于最大堆在上面已经介绍，所以堆排序的思想其实很简单。我们可以根据需要排序的数组构造一个最大堆，然后我们依次将堆的第一个数即最大的数换到堆的最后，然后将堆的大小减一即可。\n\n``` java\npublic static void heapSort(Comparable[] a) {\n\tint N = a.length;\n\t//需要注意的是，在这里我们从N/2开始修复最大堆，因为大于N/2的都是叶子结点\n\t//不需要修复\n\tfor (int k = N/2; k >= 1; k--)\n\t\tsink(a, k, N);\n\n\twhile (N > 1) {\n\t\texch(a, 1, N--);\n\t\tsink(a, 1, N);\n\t}\n}\n```","source":"_posts/2014-08-29-heap-sort.md","raw":"---\nlayout: post\ntitle:  \"堆排序(heap sort)\"\ndate:   2014-08-29 08:33:20\ncategories:   algorithms\n---\n\n###二叉堆\n二叉堆是一个数组，它可以被看成一个近似的完全二叉树。如图一。树上的每个节点都对应数组中的一个元素。除了最底层外，该树是完全充满的，而且是从左向右填充。<br>\n![kmp1](/img/heap-sort-1.png)\n\n二叉堆可以分为两种形式：最大堆和最小堆。在最大堆中，每一个父节点的值都要大于子节点的值；在最小堆中，每一个父节点的值都要小于子节点的值。\n\n堆的主要操作是实现插入元素和删除最大元素（最大堆）。\n\n####由下至上的堆有序化（上浮）\n（最大堆）如果堆的有序状态因为某个节点变得比它的父节点更大而被打破，那么我们就需要通过交换它和它的父节点来修复堆。如果交换后它仍比父节点大，那继续交换直至遇到一个比它大的父节点。<br>\n这种方法主要用在建堆的时候，即插入元素的时候。\n``` java\nprivate void swim(int k) {\n\twhile (k > 1 && less(k/2, k)) {\n\t\texch(k/2, k);\n\t\tk = k/2;\n\t}\n}\n```\n\n####有上至下的堆的有序化(下沉)\n（最大堆）如果堆的有序状态因为某个结点变得比它的两个子结点更小而被打破，那么我们就要不断交换它和它的两个子结点的较大者来修复堆。直至它比它的两个子结点都大。<br>\n这种方法主要用在删除元素后的恢复堆上。\n``` java\nprivate void sink(int k) {\n\twhile (2*k <= N) {\n\t\tint j = 2*k;\n\t\t//找到子结点中较大的结点\n\t\tif (j < N && less(j, j+1)) \n\t\t\tj++;\n\t\t//如果父结点比子结点大，结束\n\t\tif (!less(k, j)) \n\t\t\tbreak;\n\t\texch(k, j);\n\t}\n}\n```\n\n####二叉堆的实现：\n二叉堆有可以做优先级队列，如下是实现：\n``` java\npublic class MaxPQ<Key extends Comparable<Key>> {\n\t//在这里，我们使用长度为N+1的数组来存储N个数，位置从1开始\n\tprivate Key[] pq;\n\tprivate int N = 0;\n\n\tpublic MaxPQ(int maxN) {\n\t\tpq = (Key[]) new Comparable[maxN+1];\n\t}\n\n\tpublic boolean isEmpty() {\n\t\treturn N == 0;\n\t}\n\n\tpublic int size() {\n\t\treturn N;\n\t}\n\n\tpublic void insert(Key v) {\n\t\tpq[++N] = v;\n\t\tswim(N);\n\t}\n\n\tpublic Key delMax() {\n\t\tKey max = pq[1];\n\t\texch(1, N--);\n\t\tpq[N+1] = null;\n\t\tsink(1);\n\t\treturn max;\n\t}\n\n    private boolean less(int i, int j) {\n    \treturn ((Comparable<Key>) pq[i]).compareTo(pq[j]) < 0;\n    }\n\n    private void exch(int i, int j) {\n        Key swap = pq[i];\n        pq[i] = pq[j];\n        pq[j] = swap;\n    }\n\n}\n```\n \n###堆排序\n由于最大堆在上面已经介绍，所以堆排序的思想其实很简单。我们可以根据需要排序的数组构造一个最大堆，然后我们依次将堆的第一个数即最大的数换到堆的最后，然后将堆的大小减一即可。\n\n``` java\npublic static void heapSort(Comparable[] a) {\n\tint N = a.length;\n\t//需要注意的是，在这里我们从N/2开始修复最大堆，因为大于N/2的都是叶子结点\n\t//不需要修复\n\tfor (int k = N/2; k >= 1; k--)\n\t\tsink(a, k, N);\n\n\twhile (N > 1) {\n\t\texch(a, 1, N--);\n\t\tsink(a, 1, N);\n\t}\n}\n```","slug":"2014-08-29-heap-sort","published":1,"updated":"2015-04-30T11:47:55.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck5n0042rwmw9j4i4tb6"},{"layout":"post","title":"基础排序(sorting)","date":"2014-11-19T11:39:20.000Z","_content":"\n###选择排序(selection sort)\n\n选择排序的思想就是每次在数组未排序部分选择最大或者最小的数值，然后将它放在正确的位置上。<br/>\n代码实现如下:\n``` java \npublic static void insertionSort(Comparable[] a) {\n    int N = a.length;\n    for (int i = 0; i < N; i++) {\n        int min = i;\n        for (int j = i + 1; j < N; j++) {\n            if (less(a[j], a[min])) \n                min = j;\n        }\n        exch(a, i, min);\n    }\n}\n\npublic static boolean less(Comparable v, Comparable w) {\n    return v.compareTo(w) < 0;\n}\n\npublic static void exch(Comparable[] a, int i, int j) {\n    Comparble t = a[i];\n    a[i] = a[j];\n    a[j] = t;\n}\n```\n\n###插入排序(insertion sort)\n插入排序的思想是每次让前面部分的数组达到有序：显然，数组第一个数肯定是有序的；我们然后让数组的前两个数、前三个数，一直到所有的数都达到有序。<br>\n代码实现如下：<br>\n``` java\npublic static void insertionSort(Comparable[] a) {\n    int N = a.length;\n    for (int i = 1; i < N; i++) {\n        for (int j = i; j > 0; j--) {\n            if (less(a[j], a[j-1]))\n                exch(a, j, j-1);\n        }\n    }\n}\n```\n###希尔排序（shell sort）\n希尔排序是对插入排序的改进，又称为缩小增量排序。希尔排序的思想就是使数组中任意间隔为`h`的元素都是有序的。这样的数组被称为`h`有序数组。也就是说一个`h`有序数组就是`h`个互相独立的有序数组编织在一起组成的一个数组，如图一。在排序时，如果`h`很大，我们就能将元素移动到很远的地方，为实现更小的`h`有序创造方便。用这种方式，对于任意一`1`结尾的`h`序列，我们都能够将数组排序。下面的算法使用了序列$\\frac{1}{2}(3^k-1)$,从`N/3`开始递减到`1`。在选取这个增量数组的时候，我们要注意避免序列中的值互为倍数的情况。<br>\n![shell](/img/sorting-1.png)\n\n下面是代码实现：\n``` java\npublic static void shellSort(Comparable[] a) {\n    int N = a.length;\n    int h = 1;\n    while (h < N/3) h = 3*h + 1; \n    while (h >= 1) {\n        for (int i = h; i < N; i++) {\n            for (int j = i; j >= h && less(a[j], a[j-h]);j -= h)\n                exch(a, j, j-h);\n        }\n        h = h/3;\n    }\n}\n```\n\n###归并排序（merge sort）\n归并排序是很好的分治法(divide and conquer)解决的问题。它首先递归地将数组分成两半分别排序，然后将结果归并起来。归并排序比前面的集中排序算法好的地方时它的时间和`NlogN`成正比，但是它需要`N`的额外空间。\n\nc++代码如下：\n\n``` cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid merge(vector<int> &A, int start, int mid, int end) {\n    vector<int> aux;\n    for (int k = start; k <= end; k++)\n        aux.push_back(A[k]);\n    \n    int i = 0, j = mid - start + 1;\n    int aux_mid = mid - start, aux_end = end - start;\n    \n    for (int k = start; k <= end; k++) {\n        if (i > aux_mid)\n            A[k] = aux[j++];\n        else if (j > aux_end)\n            A[k] = aux[i++];\n        else if (aux[i] < aux[j])\n            A[k] = aux[i++];\n        else\n            A[k] = aux[j++];\n    }\n}\n\nvoid mergeSort(vector<int> &A, int start, int end) {\n    if (start >= end) return;\n    \n    int mid = start + (end - start)/2;\n    mergeSort(A, start, mid);\n    mergeSort(A, mid + 1, end);\n    merge(A, start, mid, end);\n}\n\nvoid mergeSort(vector<int> &A) {\n    mergeSort(A, 0, (int)A.size() - 1);\n}\n\nint main() {\n    vector<int> test;\n    test.push_back(9);\n    test.push_back(8);\n    test.push_back(7);\n    test.push_back(6);\n    test.push_back(1);\n    test.push_back(4);\n    test.push_back(3);\n    test.push_back(2);\n    mergeSort(test);\n    for (int i = 0; i < test.size(); i++)\n        cout<<test[i]<<endl;\n}\n```\n\njava代码如下:\n\n``` java\npublic class MergeSort {\n\tprivate static Comparable[] aux;\n\n\tpublic static void merge(Comparable[] a, int lo, int mid, int hi) {\n\t\tint i = lo, j = mid + 1;\n\n\t\tfor (int k = lo; k <= hi; k++) \n\t\t\taux[k] = a[k];\n\n\t\tfor (int k = lo; k <= hi; k++) {\n\t\t\tif \t\t(i > mid) \t\t\t\ta[k] = aux[j++];\n\t\t\telse if (j > hi) \t\t\t\ta[k] = aux[i++];\n\t\t\telse if (less(aux[j], aux[i])) \ta[k] = aux[j++];\n\t\t\telse \t\t\t\t\t\t\ta[k] = aux[i++];\n\t\t}\n\t}\n\n\tpublic static void sort(Comparable a) {\n\t\taux = new Comparable[a.length];\n\t\tsort(a, 0, a.length - 1);\n\t}\n\n\tprivate static void sort(Comparable[] a, int lo, int hi) {\n\t\tif (hi <= lo) return;\n\t\tint mid = lo + (hi - lo)/2;\n\t\tsort(a, lo, mid);\n\t\tsort(a, mid + 1, hi);\n\t\tmerge(a, lo, mid, hi);\n\t}\n}\n```\n\n###快速排序(quick sort)\n快速排序也是分治法的一种。它相对于归并排序的优势在与它并不需要辅助数组，即额外的内存空间。它的思想是将数组分成两个子数组，然后递归地对这两个字数组进行排序。<br>\n\nc++代码如下：\n``` cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid swap(int *a, int *b) {\n    int tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n\nint partition(vector<int> &A, int start, int end) {\n    int mid = start - 1;\n    int sentinel = A[end];\n    for (int i = start; i < end; i++) {\n        if (A[i] < sentinel) {\n            swap(&A[i], &A[++mid]);\n        }\n    }\n    swap(&A[++mid], &A[end]);\n    return mid;\n}\n\nvoid quickSort(vector<int> &A, int start, int end) {\n    if (start < end) {\n        int mid = partition(A, start, end);\n        quickSort(A, start, mid - 1);\n        quickSort(A, mid + 1, end);\n    }\n}\n\nvoid quickSort(vector<int> &A) {\n    quickSort(A, 0, (int)A.size() - 1);\n}\n\nint main() {\n    vector<int> test;\n    test.push_back(9);\n    test.push_back(8);\n    test.push_back(7);\n    test.push_back(6);\n    test.push_back(1);\n    test.push_back(4);\n    test.push_back(3);\n    test.push_back(2);\n    quickSort(test);\n    for (int i = 0; i < test.size(); i++)\n        cout<<test[i]<<endl;\n}\n```\n\njava代码如下\n\n``` java\npublic class QuickSort {\n\tpublic static void sort(Comparable[] a) {\n\t\tsort(a, a, 0, a.length - 1);\n\t}\n\n\tprivate static int partition(Comparable[] a, int lo, int hi) {\n\t\tint i = lo, j = hi+1;\n\t\tComparable v = a[lo];\n\t\twhile(true) {\n\t\t\twhile (less(a[++i], v)) if (i == hi) break; //找到左边第一个比v大的值\n\t\t\twhile (less(v, a[--j])) if (j == lo) break;\t//找到右边第一个比v小的值\n\t\t\tif (i >= j) break;\n\t\t\texch(a, i, j);\t//交换两个值\n\t\t}\n\t\texch(a, i, j);\n\t\treturn j;\n\t}\n\n\tprivate static void sort(Comparable[] a, int lo, int hi) {\n\t\tif (hi <= lo) return;\n\t\tint j = partition(a, lo, hi);\n\t\tsort(a, lo, j-1);\n\t\tsort(a, j+1, hi);\n\t}\n}\n```\n###基数排序\n\n基数排序是线性时间排序的一种，它跟以上的那些比较排序算法不同的是它使线性时间的，而且它是一种稳定排序。\n\n以采用LSD(Least significant digital)排序方式的基数排序为例，我们就是先根据低位的数值对数组进行排序，达到低位有序，然后依次排序到最高位。\n\n其实根据某一位对数组排序时用的方法用的就是计数排序，我们一轮遍历下来就可以知道每一个元素的正确位置。但是在这里需要注意的是不要把顺序弄乱，就是同一位同一数值的两个数不能够交换，因为基数排序是一种稳定排序。\n\nLSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。MSD的方式与LSD相反，是由高位数为基底开始进行分配，但在分配之后并不马上合并回一个数组中，而是在每个“桶子”中建立“子桶”，将每个桶子中的数值按照下一数位的值分配到“子桶”中。在进行完最低位数的分配后再合并回单一的数组中。\n\nLSD方式的基数排序的c++实现：\n\n``` cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint getRadix(int a, int pos) {\n    int remain = 0;\n    for(int i = 1; i <= pos; i++) {\n        if (a < 1) {\n            remain = 0;\n            break;\n        }\n        \n        remain = a % 10;\n        a = a / 10;\n    }\n    return remain;\n}\n\nvoid radixSort(vector<int> &A) {\n    int count[11];\n    \n    for (int pos = 1;;pos++) {\n        //在计算某一位的数值的个数之前，先将计数数组清零\n        //然后计算某一位的数值的个数，位数不足的补零\n        fill(count, count + 10, 0);\n        for (int i = 0; i < A.size(); i++) {\n            int radix = getRadix(A[i], pos);\n            count[radix + 1]++;\n        }\n        \n        //如果数组全部都补零了，说明已经排好序了，退出循环\n        if (count[1] == A.size())\n            break;\n\n        //计算某一位上每个数值的初始位置\n        for (int i = 1; i < 10; i++) {\n            count[i] += count[i - 1];\n        }\n        //将数组拷贝到辅助数组的正确位置\n        //由于计数排序是稳定排序，所以需要注意\n        vector<int> aux(A.size(), 0);\n        for (int i = 0; i < A.size(); i++) {\n            int radix = getRadix(A[i], pos);\n            aux[count[radix]++] = A[i];\n        }\n        //再拷贝回来\n        for (int i = 0; i < A.size(); i++) {\n            A[i] = aux[i];\n        }\n    }\n}\n\nint main() {\n    cout<<getRadix(123,4)<<endl;\n    \n    vector<int> test;\n    test.push_back(342);\n    test.push_back(58);\n    test.push_back(576);\n    test.push_back(356);\n\n    radixSort(test);\n    for (int i = 0; i < test.size(); i++)\n        cout<<test[i]<<endl;\n}\n```","source":"_posts/2014-08-28-sorting.md","raw":"---\nlayout: post\ntitle:  \"基础排序(sorting)\"\ndate:   2014-11-19 19:39:20\ncategories:   algorithms\n---\n\n###选择排序(selection sort)\n\n选择排序的思想就是每次在数组未排序部分选择最大或者最小的数值，然后将它放在正确的位置上。<br/>\n代码实现如下:\n``` java \npublic static void insertionSort(Comparable[] a) {\n    int N = a.length;\n    for (int i = 0; i < N; i++) {\n        int min = i;\n        for (int j = i + 1; j < N; j++) {\n            if (less(a[j], a[min])) \n                min = j;\n        }\n        exch(a, i, min);\n    }\n}\n\npublic static boolean less(Comparable v, Comparable w) {\n    return v.compareTo(w) < 0;\n}\n\npublic static void exch(Comparable[] a, int i, int j) {\n    Comparble t = a[i];\n    a[i] = a[j];\n    a[j] = t;\n}\n```\n\n###插入排序(insertion sort)\n插入排序的思想是每次让前面部分的数组达到有序：显然，数组第一个数肯定是有序的；我们然后让数组的前两个数、前三个数，一直到所有的数都达到有序。<br>\n代码实现如下：<br>\n``` java\npublic static void insertionSort(Comparable[] a) {\n    int N = a.length;\n    for (int i = 1; i < N; i++) {\n        for (int j = i; j > 0; j--) {\n            if (less(a[j], a[j-1]))\n                exch(a, j, j-1);\n        }\n    }\n}\n```\n###希尔排序（shell sort）\n希尔排序是对插入排序的改进，又称为缩小增量排序。希尔排序的思想就是使数组中任意间隔为`h`的元素都是有序的。这样的数组被称为`h`有序数组。也就是说一个`h`有序数组就是`h`个互相独立的有序数组编织在一起组成的一个数组，如图一。在排序时，如果`h`很大，我们就能将元素移动到很远的地方，为实现更小的`h`有序创造方便。用这种方式，对于任意一`1`结尾的`h`序列，我们都能够将数组排序。下面的算法使用了序列$\\frac{1}{2}(3^k-1)$,从`N/3`开始递减到`1`。在选取这个增量数组的时候，我们要注意避免序列中的值互为倍数的情况。<br>\n![shell](/img/sorting-1.png)\n\n下面是代码实现：\n``` java\npublic static void shellSort(Comparable[] a) {\n    int N = a.length;\n    int h = 1;\n    while (h < N/3) h = 3*h + 1; \n    while (h >= 1) {\n        for (int i = h; i < N; i++) {\n            for (int j = i; j >= h && less(a[j], a[j-h]);j -= h)\n                exch(a, j, j-h);\n        }\n        h = h/3;\n    }\n}\n```\n\n###归并排序（merge sort）\n归并排序是很好的分治法(divide and conquer)解决的问题。它首先递归地将数组分成两半分别排序，然后将结果归并起来。归并排序比前面的集中排序算法好的地方时它的时间和`NlogN`成正比，但是它需要`N`的额外空间。\n\nc++代码如下：\n\n``` cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid merge(vector<int> &A, int start, int mid, int end) {\n    vector<int> aux;\n    for (int k = start; k <= end; k++)\n        aux.push_back(A[k]);\n    \n    int i = 0, j = mid - start + 1;\n    int aux_mid = mid - start, aux_end = end - start;\n    \n    for (int k = start; k <= end; k++) {\n        if (i > aux_mid)\n            A[k] = aux[j++];\n        else if (j > aux_end)\n            A[k] = aux[i++];\n        else if (aux[i] < aux[j])\n            A[k] = aux[i++];\n        else\n            A[k] = aux[j++];\n    }\n}\n\nvoid mergeSort(vector<int> &A, int start, int end) {\n    if (start >= end) return;\n    \n    int mid = start + (end - start)/2;\n    mergeSort(A, start, mid);\n    mergeSort(A, mid + 1, end);\n    merge(A, start, mid, end);\n}\n\nvoid mergeSort(vector<int> &A) {\n    mergeSort(A, 0, (int)A.size() - 1);\n}\n\nint main() {\n    vector<int> test;\n    test.push_back(9);\n    test.push_back(8);\n    test.push_back(7);\n    test.push_back(6);\n    test.push_back(1);\n    test.push_back(4);\n    test.push_back(3);\n    test.push_back(2);\n    mergeSort(test);\n    for (int i = 0; i < test.size(); i++)\n        cout<<test[i]<<endl;\n}\n```\n\njava代码如下:\n\n``` java\npublic class MergeSort {\n\tprivate static Comparable[] aux;\n\n\tpublic static void merge(Comparable[] a, int lo, int mid, int hi) {\n\t\tint i = lo, j = mid + 1;\n\n\t\tfor (int k = lo; k <= hi; k++) \n\t\t\taux[k] = a[k];\n\n\t\tfor (int k = lo; k <= hi; k++) {\n\t\t\tif \t\t(i > mid) \t\t\t\ta[k] = aux[j++];\n\t\t\telse if (j > hi) \t\t\t\ta[k] = aux[i++];\n\t\t\telse if (less(aux[j], aux[i])) \ta[k] = aux[j++];\n\t\t\telse \t\t\t\t\t\t\ta[k] = aux[i++];\n\t\t}\n\t}\n\n\tpublic static void sort(Comparable a) {\n\t\taux = new Comparable[a.length];\n\t\tsort(a, 0, a.length - 1);\n\t}\n\n\tprivate static void sort(Comparable[] a, int lo, int hi) {\n\t\tif (hi <= lo) return;\n\t\tint mid = lo + (hi - lo)/2;\n\t\tsort(a, lo, mid);\n\t\tsort(a, mid + 1, hi);\n\t\tmerge(a, lo, mid, hi);\n\t}\n}\n```\n\n###快速排序(quick sort)\n快速排序也是分治法的一种。它相对于归并排序的优势在与它并不需要辅助数组，即额外的内存空间。它的思想是将数组分成两个子数组，然后递归地对这两个字数组进行排序。<br>\n\nc++代码如下：\n``` cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid swap(int *a, int *b) {\n    int tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n\nint partition(vector<int> &A, int start, int end) {\n    int mid = start - 1;\n    int sentinel = A[end];\n    for (int i = start; i < end; i++) {\n        if (A[i] < sentinel) {\n            swap(&A[i], &A[++mid]);\n        }\n    }\n    swap(&A[++mid], &A[end]);\n    return mid;\n}\n\nvoid quickSort(vector<int> &A, int start, int end) {\n    if (start < end) {\n        int mid = partition(A, start, end);\n        quickSort(A, start, mid - 1);\n        quickSort(A, mid + 1, end);\n    }\n}\n\nvoid quickSort(vector<int> &A) {\n    quickSort(A, 0, (int)A.size() - 1);\n}\n\nint main() {\n    vector<int> test;\n    test.push_back(9);\n    test.push_back(8);\n    test.push_back(7);\n    test.push_back(6);\n    test.push_back(1);\n    test.push_back(4);\n    test.push_back(3);\n    test.push_back(2);\n    quickSort(test);\n    for (int i = 0; i < test.size(); i++)\n        cout<<test[i]<<endl;\n}\n```\n\njava代码如下\n\n``` java\npublic class QuickSort {\n\tpublic static void sort(Comparable[] a) {\n\t\tsort(a, a, 0, a.length - 1);\n\t}\n\n\tprivate static int partition(Comparable[] a, int lo, int hi) {\n\t\tint i = lo, j = hi+1;\n\t\tComparable v = a[lo];\n\t\twhile(true) {\n\t\t\twhile (less(a[++i], v)) if (i == hi) break; //找到左边第一个比v大的值\n\t\t\twhile (less(v, a[--j])) if (j == lo) break;\t//找到右边第一个比v小的值\n\t\t\tif (i >= j) break;\n\t\t\texch(a, i, j);\t//交换两个值\n\t\t}\n\t\texch(a, i, j);\n\t\treturn j;\n\t}\n\n\tprivate static void sort(Comparable[] a, int lo, int hi) {\n\t\tif (hi <= lo) return;\n\t\tint j = partition(a, lo, hi);\n\t\tsort(a, lo, j-1);\n\t\tsort(a, j+1, hi);\n\t}\n}\n```\n###基数排序\n\n基数排序是线性时间排序的一种，它跟以上的那些比较排序算法不同的是它使线性时间的，而且它是一种稳定排序。\n\n以采用LSD(Least significant digital)排序方式的基数排序为例，我们就是先根据低位的数值对数组进行排序，达到低位有序，然后依次排序到最高位。\n\n其实根据某一位对数组排序时用的方法用的就是计数排序，我们一轮遍历下来就可以知道每一个元素的正确位置。但是在这里需要注意的是不要把顺序弄乱，就是同一位同一数值的两个数不能够交换，因为基数排序是一种稳定排序。\n\nLSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。MSD的方式与LSD相反，是由高位数为基底开始进行分配，但在分配之后并不马上合并回一个数组中，而是在每个“桶子”中建立“子桶”，将每个桶子中的数值按照下一数位的值分配到“子桶”中。在进行完最低位数的分配后再合并回单一的数组中。\n\nLSD方式的基数排序的c++实现：\n\n``` cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint getRadix(int a, int pos) {\n    int remain = 0;\n    for(int i = 1; i <= pos; i++) {\n        if (a < 1) {\n            remain = 0;\n            break;\n        }\n        \n        remain = a % 10;\n        a = a / 10;\n    }\n    return remain;\n}\n\nvoid radixSort(vector<int> &A) {\n    int count[11];\n    \n    for (int pos = 1;;pos++) {\n        //在计算某一位的数值的个数之前，先将计数数组清零\n        //然后计算某一位的数值的个数，位数不足的补零\n        fill(count, count + 10, 0);\n        for (int i = 0; i < A.size(); i++) {\n            int radix = getRadix(A[i], pos);\n            count[radix + 1]++;\n        }\n        \n        //如果数组全部都补零了，说明已经排好序了，退出循环\n        if (count[1] == A.size())\n            break;\n\n        //计算某一位上每个数值的初始位置\n        for (int i = 1; i < 10; i++) {\n            count[i] += count[i - 1];\n        }\n        //将数组拷贝到辅助数组的正确位置\n        //由于计数排序是稳定排序，所以需要注意\n        vector<int> aux(A.size(), 0);\n        for (int i = 0; i < A.size(); i++) {\n            int radix = getRadix(A[i], pos);\n            aux[count[radix]++] = A[i];\n        }\n        //再拷贝回来\n        for (int i = 0; i < A.size(); i++) {\n            A[i] = aux[i];\n        }\n    }\n}\n\nint main() {\n    cout<<getRadix(123,4)<<endl;\n    \n    vector<int> test;\n    test.push_back(342);\n    test.push_back(58);\n    test.push_back(576);\n    test.push_back(356);\n\n    radixSort(test);\n    for (int i = 0; i < test.size(); i++)\n        cout<<test[i]<<endl;\n}\n```","slug":"2014-08-28-sorting","published":1,"updated":"2015-09-30T11:31:34.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck5o0044rwmwbmvmxc9m"},{"layout":"post","title":"图:无向图(undirected graph)","date":"2014-08-12T01:20:20.000Z","_content":"\n###1.无向图的数据结构\n我们一般有两种方式来表示图：<br>\n\n- 邻接矩阵：我们用一个V*V的布尔矩阵来表示一个无向图。当顶点v和顶点w之间有相连接的边时，定义v行w列的元素值为true，否则为false。这种表示方法最简单，但当图的顶点太多，且为一个稀疏矩阵时，空间就有点浪费了。\n- 邻接表数组：我们可以使用一个以顶点为索引的列表数组，其中每个元素都是和该顶点相邻接的顶点列表。如图一。一般我们会使用这种表示方法。\n\n如下是java实现（Bag为一种链表实现的数据结构，类似Stack和Queue,但是对数据的先后顺序不关心，见后面的基础数据结构的博客）：\n``` java\npublic class Graph {\n\tprivate final int V;\t\t//number of vertices\n\tprivate int E;\t\t\t\t//number of edges\n\tprivate Bag<Integer>[] adj;\t//adjacency list\n\n\tpublic Graph(int V) {\n\t\tthis.V = V;\n\t\tthis.E = 0;\n\t\tadj = (Bag<Integer>[]) new Bag[V];\n\t\tfor (int v = 0; v < V; v++) \n\t\t\tadj[v] = new Bag<Integer>();\n\t}\n\n\tpublic int V() {\n\t\treturn V;\n\t}\n\n\tpublic int E() {\n\t\treturn E;\n\t}\n\n\tpublic void addEdge(int v, int w) {\n\t\tadj[v].add(w);\n\t\tadj[w].add(v);\n\t\tE++;\n\t}\n\n\tpublic Iterable<Integer> adj(int v) {\n\t\treturn ajd[v];\n\t}\n}\n```\n\n###2.深度优先搜索\n深度优先搜索总是对最近发现的结点v的出发边进行探索，知道该结点的所有出发边都被发现为止。一旦结点v的所有出发边都被发现，搜索则回溯到v的前驱结点，来搜索该前驱结点的出发边。思路其实就是使用栈的先入后出的思想，但是没有显示的使用栈，而是利用了递归。\n``` java\npublic class DepthFirstSearch {\n\tprivate boolean[] marked;\n\tprivate int count;\n\n\tpublic DepthFirstSearch(Graph G, int s) {\n\t\tmarked = new boolean[G.V()];\n\t\tdfs(G, s);\n\t}\n\n\tprivate void dfs(Graph G, int v) {\n\t\tmarked[v] = true;\n\t\tcount++;\n\t\tfor (int w : G.ajd[v]) {\n\t\t\tif (!marked[w]) {\n\t\t\t\tdfs(G, w);\n\t\t\t}\n\t\t} \n\t}\n\n\tpublic boolean marked(int w) {\n\t\treturn marked[w];\n\t}\n\n\tpublic int count() {\n\t\treturn count;\n\t}\n}\n```\n###3.广度优先搜索\n广度优先搜索时将已经发现节点和未发现节点之间的边界，沿其广度方向向外扩展。也就是说，算法需要在发现所有距离源结点s为k的所有结点之后，才会发现距离源结点s为k+1的其他结点。<br>\n广度优先搜索算法使用一个队列来保存所有已经被标记过的但其邻接表还没被检查过的顶点。先将起点加入队列，然后重复以下步骤知道队列为空：\n\n- 取队列中的下一个顶点v并标记它；\n- 将与v相邻的所有未被标记过的顶点加入队列。\n\n与深度优先搜索不同的是，广度优先搜索显示使用了一个队列来记录被访问过的结点。java实现如下（Queue为队列，与Bag一样，见Algorithms 4th edition）：<br>\n``` java\npublic BreadFirstSearch {\n\tprivate boolean[] marked;\n\tprivate int count;\n\tpublic BreadFirstSearch(Graph G, int s) {\n\t\tthis.marked = new boolean[G.V()];\n\t\tbfs(G, s);\n\t}\n\n\tprivate void bfs(Graph G, int s) {\n\t\tQueue<Integer> queue = new Queue<Integer>();\n\t\tmarked[s] = true;\n\t\tcount++;\n\t\tqueue.enqueue(s);\n\t\twhile (!q.isEmpty()) {\n\t\t\tint v = queue.dequeue();\n\t\t\tfor (int w : G.ajd[v]) {\n\t\t\t\tif (!marked[w]) {\n\t\t\t\t\tcount++;\n\t \t\t\t\tmarked[w] = true;\n\t\t\t\t\tqueue.enque(w);\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean marked(int w) {\n\t\treturn marked[w];\n\t}\n\n\tpublic int count() {\n\t\treturn count;\n\t}\n}\n```\n\n###4.广度优先搜索与迷宫问题\n与图的搜索相关的另一个问题是路径问题。其中在无权图中最典型的应该是迷宫问题，就是找出走出迷宫的最短路径。其实这就是一个简单的单源点最短路径问题，在无权图中，我们可以使用广度优先搜索来实现，只要加一点代码就可以实现。\n\n``` java\npublic BreadFirstPaths {\n\tprivate boolean[] marked;\n\tprivate int[] edgeTo;\n\tprivate final s;\n\tpublic BreadFirstSearch(Graph G, int s) {\n\t\tthis.marked = new boolean[G.V()];\n\t\tthis.edgeTo = new int[G.V()];\n\t\tthis.s = s;\n\t\tbfs(G, s);\n\t}\n\n\tprivate void bfs(Graph G, int s) {\n\t\tQueue<Integer> queue = new Queue<Integer>();\n\t\tmarked[s] = true;\n\t\tqueue.enqueue(s);\n\t\twhile (!q.isEmpty()) {\n\t\t\tint v = queue.dequeue();\n\t\t\tfor (int w : G.ajd[v]) {\n\t\t\t\tif (!marked[w]) {\n\t\t\t\t\tedgeTo[w] = v;\n\t \t\t\t\tmarked[w] = true;\n\t\t\t\t\tqueue.enque(w);\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpulic boolean hasPathTo(int v) {\n\t\treturn marked[v];\n\t}\n\n\tpublic Iterable<Integer> pathTo(int v) {\n\t\tif(!hasPathTo(v)) return null;\n\n\t\tStack<Integer> path = new Stack<Integer>();\n\t\tfor (int x = v; x != s; x = edgeTo[x])\n\t\t\tpath.push(x);\n\t\tpath.push(this.s);\n\t\treturn path;\n\t}\n}\n```","source":"_posts/2014-08-12-undirected-graph.md","raw":"---\nlayout: post\ntitle:  \"图:无向图(undirected graph)\"\ndate:   2014-08-12 09:20:20\ncategories:   algorithms\n---\n\n###1.无向图的数据结构\n我们一般有两种方式来表示图：<br>\n\n- 邻接矩阵：我们用一个V*V的布尔矩阵来表示一个无向图。当顶点v和顶点w之间有相连接的边时，定义v行w列的元素值为true，否则为false。这种表示方法最简单，但当图的顶点太多，且为一个稀疏矩阵时，空间就有点浪费了。\n- 邻接表数组：我们可以使用一个以顶点为索引的列表数组，其中每个元素都是和该顶点相邻接的顶点列表。如图一。一般我们会使用这种表示方法。\n\n如下是java实现（Bag为一种链表实现的数据结构，类似Stack和Queue,但是对数据的先后顺序不关心，见后面的基础数据结构的博客）：\n``` java\npublic class Graph {\n\tprivate final int V;\t\t//number of vertices\n\tprivate int E;\t\t\t\t//number of edges\n\tprivate Bag<Integer>[] adj;\t//adjacency list\n\n\tpublic Graph(int V) {\n\t\tthis.V = V;\n\t\tthis.E = 0;\n\t\tadj = (Bag<Integer>[]) new Bag[V];\n\t\tfor (int v = 0; v < V; v++) \n\t\t\tadj[v] = new Bag<Integer>();\n\t}\n\n\tpublic int V() {\n\t\treturn V;\n\t}\n\n\tpublic int E() {\n\t\treturn E;\n\t}\n\n\tpublic void addEdge(int v, int w) {\n\t\tadj[v].add(w);\n\t\tadj[w].add(v);\n\t\tE++;\n\t}\n\n\tpublic Iterable<Integer> adj(int v) {\n\t\treturn ajd[v];\n\t}\n}\n```\n\n###2.深度优先搜索\n深度优先搜索总是对最近发现的结点v的出发边进行探索，知道该结点的所有出发边都被发现为止。一旦结点v的所有出发边都被发现，搜索则回溯到v的前驱结点，来搜索该前驱结点的出发边。思路其实就是使用栈的先入后出的思想，但是没有显示的使用栈，而是利用了递归。\n``` java\npublic class DepthFirstSearch {\n\tprivate boolean[] marked;\n\tprivate int count;\n\n\tpublic DepthFirstSearch(Graph G, int s) {\n\t\tmarked = new boolean[G.V()];\n\t\tdfs(G, s);\n\t}\n\n\tprivate void dfs(Graph G, int v) {\n\t\tmarked[v] = true;\n\t\tcount++;\n\t\tfor (int w : G.ajd[v]) {\n\t\t\tif (!marked[w]) {\n\t\t\t\tdfs(G, w);\n\t\t\t}\n\t\t} \n\t}\n\n\tpublic boolean marked(int w) {\n\t\treturn marked[w];\n\t}\n\n\tpublic int count() {\n\t\treturn count;\n\t}\n}\n```\n###3.广度优先搜索\n广度优先搜索时将已经发现节点和未发现节点之间的边界，沿其广度方向向外扩展。也就是说，算法需要在发现所有距离源结点s为k的所有结点之后，才会发现距离源结点s为k+1的其他结点。<br>\n广度优先搜索算法使用一个队列来保存所有已经被标记过的但其邻接表还没被检查过的顶点。先将起点加入队列，然后重复以下步骤知道队列为空：\n\n- 取队列中的下一个顶点v并标记它；\n- 将与v相邻的所有未被标记过的顶点加入队列。\n\n与深度优先搜索不同的是，广度优先搜索显示使用了一个队列来记录被访问过的结点。java实现如下（Queue为队列，与Bag一样，见Algorithms 4th edition）：<br>\n``` java\npublic BreadFirstSearch {\n\tprivate boolean[] marked;\n\tprivate int count;\n\tpublic BreadFirstSearch(Graph G, int s) {\n\t\tthis.marked = new boolean[G.V()];\n\t\tbfs(G, s);\n\t}\n\n\tprivate void bfs(Graph G, int s) {\n\t\tQueue<Integer> queue = new Queue<Integer>();\n\t\tmarked[s] = true;\n\t\tcount++;\n\t\tqueue.enqueue(s);\n\t\twhile (!q.isEmpty()) {\n\t\t\tint v = queue.dequeue();\n\t\t\tfor (int w : G.ajd[v]) {\n\t\t\t\tif (!marked[w]) {\n\t\t\t\t\tcount++;\n\t \t\t\t\tmarked[w] = true;\n\t\t\t\t\tqueue.enque(w);\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean marked(int w) {\n\t\treturn marked[w];\n\t}\n\n\tpublic int count() {\n\t\treturn count;\n\t}\n}\n```\n\n###4.广度优先搜索与迷宫问题\n与图的搜索相关的另一个问题是路径问题。其中在无权图中最典型的应该是迷宫问题，就是找出走出迷宫的最短路径。其实这就是一个简单的单源点最短路径问题，在无权图中，我们可以使用广度优先搜索来实现，只要加一点代码就可以实现。\n\n``` java\npublic BreadFirstPaths {\n\tprivate boolean[] marked;\n\tprivate int[] edgeTo;\n\tprivate final s;\n\tpublic BreadFirstSearch(Graph G, int s) {\n\t\tthis.marked = new boolean[G.V()];\n\t\tthis.edgeTo = new int[G.V()];\n\t\tthis.s = s;\n\t\tbfs(G, s);\n\t}\n\n\tprivate void bfs(Graph G, int s) {\n\t\tQueue<Integer> queue = new Queue<Integer>();\n\t\tmarked[s] = true;\n\t\tqueue.enqueue(s);\n\t\twhile (!q.isEmpty()) {\n\t\t\tint v = queue.dequeue();\n\t\t\tfor (int w : G.ajd[v]) {\n\t\t\t\tif (!marked[w]) {\n\t\t\t\t\tedgeTo[w] = v;\n\t \t\t\t\tmarked[w] = true;\n\t\t\t\t\tqueue.enque(w);\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpulic boolean hasPathTo(int v) {\n\t\treturn marked[v];\n\t}\n\n\tpublic Iterable<Integer> pathTo(int v) {\n\t\tif(!hasPathTo(v)) return null;\n\n\t\tStack<Integer> path = new Stack<Integer>();\n\t\tfor (int x = v; x != s; x = edgeTo[x])\n\t\t\tpath.push(x);\n\t\tpath.push(this.s);\n\t\treturn path;\n\t}\n}\n```","slug":"2014-08-12-undirected-graph","published":1,"updated":"2015-04-30T11:20:53.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck5p0046rwmwbmo319mm"},{"layout":"post","title":"单词查找树(Tries)","date":"2014-08-11T01:03:20.000Z","_content":"\n###单词查找树\n单词查找树是由字符串键中的所有字符构造而成，允许使用被查找键中的字符进行查找。比如说有一个字典，我们想要查询一个单词的释义，我们就可以根据单词生成一个单词查找树，然后将释义保存在值中。由于单词查找树的查找时间为单词字符串的长度，所以查找效率有时比排序的算法还要高。\n\n图一所示的是一棵单词查找树。Tries是由链接的节点所组成的数据结构，这些链接可能为空，也可能指向其他节点。但是每个节点都只可能有一个指向它的节点，称为它的父节点。每个节点都有R个链接，其中R为字母表的大小。（因为Tries一般都含有大量的空链接，所以图中就把空链接忽略掉了）。有一点需要注意，图中虽然每个节点都有一个字符，但是每一个节点并没有显示存储字符，而是根据链接是否为空来间接表示。每个节点除了存储R个链接之外，还存有一个相应的值，可以是空也可以是符号表中的某个键所关联的值。我们将每个键所关联的值都存储在该键的最后一个字母所对应的节点中。\n\n![trie1](/img/trie-1.png)\n\n####节点的表示\n如图二所示，Tries有如下两个重要的性质：\n\n1. 每个节点都含有R个链接，对应着每个有可能出现的字符；\n2. 字符和键均隐式地保存在数据结构中。\n\n![trie2](/img/trie-3.png)\n\n####查找\n在单词查找树中查找是可能会出现三种情况:\n1.键的尾字符所对应的节点中的值非空。如图三中`shells`的查找。这是一次命中的查找--键所对应的值就是键的尾字符所对应的节点中所保存的值。<br/>\n2.键的尾字符所对应的节点中的值为空。如图三中`shell`的查找。这是一次失败的查找--符号表中不存在该键。<br>\n3.查找结束于一条空链接。这也是一次失败的查找。\n\n![trie3](/img/trie-2.png)\n\n####插入\n和二叉查找树一样，在插入之前进行一次查找。此时可能会出现两种情况。<br>\n1.在到达键的尾字符之前就遇到一个空链接。在这种情况下，就需要为建中还未被检查的每个字符创建一个节点并将键的值保存在最后一个字符的节点中。<br>\n2.在遇到空链接之前就到达了尾字符。在这种情况下，就将该节点的值设为键所对应的值。\n\n下面给出TrieST的java实现：\n\n```java \npublic class TrieST<Value> {\nprivate static int R = 256;\nprivate Node root;\n\nprivate static class Node {\n\tprivate Object val;\n\tprivate Node[] next = new Node[R];\n}\n\npublic Value get(String key) {\n\tNode x = get(root, key, 0);\n\tif (x == null) return null;\n\treturn (Value) x.val;\n}\n\nprivate Node get(Node x, String key, int d) {\n\tif (x == null) return null;\n\tif (d == key.length) return x;\n\n\tchar c = key.charAt(d);\n\treturn get(x.next[c], key, d + 1);\n}\n\n\npublic void put(String key, Value val) {\n\troot = put(root, key, val, 0);\n}\n\nprivate Node put(Node x, String key, Value val, int d) {\n\tif (x == null) x = new Node();\n\tif (d == key.length) {\n\t\tx.val = val;\n\t\treturn x;\n\t}\n\n\tchar c = key.charAt(d);\n\tx.next[c] = put(x.next[c], key, val, d + 1);\n\treturn x;\n}\n}\n```\n\n###三向单词查找树（Ternary search tries TSTs）\n为了避免R向单词查找树过度的空间消耗， 还有另一种数据的表示方法：三向单词查找树（TST）。在三向单词查找树中，每个节点都含有一个字符、三条链接和一个值。这三条链接分别对应着当前字母小于、等于和大于节点字母的所有键。\n\n####节点表示\n图四表示了R向单词查找树到三向单词查找树的转化。和R向单词查找树不一样的是，字符和键都是显示的存储在节点中的。\n\n![trie3](/img/trie-4.png)\n\n下面是TST的java实现：\n``` java\npublic class TST<Value> {\n\tprivate Node root;\n\n\tprivate class Node {\n\t\tchar c;\n\t\tNode left, mid, right;\n\t\tValue val;\n\t}\n\n\tpublic Value get(String key) {\n\t\tNode x = get(root, key, 0);\n\t\tif (x == null) return null;\n\t\treturn (Value) x.val;\n\t}\n\n\tprivate Node get(Node x, String key, int d) {\n\t\tif (x == null) return null;\n\t\tchar c = key.charAt(d);\n\n\t\tif (c < x.c) {\n\t\t\treturn get(x.left, key, d);\n\t\t} else if (c > x.c) {\n\t\t\treturn get(x.right, key, d);\n\t\t} else if (d < key.length - 1) {\n\t\t\treturn get(x.mid, key, d+1);\n\t\t} else {\n\t\t\treturn x;\n\t\t}\n\t}\n\n\tpublic void put(String key, Value val) {\n\t\troot = put(root, key, val, 0);\n\t}\n\n\tprivate Node put(Node x, String key, Value val, int d) {\n\t\tchar c = key.charAt(d);\n\t\tif (x == null) {\n\t\t\tx = new Node();\n\t\t\tx.c = c;\n\t\t}\n\n\t\tif (c < x.c) {\n\t\t\tx.left = put(x.left, key, val, d);\n\t\t} else if (c > x.c) {\n\t\t\tx.right = put(x.right, key, val, d);\n\t\t} else if (d < key.length()  - 1) {\n\t\t\tx.mid = put(x.mid, key, val, d+1);\n\t\t} else {\n\t\t\tx.val = val;\n\t\t}\n\n\t\treturn x;\n\t}\n}\n```","source":"_posts/2014-08-11-trie.md","raw":"---\nlayout: post\ntitle:  \"单词查找树(Tries)\"\ndate:   2014-08-11 09:03:20\ncategories:   algorithms\n---\n\n###单词查找树\n单词查找树是由字符串键中的所有字符构造而成，允许使用被查找键中的字符进行查找。比如说有一个字典，我们想要查询一个单词的释义，我们就可以根据单词生成一个单词查找树，然后将释义保存在值中。由于单词查找树的查找时间为单词字符串的长度，所以查找效率有时比排序的算法还要高。\n\n图一所示的是一棵单词查找树。Tries是由链接的节点所组成的数据结构，这些链接可能为空，也可能指向其他节点。但是每个节点都只可能有一个指向它的节点，称为它的父节点。每个节点都有R个链接，其中R为字母表的大小。（因为Tries一般都含有大量的空链接，所以图中就把空链接忽略掉了）。有一点需要注意，图中虽然每个节点都有一个字符，但是每一个节点并没有显示存储字符，而是根据链接是否为空来间接表示。每个节点除了存储R个链接之外，还存有一个相应的值，可以是空也可以是符号表中的某个键所关联的值。我们将每个键所关联的值都存储在该键的最后一个字母所对应的节点中。\n\n![trie1](/img/trie-1.png)\n\n####节点的表示\n如图二所示，Tries有如下两个重要的性质：\n\n1. 每个节点都含有R个链接，对应着每个有可能出现的字符；\n2. 字符和键均隐式地保存在数据结构中。\n\n![trie2](/img/trie-3.png)\n\n####查找\n在单词查找树中查找是可能会出现三种情况:\n1.键的尾字符所对应的节点中的值非空。如图三中`shells`的查找。这是一次命中的查找--键所对应的值就是键的尾字符所对应的节点中所保存的值。<br/>\n2.键的尾字符所对应的节点中的值为空。如图三中`shell`的查找。这是一次失败的查找--符号表中不存在该键。<br>\n3.查找结束于一条空链接。这也是一次失败的查找。\n\n![trie3](/img/trie-2.png)\n\n####插入\n和二叉查找树一样，在插入之前进行一次查找。此时可能会出现两种情况。<br>\n1.在到达键的尾字符之前就遇到一个空链接。在这种情况下，就需要为建中还未被检查的每个字符创建一个节点并将键的值保存在最后一个字符的节点中。<br>\n2.在遇到空链接之前就到达了尾字符。在这种情况下，就将该节点的值设为键所对应的值。\n\n下面给出TrieST的java实现：\n\n```java \npublic class TrieST<Value> {\nprivate static int R = 256;\nprivate Node root;\n\nprivate static class Node {\n\tprivate Object val;\n\tprivate Node[] next = new Node[R];\n}\n\npublic Value get(String key) {\n\tNode x = get(root, key, 0);\n\tif (x == null) return null;\n\treturn (Value) x.val;\n}\n\nprivate Node get(Node x, String key, int d) {\n\tif (x == null) return null;\n\tif (d == key.length) return x;\n\n\tchar c = key.charAt(d);\n\treturn get(x.next[c], key, d + 1);\n}\n\n\npublic void put(String key, Value val) {\n\troot = put(root, key, val, 0);\n}\n\nprivate Node put(Node x, String key, Value val, int d) {\n\tif (x == null) x = new Node();\n\tif (d == key.length) {\n\t\tx.val = val;\n\t\treturn x;\n\t}\n\n\tchar c = key.charAt(d);\n\tx.next[c] = put(x.next[c], key, val, d + 1);\n\treturn x;\n}\n}\n```\n\n###三向单词查找树（Ternary search tries TSTs）\n为了避免R向单词查找树过度的空间消耗， 还有另一种数据的表示方法：三向单词查找树（TST）。在三向单词查找树中，每个节点都含有一个字符、三条链接和一个值。这三条链接分别对应着当前字母小于、等于和大于节点字母的所有键。\n\n####节点表示\n图四表示了R向单词查找树到三向单词查找树的转化。和R向单词查找树不一样的是，字符和键都是显示的存储在节点中的。\n\n![trie3](/img/trie-4.png)\n\n下面是TST的java实现：\n``` java\npublic class TST<Value> {\n\tprivate Node root;\n\n\tprivate class Node {\n\t\tchar c;\n\t\tNode left, mid, right;\n\t\tValue val;\n\t}\n\n\tpublic Value get(String key) {\n\t\tNode x = get(root, key, 0);\n\t\tif (x == null) return null;\n\t\treturn (Value) x.val;\n\t}\n\n\tprivate Node get(Node x, String key, int d) {\n\t\tif (x == null) return null;\n\t\tchar c = key.charAt(d);\n\n\t\tif (c < x.c) {\n\t\t\treturn get(x.left, key, d);\n\t\t} else if (c > x.c) {\n\t\t\treturn get(x.right, key, d);\n\t\t} else if (d < key.length - 1) {\n\t\t\treturn get(x.mid, key, d+1);\n\t\t} else {\n\t\t\treturn x;\n\t\t}\n\t}\n\n\tpublic void put(String key, Value val) {\n\t\troot = put(root, key, val, 0);\n\t}\n\n\tprivate Node put(Node x, String key, Value val, int d) {\n\t\tchar c = key.charAt(d);\n\t\tif (x == null) {\n\t\t\tx = new Node();\n\t\t\tx.c = c;\n\t\t}\n\n\t\tif (c < x.c) {\n\t\t\tx.left = put(x.left, key, val, d);\n\t\t} else if (c > x.c) {\n\t\t\tx.right = put(x.right, key, val, d);\n\t\t} else if (d < key.length()  - 1) {\n\t\t\tx.mid = put(x.mid, key, val, d+1);\n\t\t} else {\n\t\t\tx.val = val;\n\t\t}\n\n\t\treturn x;\n\t}\n}\n```","slug":"2014-08-11-trie","published":1,"updated":"2015-04-30T11:46:42.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck5v0048rwmwmjucpe3p"},{"layout":"post","title":"子字符串查找——暴力查找与KMP算法","date":"2014-08-06T06:03:20.000Z","_content":"\n\n在这篇文章里，主要分析子字符串查找的两种算法：暴力查找和KMP算法。\n\n###1.暴力查找\n子字符串查找最简单的方法就是在需要查找的字符串(text)中模式(pattern)可能出现匹配的任何地方检查匹配是否存在。代码如下：\n``` java\npublic static int search(String pat, String text) {\n\tint M = pat.length();\n\tint N = text.length();\n\tfor (int i = 0; i <= N - M; i++) {\n\t\tint j;\n\t\tfor (j = 0; j < M; j++) {\n\t\t\tif (text.charAt(i) ！= pat.charAt(j))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == M) \n\t\t\treturn i;\t//找到匹配\n\t}\n\treturn -1;\t\t//没找到匹配，返回-1\n}\n```\n\n在程序中，我们使用了一个指针`i`来跟踪文本，一个指针`j`来跟踪模式。对每一个可能的`i(i<=M-N)`,将文本和模式进行匹配，如果模式的字符和文本的字符匹配，则将指针`j`加`1`。如果最后指针`j`为`M`，那么说明在位置`i`上文本和字符串是匹配的，返回位置`i`。否则返回`-1`，说明没有找到匹配。\n\n这种朴素的查找方法思路简单，也很容易实现，但是时间复杂度高，最坏情况下，时间复杂度约为`MN`,所以我们想追求速度更快的子字符窜查找算法。\n\n在暴力查找算法中，在每个位置`i`上，如果模式没有匹配，我们就直接把指针`i`回溯到`i+1`,在这种情况下，我们会浪费掉我们已经匹配过的`j`个字符的信息，所以，KMP算法就是通过利用这几个字符串的信息，减少指针`i`的回溯，而达到查找的时间复杂度为`O(N)`的目的的。\n\n###2.KMP算法\nKMP算法是Knuth-Morris-Pratt算法的缩写。\n\n*在学习这个算法时，我是先看的《Algorithms》，但是上面讲的不是很容易懂，所以又看了《算法导论》，才把它看明白，所以以下都是基于算导，而且图也是直接截的算导的图。*\n\n\n在说KMP算法之前，我们先约定两个定义：\n\n> 1.如果对某个字符串`y`有`x=ωy`，则称字符串`ω`是`x`的前缀,记为`w<x`\n\n> 2.如果对某个字符串`y`有`x=yω`，则称字符串`ω`是`x`的后缀,记为`w>x`\n\n现在我们来看怎么利用一次失败的匹配中的`j`个已知字符。\n\n如图一中`(a)`所示，在这次匹配中，模式`P`相对于文本`T`的偏移量为`s`，在模式的`q+1`位置处，匹配失败。如果按照暴力查找中的思路，我们会将文本`T`的指针指向`s+1`处，但是我们观察模式`P`,我们会发现不需要把文本的指针回退`q`，如`(b)`所示，我们只要将指针回退到`s'=s+2`。\n\n接下来我们要找出指针回退的规律，同时我们用一个辅助数组`π[1..m]`,其中`m`为模式长度,并且约定如下：\n> 已知一个模式`P[1..m]`,模式`P`的前缀函数是函数`π:{1,2,...,m}→{0,1，...,m}`，满足`π[q]=max{k:k<q,且Pk为Pq的后缀}`\n\n> 简单点说就是假设`Pk`是`Pq`的一个前缀，那么`π[q]`为同时为`Pq`的前缀和缀的Pk的最长长度，例如模式`ABAB`,那么`AB`既是模式的前缀，同时也是模式的后缀，而且我们也找不出另外一个更长模式的子字符串既是模式的前缀又是模式的后缀。所以`π[4]=2`(因为必须是`Pk`必须是`Pq`的子字符串)。\n\n\n所以假设我们已经知道了前缀数组`π`，那么我们就可以根据当前的`q`值知道下一个可能的有效偏移`s'`。如图中`(b)`所示，`π[5]=3`，而`P3`既是`P5`的前缀同时也是`T[s+1..s+5]`的后缀(因为`P[1..5]`和`T[s+1..s+5]`匹配),所以我们可以知道下一个可能的有效偏移为`s'=s+(q-π[q])=s+(5-3)=s+2`。\n\n![kmp1](/img/kmp-1.png)<br>图一\n\n图二中，我们可以看到关于模式`ababaca`的完整前缀函数`π`：\n\n![kmp1](/img/kmp-2.png)<br>图二\n\n在图二中，我们能看到一个`π*`数组，我们也给它一个定义\n> 设P是长度为`m`的模式，其前缀函数为`π`，对`q=1,2..m`,有`π*[q]={k: k<q且Pk为Pq的前缀}`。例如图二中`π*[5]={3,1,0}`。\n\n关于`π*`数组，我们还有一条性质在求`π`的时候能够用到\n> 若x=max{k∈π*[q-1], 且P[q+1]=P[x+1]},那么π[q]=k+1，否则π[q]=0\n\n> 其实这很好理解，如果我们能够在π*[q-1]数组中找到这么一个最大的x，使得 P[q+1]=P[x+1],那么π[q]=k+1。如果我们找不到这么一个x，那么π[q]=0\n\n那么现在的问题是怎么求前缀数组呢，我们先给出算导上的伪代码：\n\n```\n\tCompute-prefix-function(P)\n\t1 \tm = P.length\n\t2 \tlet π[1..m] be a new array\n\t3 \tπ[1] = 0\n\t4 \tk = 0\n\t5 \tfor q=2 to m\n\t6 \t\twhile k>0 and P[k+1] != P[q]\n\t7\t\t\tk=π[k]\n\t8\t\tif P[k+1] == P[q]\n\t9 \t\t\tk=k+1\n\t10\t\tπ[q] = k\n\t11\treturn π\n```\n\n我们接下来一行行分析\n\n> 1~2行： 对数组进行初始化\n>\n> 3~4行： 我们可以知道`π[1]=0`,同时我们令`k=π[q-1]=0`,这与循环结束后的条件保持一致\n>\n> 6~7行： 这里我们就是在π*[q-1]数组中寻找这么一个k值，使得P[k+1]=P[q],如果我们找到了这么一个k或者k为零，结束循环\n\n> 8~9行：如果我们在上两行找到的k值满足P[k+1]=P[q]，那说明我们找到了这么一个k值，那么π[q]=k+1；如果不满足条件，那说明k=0，而且P[1]!=P[q]，则π[q]=0\n\n到这里，我们就完成了前缀数组的计算。然后我们给出主程序的伪代码：\n\n```\n\tKMP-Matcher(T, p)\n\t1\tn=T.length\n\t2\tm=P.length\n\t3\tπ=Compute-prefix-function(P)\t\t\n\t4\tq=0\t\t\t\t\t\t\t\t\t\t//number of characters matched\n\t5 \tfor i=1 to n\t\t\t\t\t\t\t//scan the text from left to right\n\t6\t\twhile q>0 and P[q+1]!=T[i]\n\t7\t\t\tq=π[q]\t\t\t\t\t\t\t//next character does not match\n\t8\t\tif P[q+1]==T[i]\n\t9\t\t\tq=q+1\t\t\t\t\t\t\t//next character matches\t\n\t10\t\tif q==m\t\t\t\t\t\t\t\t//is all of P matched?\t\t\t\n\t11\t\t\tprint \"Pattern occurs with shift\" i-m\t\n\t12 \t\t\tq=π[q]\t\t\t\t\t\t\t//look for the next match\t\n```\n\n啦啦啦,KMP算法就这样啦，主要参考的是《algorithms》和《算法导论》,在第一本书中将的不如算导中好（个人感觉），所以推荐看算导。\n\n最后附上Java实现代码：\n``` java\npublic class KMP {\n    private String pat;\n    private int[] pi;\n\n    public KMP(String pat) {\n        this.pat = pat;\n        int M = pat.length();\n        pi = new int[M];\n\n        pi[0] = 0;\n        int k = 0;\n\n        for (int i = 1; i < M; i++) {\n            while (k > 0 && pat.charAt(k) != pat.charAt(i))\n                k = pi[k-1];\n\n            if (pat.charAt(k) == pat.charAt(i))\n                k = k + 1;\n\n            pi[i] = k;\n        }\n    }\n\n    public void search(String txt) {\n        int N = txt.length();\n        int M = pat.length();\n\n        int q = 0;\n        for (int i = 0; i < N; i++) {\n            while (q > 0 && pat.charAt(q) != txt.charAt(i))\n                q = pi[q-1];\n\n            if (pat.charAt(q) == txt.charAt(i))\n               q = q + 1;\n\n            if (q == M) {\n                System.out.println(\"pattern occurs with shift \" + (i - M + 1));\n                q = pi[q-1];\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        String pat = \"ab\";\n        String txt = \"ababc\";\n        KMP kmp = new KMP(pat);\n        kmp.search(txt);\n    }\n}\n```","source":"_posts/2014-08-06-brute_search_and_KMP.md","raw":"---\nlayout: post\ntitle:  \"子字符串查找——暴力查找与KMP算法\"\ndate:   2014-08-06 14:03:20\ncategories:   algorithms\n---\n\n\n在这篇文章里，主要分析子字符串查找的两种算法：暴力查找和KMP算法。\n\n###1.暴力查找\n子字符串查找最简单的方法就是在需要查找的字符串(text)中模式(pattern)可能出现匹配的任何地方检查匹配是否存在。代码如下：\n``` java\npublic static int search(String pat, String text) {\n\tint M = pat.length();\n\tint N = text.length();\n\tfor (int i = 0; i <= N - M; i++) {\n\t\tint j;\n\t\tfor (j = 0; j < M; j++) {\n\t\t\tif (text.charAt(i) ！= pat.charAt(j))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == M) \n\t\t\treturn i;\t//找到匹配\n\t}\n\treturn -1;\t\t//没找到匹配，返回-1\n}\n```\n\n在程序中，我们使用了一个指针`i`来跟踪文本，一个指针`j`来跟踪模式。对每一个可能的`i(i<=M-N)`,将文本和模式进行匹配，如果模式的字符和文本的字符匹配，则将指针`j`加`1`。如果最后指针`j`为`M`，那么说明在位置`i`上文本和字符串是匹配的，返回位置`i`。否则返回`-1`，说明没有找到匹配。\n\n这种朴素的查找方法思路简单，也很容易实现，但是时间复杂度高，最坏情况下，时间复杂度约为`MN`,所以我们想追求速度更快的子字符窜查找算法。\n\n在暴力查找算法中，在每个位置`i`上，如果模式没有匹配，我们就直接把指针`i`回溯到`i+1`,在这种情况下，我们会浪费掉我们已经匹配过的`j`个字符的信息，所以，KMP算法就是通过利用这几个字符串的信息，减少指针`i`的回溯，而达到查找的时间复杂度为`O(N)`的目的的。\n\n###2.KMP算法\nKMP算法是Knuth-Morris-Pratt算法的缩写。\n\n*在学习这个算法时，我是先看的《Algorithms》，但是上面讲的不是很容易懂，所以又看了《算法导论》，才把它看明白，所以以下都是基于算导，而且图也是直接截的算导的图。*\n\n\n在说KMP算法之前，我们先约定两个定义：\n\n> 1.如果对某个字符串`y`有`x=ωy`，则称字符串`ω`是`x`的前缀,记为`w<x`\n\n> 2.如果对某个字符串`y`有`x=yω`，则称字符串`ω`是`x`的后缀,记为`w>x`\n\n现在我们来看怎么利用一次失败的匹配中的`j`个已知字符。\n\n如图一中`(a)`所示，在这次匹配中，模式`P`相对于文本`T`的偏移量为`s`，在模式的`q+1`位置处，匹配失败。如果按照暴力查找中的思路，我们会将文本`T`的指针指向`s+1`处，但是我们观察模式`P`,我们会发现不需要把文本的指针回退`q`，如`(b)`所示，我们只要将指针回退到`s'=s+2`。\n\n接下来我们要找出指针回退的规律，同时我们用一个辅助数组`π[1..m]`,其中`m`为模式长度,并且约定如下：\n> 已知一个模式`P[1..m]`,模式`P`的前缀函数是函数`π:{1,2,...,m}→{0,1，...,m}`，满足`π[q]=max{k:k<q,且Pk为Pq的后缀}`\n\n> 简单点说就是假设`Pk`是`Pq`的一个前缀，那么`π[q]`为同时为`Pq`的前缀和缀的Pk的最长长度，例如模式`ABAB`,那么`AB`既是模式的前缀，同时也是模式的后缀，而且我们也找不出另外一个更长模式的子字符串既是模式的前缀又是模式的后缀。所以`π[4]=2`(因为必须是`Pk`必须是`Pq`的子字符串)。\n\n\n所以假设我们已经知道了前缀数组`π`，那么我们就可以根据当前的`q`值知道下一个可能的有效偏移`s'`。如图中`(b)`所示，`π[5]=3`，而`P3`既是`P5`的前缀同时也是`T[s+1..s+5]`的后缀(因为`P[1..5]`和`T[s+1..s+5]`匹配),所以我们可以知道下一个可能的有效偏移为`s'=s+(q-π[q])=s+(5-3)=s+2`。\n\n![kmp1](/img/kmp-1.png)<br>图一\n\n图二中，我们可以看到关于模式`ababaca`的完整前缀函数`π`：\n\n![kmp1](/img/kmp-2.png)<br>图二\n\n在图二中，我们能看到一个`π*`数组，我们也给它一个定义\n> 设P是长度为`m`的模式，其前缀函数为`π`，对`q=1,2..m`,有`π*[q]={k: k<q且Pk为Pq的前缀}`。例如图二中`π*[5]={3,1,0}`。\n\n关于`π*`数组，我们还有一条性质在求`π`的时候能够用到\n> 若x=max{k∈π*[q-1], 且P[q+1]=P[x+1]},那么π[q]=k+1，否则π[q]=0\n\n> 其实这很好理解，如果我们能够在π*[q-1]数组中找到这么一个最大的x，使得 P[q+1]=P[x+1],那么π[q]=k+1。如果我们找不到这么一个x，那么π[q]=0\n\n那么现在的问题是怎么求前缀数组呢，我们先给出算导上的伪代码：\n\n```\n\tCompute-prefix-function(P)\n\t1 \tm = P.length\n\t2 \tlet π[1..m] be a new array\n\t3 \tπ[1] = 0\n\t4 \tk = 0\n\t5 \tfor q=2 to m\n\t6 \t\twhile k>0 and P[k+1] != P[q]\n\t7\t\t\tk=π[k]\n\t8\t\tif P[k+1] == P[q]\n\t9 \t\t\tk=k+1\n\t10\t\tπ[q] = k\n\t11\treturn π\n```\n\n我们接下来一行行分析\n\n> 1~2行： 对数组进行初始化\n>\n> 3~4行： 我们可以知道`π[1]=0`,同时我们令`k=π[q-1]=0`,这与循环结束后的条件保持一致\n>\n> 6~7行： 这里我们就是在π*[q-1]数组中寻找这么一个k值，使得P[k+1]=P[q],如果我们找到了这么一个k或者k为零，结束循环\n\n> 8~9行：如果我们在上两行找到的k值满足P[k+1]=P[q]，那说明我们找到了这么一个k值，那么π[q]=k+1；如果不满足条件，那说明k=0，而且P[1]!=P[q]，则π[q]=0\n\n到这里，我们就完成了前缀数组的计算。然后我们给出主程序的伪代码：\n\n```\n\tKMP-Matcher(T, p)\n\t1\tn=T.length\n\t2\tm=P.length\n\t3\tπ=Compute-prefix-function(P)\t\t\n\t4\tq=0\t\t\t\t\t\t\t\t\t\t//number of characters matched\n\t5 \tfor i=1 to n\t\t\t\t\t\t\t//scan the text from left to right\n\t6\t\twhile q>0 and P[q+1]!=T[i]\n\t7\t\t\tq=π[q]\t\t\t\t\t\t\t//next character does not match\n\t8\t\tif P[q+1]==T[i]\n\t9\t\t\tq=q+1\t\t\t\t\t\t\t//next character matches\t\n\t10\t\tif q==m\t\t\t\t\t\t\t\t//is all of P matched?\t\t\t\n\t11\t\t\tprint \"Pattern occurs with shift\" i-m\t\n\t12 \t\t\tq=π[q]\t\t\t\t\t\t\t//look for the next match\t\n```\n\n啦啦啦,KMP算法就这样啦，主要参考的是《algorithms》和《算法导论》,在第一本书中将的不如算导中好（个人感觉），所以推荐看算导。\n\n最后附上Java实现代码：\n``` java\npublic class KMP {\n    private String pat;\n    private int[] pi;\n\n    public KMP(String pat) {\n        this.pat = pat;\n        int M = pat.length();\n        pi = new int[M];\n\n        pi[0] = 0;\n        int k = 0;\n\n        for (int i = 1; i < M; i++) {\n            while (k > 0 && pat.charAt(k) != pat.charAt(i))\n                k = pi[k-1];\n\n            if (pat.charAt(k) == pat.charAt(i))\n                k = k + 1;\n\n            pi[i] = k;\n        }\n    }\n\n    public void search(String txt) {\n        int N = txt.length();\n        int M = pat.length();\n\n        int q = 0;\n        for (int i = 0; i < N; i++) {\n            while (q > 0 && pat.charAt(q) != txt.charAt(i))\n                q = pi[q-1];\n\n            if (pat.charAt(q) == txt.charAt(i))\n               q = q + 1;\n\n            if (q == M) {\n                System.out.println(\"pattern occurs with shift \" + (i - M + 1));\n                q = pi[q-1];\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        String pat = \"ab\";\n        String txt = \"ababc\";\n        KMP kmp = new KMP(pat);\n        kmp.search(txt);\n    }\n}\n```","slug":"2014-08-06-brute_search_and_KMP","published":1,"updated":"2015-04-30T11:24:21.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck5x004arwmws8q5eufw"},{"layout":"post","title":"Ubuntu 12.04 配置两级Rsyslog","date":"2014-08-03T16:00:00.000Z","_content":"\n###升级Rsyslog\n由于要使用Rsyslog的日志动态文件名的功能，必须将Rsyslog升级到高的版本（ubuntu上自带的版本为5.8.*）。升级的方式使用`apt-get install`\n```\n    1.修改/etc/apt/sources.list,添加如下两行：\n    deb http://ubuntu.adiscon.com/v7-stable precise/\n    deb-src http://ubuntu.adiscon.com/v7-stable precise/\n    2.添加PGP Key\n    sudo apt-key adv --recv-keys --keyserver keyserver.ubuntu.com AEF0CF8E\n    gpg --export --armor AEF0CF8E | sudo apt-key add -\n    2.sudo apt-get update && apt-get upgrade\n    如果出现：\n    The following packages have been kept back:\n    rsyslog\n    使用apt-get install rsyslog安装\n```\n###修改配置文件/etc/rsyslog.conf\n\n```\n    1.由于升级版本后配置文件还是使用原来的，在服务器端和客户端都注释掉如下几行：\n    #$FileOwner syslog                                       \n    #$FileGroup adm\n    #$FileCreateMode 0640                                    \n    #$DirCreateMode 0755                                     \n    #$Umask 0022\n    #$PrivDropToUser syslog\n    #$PrivDropToGroup syslog  \n    （为什么要注释这几行，应该是rsyslog在ubuntu上的bug，特别是Ubuntu12.04，\n    如果注释的话，没法创建动态文件名的日志，但是注释掉的话，文件夹和文件都是使\n    用root创建的：\n    drwx------  2 root      root   4096  8Ղ 21 09:27 ubuntu/\n    -rw-r--r--  1 root      root  31605  8Ղ 21 14:40 appversion.log\n    ）\n    2.服务器端配置：\n    #使用tcp协议接收日志\n    module(load=\"imtcp\") #加载模块imtcp\n    input(type=\"imtcp\" port=\"514\")    #启动端口监听\n    #根据不同的app_version（uuid，格式为xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxx）\n    #生成不同的文件\n    $template DynFile,\"/var/log/%rawmsg:1:36%.log\"\n\n    *.*     -?DynFile #以后可以改进，只是对其他机器的日志进行过滤\n    3.客户端配置：\n    module(load=\"imudp\")    #加载模块imdup\n    input(type=\"imudp\" port=\"514\") #启动端口监听，接收来自Log4j的日志，因为是本地，所以可以使用udp\n    \n    #在消息的前面添加app_version\n    template (name=\"tpl\" type=\"list\") {\n      constant(value=\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxx\")\n      property(name=\"rawmsg\")\n      constant(value=\"\\n\")\n    }\n \n    local1.* @@10.1.59.241:514;tpl #发送到服务端，使用tcp协议\n```\n###以Log4j为例，将Log4j的日志写入本地rsyslog，然后发送给日志服务器\n```\n    1.log4j.properties的配置\n\n    log4j.rootLogger=DEBUG, SYSLOG \n    log4j.appender.SYSLOG=org.apache.log4j.net.SyslogAppender  \n    log4j.appender.SYSLOG.syslogHost=127.0.0.1\n    log4j.appender.syslog.Threshold=DEBUG  \n    log4j.appender.SYSLOG.layout=org.apache.log4j.PatternLayout  \n    log4j.appender.SYSLOG.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n  \n    log4j.appender.SYSLOG.Header=true\n    log4j.appender.SYSLOG.Facility=local1\n    \n    2.java代码示例：\n    \n    import org.apache.log4j.Logger;\n    public class Log {\n        private static Logger logger = Logger.getLogger(LogTest.class);\n        public static void main(String[] args) {\n            logger.debug(\"this is debug message\");\n            logger.info(\"this is info message\");\n        }\n    }\n```","source":"_posts/2014-08-04-ubuntu-rsyslog.md","raw":"---\nlayout: post\ntitle:  \"Ubuntu 12.04 配置两级Rsyslog\"\ncategory: linux\ndate:   2014-08-04\n---\n\n###升级Rsyslog\n由于要使用Rsyslog的日志动态文件名的功能，必须将Rsyslog升级到高的版本（ubuntu上自带的版本为5.8.*）。升级的方式使用`apt-get install`\n```\n    1.修改/etc/apt/sources.list,添加如下两行：\n    deb http://ubuntu.adiscon.com/v7-stable precise/\n    deb-src http://ubuntu.adiscon.com/v7-stable precise/\n    2.添加PGP Key\n    sudo apt-key adv --recv-keys --keyserver keyserver.ubuntu.com AEF0CF8E\n    gpg --export --armor AEF0CF8E | sudo apt-key add -\n    2.sudo apt-get update && apt-get upgrade\n    如果出现：\n    The following packages have been kept back:\n    rsyslog\n    使用apt-get install rsyslog安装\n```\n###修改配置文件/etc/rsyslog.conf\n\n```\n    1.由于升级版本后配置文件还是使用原来的，在服务器端和客户端都注释掉如下几行：\n    #$FileOwner syslog                                       \n    #$FileGroup adm\n    #$FileCreateMode 0640                                    \n    #$DirCreateMode 0755                                     \n    #$Umask 0022\n    #$PrivDropToUser syslog\n    #$PrivDropToGroup syslog  \n    （为什么要注释这几行，应该是rsyslog在ubuntu上的bug，特别是Ubuntu12.04，\n    如果注释的话，没法创建动态文件名的日志，但是注释掉的话，文件夹和文件都是使\n    用root创建的：\n    drwx------  2 root      root   4096  8Ղ 21 09:27 ubuntu/\n    -rw-r--r--  1 root      root  31605  8Ղ 21 14:40 appversion.log\n    ）\n    2.服务器端配置：\n    #使用tcp协议接收日志\n    module(load=\"imtcp\") #加载模块imtcp\n    input(type=\"imtcp\" port=\"514\")    #启动端口监听\n    #根据不同的app_version（uuid，格式为xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxx）\n    #生成不同的文件\n    $template DynFile,\"/var/log/%rawmsg:1:36%.log\"\n\n    *.*     -?DynFile #以后可以改进，只是对其他机器的日志进行过滤\n    3.客户端配置：\n    module(load=\"imudp\")    #加载模块imdup\n    input(type=\"imudp\" port=\"514\") #启动端口监听，接收来自Log4j的日志，因为是本地，所以可以使用udp\n    \n    #在消息的前面添加app_version\n    template (name=\"tpl\" type=\"list\") {\n      constant(value=\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxx\")\n      property(name=\"rawmsg\")\n      constant(value=\"\\n\")\n    }\n \n    local1.* @@10.1.59.241:514;tpl #发送到服务端，使用tcp协议\n```\n###以Log4j为例，将Log4j的日志写入本地rsyslog，然后发送给日志服务器\n```\n    1.log4j.properties的配置\n\n    log4j.rootLogger=DEBUG, SYSLOG \n    log4j.appender.SYSLOG=org.apache.log4j.net.SyslogAppender  \n    log4j.appender.SYSLOG.syslogHost=127.0.0.1\n    log4j.appender.syslog.Threshold=DEBUG  \n    log4j.appender.SYSLOG.layout=org.apache.log4j.PatternLayout  \n    log4j.appender.SYSLOG.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n  \n    log4j.appender.SYSLOG.Header=true\n    log4j.appender.SYSLOG.Facility=local1\n    \n    2.java代码示例：\n    \n    import org.apache.log4j.Logger;\n    public class Log {\n        private static Logger logger = Logger.getLogger(LogTest.class);\n        public static void main(String[] args) {\n            logger.debug(\"this is debug message\");\n            logger.info(\"this is info message\");\n        }\n    }\n```","slug":"2014-08-04-ubuntu-rsyslog","published":1,"updated":"2015-04-30T11:18:31.000Z","comments":1,"photos":[],"link":"","_id":"cif6xck5z004crwmwkire7ysd"}],"PostAsset":[],"PostCategory":[{"post_id":"cif6xck0s0002rwmw817ikfgp","category_id":"cif6xck0v0003rwmwirllm89u","_id":"cif6xck0w0004rwmwl7da1v08"},{"post_id":"cif6xck0y0005rwmwti07owir","category_id":"cif6xck0z0006rwmwphcl9us4","_id":"cif6xck0z0007rwmwap9m4exd"},{"post_id":"cif6xck100008rwmwplxisvn7","category_id":"cif6xck110009rwmwixl25zvt","_id":"cif6xck11000arwmwsd0lpznh"},{"post_id":"cif6xck12000brwmw7nitrwo3","category_id":"cif6xck1a000crwmwfcg4ftbv","_id":"cif6xck1a000drwmw6fo19jkp"},{"post_id":"cif6xck1c000erwmw21ekseud","category_id":"cif6xck1d000frwmwmdzt8rzd","_id":"cif6xck1e000irwmw8bj771mm"},{"post_id":"cif6xck1f000jrwmwzajgxgjr","category_id":"cif6xck1h000krwmwpo2w51m4","_id":"cif6xck1i000lrwmwmz60oleh"},{"post_id":"cif6xck1j000mrwmwogm17sra","category_id":"cif6xck1h000krwmwpo2w51m4","_id":"cif6xck1k000nrwmwngl9cjey"},{"post_id":"cif6xck1l000orwmww6cx7cqi","category_id":"cif6xck1h000krwmwpo2w51m4","_id":"cif6xck1n000prwmwv3wr4p74"},{"post_id":"cif6xck1o000qrwmwkudn09p5","category_id":"cif6xck1d000frwmwmdzt8rzd","_id":"cif6xck1p000rrwmws9j6lrjv"},{"post_id":"cif6xck1q000trwmwl01y037w","category_id":"cif6xck1d000frwmwmdzt8rzd","_id":"cif6xck1r000urwmwbyfivpct"},{"post_id":"cif6xck1s000vrwmwesz7ts28","category_id":"cif6xck1d000frwmwmdzt8rzd","_id":"cif6xck1t000wrwmwfn5japji"},{"post_id":"cif6xck1u000yrwmwzzvn3ghe","category_id":"cif6xck1d000frwmwmdzt8rzd","_id":"cif6xck1v000zrwmw726xqzoy"},{"post_id":"cif6xck1w0011rwmw7evryd2b","category_id":"cif6xck1d000frwmwmdzt8rzd","_id":"cif6xck1x0012rwmwvt0xg21n"},{"post_id":"cif6xck1y0014rwmw8gn6acn9","category_id":"cif6xck1h000krwmwpo2w51m4","_id":"cif6xck1z0015rwmwxymxn678"},{"post_id":"cif6xck1z0016rwmww0xxw00c","category_id":"cif6xck200017rwmwup5tbh7q","_id":"cif6xck210018rwmw9frwk7q3"},{"post_id":"cif6xck220019rwmwiflvncjx","category_id":"cif6xck200017rwmwup5tbh7q","_id":"cif6xck23001arwmwjtlhjf9c"},{"post_id":"cif6xck24001brwmwd4zds3ke","category_id":"cif6xck1d000frwmwmdzt8rzd","_id":"cif6xck26001crwmwhzaxoh8y"},{"post_id":"cif6xck27001erwmwscta5tm1","category_id":"cif6xck200017rwmwup5tbh7q","_id":"cif6xck27001frwmwh1ubqjrl"},{"post_id":"cif6xck28001grwmwyu3vdlpv","category_id":"cif6xck200017rwmwup5tbh7q","_id":"cif6xck29001hrwmw2ajuwzb0"},{"post_id":"cif6xck2b001krwmwms53lgn7","category_id":"cif6xck2c001lrwmw3pqkkmro","_id":"cif6xck2c001mrwmwnhv9aj05"},{"post_id":"cif6xck2d001nrwmwua2vosmm","category_id":"cif6xck2c001lrwmw3pqkkmro","_id":"cif6xck2e001orwmwsa43vp1m"},{"post_id":"cif6xck2g001prwmwcshtxra3","category_id":"cif6xck2c001lrwmw3pqkkmro","_id":"cif6xck2h001qrwmwxudclkb5"},{"post_id":"cif6xck2j001trwmwzew3ebhz","category_id":"cif6xck1d000frwmwmdzt8rzd","_id":"cif6xck2k001urwmwdiuf72of"},{"post_id":"cif6xck2l001vrwmwsqm4k773","category_id":"cif6xck2c001lrwmw3pqkkmro","_id":"cif6xck2m001wrwmw4sqtokxd"},{"post_id":"cif6xck2m001xrwmwuhlyr0v8","category_id":"cif6xck2c001lrwmw3pqkkmro","_id":"cif6xck2n001yrwmwz4btj7dy"},{"post_id":"cif6xck2o001zrwmwieybftp4","category_id":"cif6xck2c001lrwmw3pqkkmro","_id":"cif6xck2p0020rwmwi07votrg"},{"post_id":"cif6xck2q0021rwmwl06puwyi","category_id":"cif6xck2c001lrwmw3pqkkmro","_id":"cif6xck2s0022rwmw3909req5"},{"post_id":"cif6xck2t0023rwmw7x9l8v9y","category_id":"cif6xck1d000frwmwmdzt8rzd","_id":"cif6xck2u0024rwmwo7j944mu"},{"post_id":"cif6xck2v0025rwmwtsjfblvj","category_id":"cif6xck1d000frwmwmdzt8rzd","_id":"cif6xck2v0026rwmw22mf3bmw"},{"post_id":"cif6xck2w0027rwmwmdincvlh","category_id":"cif6xck1a000crwmwfcg4ftbv","_id":"cif6xck2x0028rwmwn2kop97a"},{"post_id":"cif6xck2y0029rwmwdtu8b27v","category_id":"cif6xck1d000frwmwmdzt8rzd","_id":"cif6xck2z002arwmws6ta7ksc"},{"post_id":"cif6xck30002brwmwbbo2qeqe","category_id":"cif6xck2c001lrwmw3pqkkmro","_id":"cif6xck31002crwmwtmwz135b"},{"post_id":"cif6xck32002drwmw0sg4ygfq","category_id":"cif6xck2c001lrwmw3pqkkmro","_id":"cif6xck33002erwmwiedd6y3x"},{"post_id":"cif6xck34002frwmwfee1lnsb","category_id":"cif6xck2c001lrwmw3pqkkmro","_id":"cif6xck35002grwmwp91y54tm"},{"post_id":"cif6xck36002hrwmw2zyt50dz","category_id":"cif6xck2c001lrwmw3pqkkmro","_id":"cif6xck37002irwmw6bk4gqhk"},{"post_id":"cif6xck38002lrwmw1k18101h","category_id":"cif6xck2c001lrwmw3pqkkmro","_id":"cif6xck39002mrwmw11qt04re"},{"post_id":"cif6xck3a002nrwmwxbwrx0k4","category_id":"cif6xck2c001lrwmw3pqkkmro","_id":"cif6xck3b002orwmw4nlrad2k"},{"post_id":"cif6xck3c002qrwmwqopvrpdj","category_id":"cif6xck2c001lrwmw3pqkkmro","_id":"cif6xck3d002rrwmwor8l8xd7"},{"post_id":"cif6xck3f002trwmwb7z12uxm","category_id":"cif6xck1d000frwmwmdzt8rzd","_id":"cif6xck3g002urwmwd54tvs4o"},{"post_id":"cif6xck3h002vrwmwqg1hdtqg","category_id":"cif6xck200017rwmwup5tbh7q","_id":"cif6xck3i002wrwmwx7dvg8wb"},{"post_id":"cif6xck3l002xrwmw137s17hg","category_id":"cif6xck2c001lrwmw3pqkkmro","_id":"cif6xck3m002yrwmwv2smgvk5"},{"post_id":"cif6xck3n0030rwmwd3q28g7n","category_id":"cif6xck2c001lrwmw3pqkkmro","_id":"cif6xck3o0031rwmw8ygxkf36"},{"post_id":"cif6xck3p0032rwmw8b3rda48","category_id":"cif6xck200017rwmwup5tbh7q","_id":"cif6xck3p0033rwmw6sgsx8n0"},{"post_id":"cif6xck4a0034rwmwynp139mn","category_id":"cif6xck2c001lrwmw3pqkkmro","_id":"cif6xck4b0035rwmwpnombvfv"},{"post_id":"cif6xck4c0037rwmwabghdw19","category_id":"cif6xck1d000frwmwmdzt8rzd","_id":"cif6xck4c0038rwmw52rrzwxi"},{"post_id":"cif6xck4f0039rwmwjjggllwo","category_id":"cif6xck200017rwmwup5tbh7q","_id":"cif6xck4g003arwmw8ttt58k5"},{"post_id":"cif6xck4h003brwmwnjc4325z","category_id":"cif6xck200017rwmwup5tbh7q","_id":"cif6xck4i003crwmw8bl3xcew"},{"post_id":"cif6xck4m003drwmw89zxurxw","category_id":"cif6xck200017rwmwup5tbh7q","_id":"cif6xck4n003erwmwg69fnd61"},{"post_id":"cif6xck4o003frwmw6cy54hmi","category_id":"cif6xck200017rwmwup5tbh7q","_id":"cif6xck4p003grwmwvk2x6pes"},{"post_id":"cif6xck4t003hrwmwuhysmpu3","category_id":"cif6xck1d000frwmwmdzt8rzd","_id":"cif6xck4u003irwmw9wzyi5d2"},{"post_id":"cif6xck4w003jrwmw4yy0xso0","category_id":"cif6xck1d000frwmwmdzt8rzd","_id":"cif6xck4w003krwmwearr1ofv"},{"post_id":"cif6xck50003lrwmw72lqlab4","category_id":"cif6xck1d000frwmwmdzt8rzd","_id":"cif6xck51003mrwmwh8v3u89h"},{"post_id":"cif6xck57003orwmwj9xc0syg","category_id":"cif6xck1d000frwmwmdzt8rzd","_id":"cif6xck58003prwmwci8w9my3"},{"post_id":"cif6xck59003rrwmwdp60dwwl","category_id":"cif6xck1d000frwmwmdzt8rzd","_id":"cif6xck5a003srwmwfod96l03"},{"post_id":"cif6xck5g003urwmwna8fnyfl","category_id":"cif6xck1d000frwmwmdzt8rzd","_id":"cif6xck5h003vrwmwytpks4lc"},{"post_id":"cif6xck5i003wrwmw5zhoa672","category_id":"cif6xck1d000frwmwmdzt8rzd","_id":"cif6xck5j003xrwmw0ztr11bc"},{"post_id":"cif6xck5k003zrwmw6g0q83gy","category_id":"cif6xck1d000frwmwmdzt8rzd","_id":"cif6xck5l0040rwmwmujpgmsp"},{"post_id":"cif6xck5n0042rwmw9j4i4tb6","category_id":"cif6xck2c001lrwmw3pqkkmro","_id":"cif6xck5n0043rwmwenskkexo"},{"post_id":"cif6xck5o0044rwmwbmvmxc9m","category_id":"cif6xck2c001lrwmw3pqkkmro","_id":"cif6xck5p0045rwmwaxs875mj"},{"post_id":"cif6xck5p0046rwmwbmo319mm","category_id":"cif6xck2c001lrwmw3pqkkmro","_id":"cif6xck5v0047rwmwc4d7jbw3"},{"post_id":"cif6xck5v0048rwmwmjucpe3p","category_id":"cif6xck2c001lrwmw3pqkkmro","_id":"cif6xck5w0049rwmwj0u5v77r"},{"post_id":"cif6xck5x004arwmws8q5eufw","category_id":"cif6xck2c001lrwmw3pqkkmro","_id":"cif6xck5y004brwmwflmfpn9g"},{"post_id":"cif6xck5z004crwmwkire7ysd","category_id":"cif6xck1a000crwmwfcg4ftbv","_id":"cif6xck60004drwmwnuj8x4vn"}],"PostTag":[{"post_id":"cif6xck1c000erwmw21ekseud","tag_id":"cif6xck1d000grwmw7yb9vo48","_id":"cif6xck1e000hrwmw3cqigqiy"},{"post_id":"cif6xck1o000qrwmwkudn09p5","tag_id":"cif6xck1d000grwmw7yb9vo48","_id":"cif6xck1p000srwmwrzrn15lh"},{"post_id":"cif6xck1s000vrwmwesz7ts28","tag_id":"cif6xck1d000grwmw7yb9vo48","_id":"cif6xck1t000xrwmw2k0e669z"},{"post_id":"cif6xck1u000yrwmwzzvn3ghe","tag_id":"cif6xck1d000grwmw7yb9vo48","_id":"cif6xck1v0010rwmwcd5yt9e8"},{"post_id":"cif6xck1w0011rwmw7evryd2b","tag_id":"cif6xck1d000grwmw7yb9vo48","_id":"cif6xck1x0013rwmw9mqx0s93"},{"post_id":"cif6xck24001brwmwd4zds3ke","tag_id":"cif6xck1d000grwmw7yb9vo48","_id":"cif6xck26001drwmw35qxzfrs"},{"post_id":"cif6xck28001grwmwyu3vdlpv","tag_id":"cif6xck2a001irwmwbmnuyfhl","_id":"cif6xck2a001jrwmw7m39rjsi"},{"post_id":"cif6xck2g001prwmwcshtxra3","tag_id":"cif6xck2i001rrwmwrrknlibc","_id":"cif6xck2i001srwmwk9n8nga0"},{"post_id":"cif6xck36002hrwmw2zyt50dz","tag_id":"cif6xck37002jrwmwp2lf7hfp","_id":"cif6xck37002krwmww1wofgyo"},{"post_id":"cif6xck3a002nrwmwxbwrx0k4","tag_id":"cif6xck37002jrwmwp2lf7hfp","_id":"cif6xck3b002prwmw1q9otftf"},{"post_id":"cif6xck3c002qrwmwqopvrpdj","tag_id":"cif6xck2i001rrwmwrrknlibc","_id":"cif6xck3d002srwmw2uu3ybbg"},{"post_id":"cif6xck3l002xrwmw137s17hg","tag_id":"cif6xck37002jrwmwp2lf7hfp","_id":"cif6xck3m002zrwmwjnidm0qx"},{"post_id":"cif6xck4a0034rwmwynp139mn","tag_id":"cif6xck2i001rrwmwrrknlibc","_id":"cif6xck4b0036rwmwp3wzunge"},{"post_id":"cif6xck50003lrwmw72lqlab4","tag_id":"cif6xck1d000grwmw7yb9vo48","_id":"cif6xck51003nrwmw37cjc1ye"},{"post_id":"cif6xck57003orwmwj9xc0syg","tag_id":"cif6xck1d000grwmw7yb9vo48","_id":"cif6xck58003qrwmws65u9z46"},{"post_id":"cif6xck59003rrwmwdp60dwwl","tag_id":"cif6xck1d000grwmw7yb9vo48","_id":"cif6xck5a003trwmwjo8hki7y"},{"post_id":"cif6xck5i003wrwmw5zhoa672","tag_id":"cif6xck1d000grwmw7yb9vo48","_id":"cif6xck5j003yrwmwvav186zb"},{"post_id":"cif6xck5k003zrwmw6g0q83gy","tag_id":"cif6xck1d000grwmw7yb9vo48","_id":"cif6xck5l0041rwmwomzbxpdv"}],"Tag":[{"name":"动态规划","_id":"cif6xck1d000grwmw7yb9vo48"},{"name":"二分搜索","_id":"cif6xck2a001irwmwbmnuyfhl"},{"name":"二叉树","_id":"cif6xck2i001rrwmwrrknlibc"},{"name":"图","_id":"cif6xck37002jrwmwp2lf7hfp"}]}}