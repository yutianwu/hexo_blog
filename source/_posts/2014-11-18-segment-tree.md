---
layout: post
title:  "数据结构：线段树(segment tree)"
date:   2014-11-18 10:39:20
categories:   algorithms
mathjax: true
---

###线段树的概念

线段树是擅长处理区间的，形如下图的数据结构。线段树是一棵完美二叉树（Perfect Binary Tree)（所有的叶子的深度都相同，并且每个节点要么是叶子要么有2个儿子的树）树上的每个节点都维护一个区间。根维护的是整个区间，每个节点维护的是父亲的区间二等分后的其中一个子区间。当有$n$个元素时，对区间的操作可以在$O(\log{n})$的时间内完成。

![segment tree 1](/img/segment_tree_1.png)

根据节点中维护的数据不同，线段树可以提供不同的功能。比如说可以实现Range Mininum Query(RMQ)操作的线段树。

###基于线段树的RMQ结构

下面要建立的线段树在给定数列 $a _0$, $a_1$, ... ,$a^{n-1}$的情况下，可以在$O(\log{n})$ 时间内完成如下两种操作

+ 给定$s$和$t$，求$a_s$,$a^{s+1}$,...,$a_t$的最小值
+ 给定$i$和$x$，把$a_i$的值改成$x$

如图，线段树的每个节点维护对应区间的最下值。在建树时，只要按从下到上的顺序分别取左右儿子的值中的较小值就可以了。

![segment tree 1](/img/segment_tree_2.png)

###基于线段树的RMQ的查询

如果要求$a_0,...,a_6$的最小值，我们只需要求下图中的三个节点的值的最小值即可。

![segment tree 1](/img/segment_tree_3.png)

像这样，即使查询的是一个比较大的区间，由于较靠上的节点对应较大的区间，通过这些瓯可以知道大部分值的最小值，从而只需要访问很少的节点就可以求得最小值。

要求某个区间的最小值，像下面这样递归处理就可以了。

+ 如果所查询的区间和当前节点对应的区间完全没有交集，那么就返回一个不影响答案的值，例如INT_MAX
+ 如果所查询的区间完全包含了当前节点对应的区间，那么就返回当前节点的值
+ 以上两种情况都不满足的话，就对两个儿子递归处理，返回两个结果中的较小者。

###基于线段树的RMQ的值的更新
在更新$a_0$的值时，需要重新计算下图所示的4个节点的值。

![segment tree 1](/img/segment_tree_4.png)

在更新$a_i$的值时，需要对包含的所有区间对应的节点的值重新进行计算。在更新时，可以从下面的节点开始向上不断更新，把每个节点的值更新为左右两个儿子的值的较小者就可以了。

###基于线段树的RMQ的复杂度
不论哪种操作对于每个深度都最多访问常数个节点。因此对于$n$个元素，每一次操作的复杂度是$O(\log{n})$。对于二叉搜索树，我们曾经提到过可能有因操作不当而导致退化的情况发生，从而钱剁更这是很糟糕。不过因为线段树不会添加或者删除节点，所以即使是朴素的实现也都能在$O(\log{n})$时间内进行各种操作。

此外，$n$个元素的线段树的初始化的时间复杂度和总的空间复杂度都是$O(n)$。这是因为节点数是$n+n/2+n/4+...=2n-1$。直觉上很容易1以产生复杂度是$O(n\log{n})$的错觉，需要注意。


>$n+n/2+n/4+...=2n-1$的证明
><hr>
>
>$\because$ $1+2^1+2^2+...2^k=2^{k+1}-1=2\cdot2^k-1$(等比数列求和公式)而且$n=2^k$
>
>$\therefore$ $1+2+...n=1+2^1+2^2+...2^k=2n-1$

###基于线段树的RMQ的实现
为了简单起见，在建立线段树时，把数列所有的值都初始化为INT_MAX。此外，query的参数中不止传入节点的编号，还传入了节点对应的区间。虽然从节点的编号也可以计算出对应的区间但是把区间作为参数传入就可以节省这一步计算，为了简单起见，我们在实现中传入了对应的区间。

``` cpp
#include <iostream>
#include <math.h>

using namespace std;

const int MAX_N = 1 << 17;

int n, tree[2 * MAX_N - 1];

void init(int n_) {
    //将元素个数扩大到2的幂,这样的话，就能够保证是
    //完美二叉树
    n = 1;
    while (n < n_)
        n *= 2;
    
    //初始化
    for (int i = 0; i < n; i++)
        tree[i] = INT_MAX;
}

void update(int k, int a) {
    //根据公式，第k个叶子节点的下标
    k += n - 1;
    tree[k] = a;
    
    while (k > 0) {
        k = (k - 1) / 2;
        tree[k] = min(tree[k * 2 + 1], tree[k * 2 + 2]);
     }
}

/*
在这种求区间范围的题中，开区间和闭区间还是很重要的，
在这里，求的是左闭右开区间的值，所以在两个子查询中
就不用进行加一操作了
*/

//求[a, b)的最小值,
//后面的参数是为了计算起来方便而传入的
//k是节点的编号，l，r表示这个节点对应的是[l, r)区间。
//在外部调用时，使用query(a, b, 0, 0, n)

int query(int a, int b, int k, int l, int r) {
    if (r <= a || b <= l) return INT_MAX;
    
    if (a <= l && r <= b) return tree[k];
    else {
        int vl = query(a, b, k * 2 + 1, l, (l + r) / 2);
        int vr = query(a, b, k * 2 + 2, (l + r) / 2, r);
        return min(vl, vr);
    }
}
```